if not game:IsLoaded() then
	game.Loaded:Wait()
end

TidalWaveLoadStartTime = tick()

CloneRef = cloneref or clonereference or function(o) return o end

Players = CloneRef(game:GetService("Players"))
CoreGui = CloneRef(game:GetService("CoreGui"))
Lighting = CloneRef(game:GetService("Lighting"))
MaterialService = CloneRef(game:GetService("MaterialService"))
NetworkClient = CloneRef(game:GetService("NetworkClient"))
ReplicatedFirst = CloneRef(game:GetService("ReplicatedFirst"))
ReplicatedStorage = CloneRef(game:GetService("ReplicatedStorage"))
StarterGui = CloneRef(game:GetService("StarterGui"))
StarterPack = CloneRef(game:GetService("StarterPack"))
StarterPlayer = CloneRef(game:GetService("StarterPlayer"))
Teams = CloneRef(game:GetService("Teams"))
SoundService = CloneRef(game:GetService("SoundService"))
ChatService = CloneRef(game:GetService("Chat"))
TextChatService = CloneRef(game:GetService("TextChatService"))
VoiceChatService = CloneRef(game:GetService("VoiceChatService"))
TestService = CloneRef(game:GetService("TestService"))
VRService = CloneRef(game:GetService("VRService"))
AssetService = CloneRef(game:GetService("AssetService"))
CollectionService = CloneRef(game:GetService("CollectionService"))
ContentProvider = CloneRef(game:GetService("ContentProvider"))
ContextActionService = CloneRef(game:GetService("ContextActionService"))
Debris = CloneRef(game:GetService("Debris"))
FriendService = CloneRef(game:GetService("FriendService"))
GroupService = CloneRef(game:GetService("GroupService"))
GuiService = CloneRef(game:GetService("GuiService"))
HttpService = CloneRef(game:GetService("HttpService"))
InsertService = CloneRef(game:GetService("InsertService"))
PathfindingService = CloneRef(game:GetService("PathfindingService"))
ProximityPromptService = CloneRef(game:GetService("ProximityPromptService"))
RunService = CloneRef(game:GetService("RunService"))
TeleportService = CloneRef(game:GetService("TeleportService"))
TweenService = CloneRef(game:GetService("TweenService"))
UserInputService = CloneRef(game:GetService("UserInputService"))
AvatarEditorService = CloneRef(game:GetService("AvatarEditorService"))
VirtualUser = CloneRef(game:GetService("VirtualUser"))
VoiceChatInternal = CloneRef(game:GetService("VoiceChatInternal"))
UIS = UserInputService

CurrentVersion = "0.7.16"

Plr = CloneRef(Players.LocalPlayer)
Mouse = CloneRef(Plr:GetMouse())
Camera = CloneRef(workspace.CurrentCamera)

KeepTidalWave = false
AnimateWindows = true
HackListRGBText = true
NotifyOn = true
AnimateCategories = true
KeepCMDBarOpen = false

ProfileToAutoLoad = nil

MenuOpenSpeed = 0.2
CategoryCloseSpeed = 0.3

MenuEasingStyle = "Quad"
MenuOpenEasingDirection = "Out"
MenuCloseEasingDirection = "In"
TextFont = "Montserrat"
BoldFont = "MontserratBold"
MenuKeybind = "RightShift"
CMDBarKeybind = ""
SearchBarKeybind = ""

TidalWaveFocused = false
StopScript = false
Connections = {
	Combat = {},
	Player = {},
	Movement = {},
	Skywars = {},
	["Chick-n-Coop"] = {},
	Visuals = {},
	World = {},
	Other = {},
	ServerInfo = {},
	TidalWave = {},
    Storage = {},
}
TidalWaveKeybinds = {}
GuiColors = {
	CategoryTopBar = Color3.fromRGB(20, 135, 255),
	CategoryBackground = Color3.fromRGB(25, 25, 25),
	Button = Color3.fromRGB(20, 20, 20),
	ButtonHover = Color3.fromRGB(40, 40, 40),
	Text = Color3.fromRGB(255, 255, 255),
	TextboxPlaceholder = Color3.fromRGB(178, 178, 178),
	TextboxBackground = Color3.fromRGB(25, 25, 25),
	EnabledIndicatorOff = Color3.fromRGB(0, 92, 162),
	EnabledIndicatorOn = Color3.fromRGB(0, 200, 255),
}
CMDS = {}
Aliases = {}
Toggles = {}
Values = {}
KeycodeMap = {
	["0"] = 0x30,
	["1"] = 0x31,
	["2"] = 0x32,
	["3"] = 0x33,
	["4"] = 0x34,
	["5"] = 0x35,
	["6"] = 0x36,
	["7"] = 0x37,
	["8"] = 0x38,
	["9"] = 0x39,
	["A"] = 0x41,
	["B"] = 0x42,
	["C"] = 0x43,
	["D"] = 0x44,
	["E"] = 0x45,
	["F"] = 0x46,
	["G"] = 0x47,
	["H"] = 0x48,
	["I"] = 0x49,
	["J"] = 0x4A,
	["K"] = 0x4B,
	["L"] = 0x4C,
	["M"] = 0x4D,
	["N"] = 0x4E,
	["O"] = 0x4F,
	["P"] = 0x50,
	["Q"] = 0x51,
	["R"] = 0x52,
	["S"] = 0x53,
	["T"] = 0x54,
	["U"] = 0x55,
	["V"] = 0x56,
	["W"] = 0x57,
	["X"] = 0x58,
	["Y"] = 0x59,
	["Z"] = 0x5A,
	["Enter"] = 0x0D,
	["Shift"] = 0x10,
	["Ctrl"] = 0x11,
	["Control"] = 0x11,
	["Alt"] = 0x12,
	["Pause"] = 0x13,
	["CapsLock"] = 0x14,
	["Spacebar"] = 0x20,
	["Space"] = 0x20,
	["PageUp"] = 0x21,
	["PageDown"] = 0x22,
	["End"] = 0x23,
	["Home"] = 0x24,
	["Left"] = 0x25,
	["Up"] = 0x26,
	["Right"] = 0x27,
	["Down"] = 0x28,
	["LeftArrow"] = 0x25,
	["UpArrow"] = 0x26,
	["RightArrow"] = 0x27,
	["DownArrow"] = 0x28,
	["Insert"] = 0x2D,
	["Delete"] = 0x2E,
	["F1"] = 0x70,
	["F2"] = 0x71,
	["F3"] = 0x72,
	["F4"] = 0x73,
	["F5"] = 0x74,
	["F6"] = 0x75,
	["F7"] = 0x76,
	["F8"] = 0x77,
	["F9"] = 0x78,
	["F10"] = 0x79,
	["F11"] = 0x7A,
	["F12"] = 0x7B,
}

-------------------------------------------------------------------------------- Combat Variables

HitboxExpanderTarget = "HumanoidRootPart"
GlobalAimbotTarget = "Head"
GlobalAimbotMethod = "CFrame"
PartAimbotMethod = "CFrame"

GlobalAimbotSize = Vector2.new(480, 360)
PartAimbotSize = Vector2.new(480, 360)
ToolHitboxExpanderSize = Vector3.new(2, 2, 2)
HitboxExpanderSize = Vector3.new(2, 2, 1)

GlobalAimbotMinDistance = 0
GlobalAimbotMaxDistance = 1000
HitboxExpanderTransparency = 1
ToolHitboxExpanderTransparency = 1

-------------------------------------------------------------------------------- Player Variables

StrengthenDensity = 0.7
HipHeight = 2
BangSpeed = 5

StatesDisabled = {}

-------------------------------------------------------------------------------- Movement Variables

WalkSpeed = 16
JumpPower = 50
Gravity = 196.2
FlySpeed = 50
FloatPartTransparency = 1
CFrameFlySpeed = 50
GotoCameraTweenTime = 1
SpiderHackSpeed = 50
PulseTeleportTime = 0.5
OrbitSpeed = 0.2
OrbitDistance = 6
MaxSlopeAngle = 89
TeleportTweenTime = 0
SpinSpeed = 10
SpiderHackRadius = 3
SpeedPercentage = 100

SpeedHackMethod = "WalkSpeed"
PartAimbotMode = "Model"
PartAimbotTarget = "Head"
ClickTeleportSound = "rbxassetid://5066021887"
FlyMethod = "BodyVelocity"

PartAimbotFolder = nil
PlayerToFollow = nil
PlayerToOrbit = nil
PlayerToStareAt = nil
PlayerToTeleportTo = nil
PlayerToLoopTeleportTo = nil

-------------------------------------------------------------------------------- Visual Variables

PlayerTracersTeammateColor = Color3.fromRGB(0, 255, 0)
PlayerTracersEnemyColor = Color3.fromRGB(255, 0, 0)
PlayerDrawingEspTeammateOutlineColor = Color3.fromRGB(0, 255, 0)
PlayerDrawingEspTeammateFillColor = Color3.fromRGB(0, 255, 0)
PlayerDrawingEspEnemyOutlineColor = Color3.fromRGB(255, 0, 0)
PlayerDrawingEspEnemyFillColor = Color3.fromRGB(255, 0, 0)
EspTeammateTextColor = Color3.fromRGB(0, 255, 0)
EspEnemyTextColor = Color3.fromRGB(255, 0, 0)
PlayerHighlightEspTeammateOutlineColor = Color3.fromRGB(0, 255, 0)
PlayerHighlightEspTeammateFillColor = Color3.fromRGB(0, 255, 0)
PlayerHighlightEspEnemyOutlineColor = Color3.fromRGB(255, 0, 0)
PlayerHighlightEspEnemyFillColor = Color3.fromRGB(255, 0, 0)
PartEspOutlineColor = Color3.fromRGB(255, 0, 0)
PartEspFillColor = Color3.fromRGB(255, 255, 255)
ColorShiftTop = Color3.fromRGB(255, 255, 255)
ColorShiftBottom = Color3.fromRGB(255, 255, 255)
OutdoorAmbient = Color3.fromRGB(255, 255, 255)
Ambient = Color3.fromRGB(255, 255, 255)

PlayerDrawingEspSize = Vector2.new(1000, 0)
PlayerTracersPosition = Vector2.new(Camera.ViewportSize.X * 0.5, Camera.ViewportSize.Y)

PartEspPath = nil
PartEspName = nil

Brightness = 3
ForceTimeOfDay = 12
PlayerEspTextSize = 10
PlayerHighlightEspFillTransparency = 1
PlayerHighlightEspOutlineTransparency = 0
PartEspFillTransparency = 1
PartEspOutlineTransparency = 0
TeleportSpeed = 0
WaterTransparency = 0.5
PlayerDrawingEspThickness = 1
PlayerTracersThickness = 1
GeographicLatitude = 0
EnvironmentDiffuseScale = 1
EnvironmentSpecularScale = 1
ShadowSoftness = 0.5
ExposureCompensation = 0
Fov = 70
MinZoom = 0
MaxZoom = 400

PartEspMode = "Folder"
PartEspHighlightMode = "Highlight"
TeleportEasingStyle = "Linear"
TeleportEasingDirection = "Out"

-------------------------------------------------------------------------------- Other Variables

InstanceToSpoof = nil
SpoofValue = nil
PlayerToFreeze = nil
Rebinding = nil
PosToWalkTo = nil
SpoofFunctionValue = nil
SpoofFunctionSelf = nil

ValueToSpoof = ""
SpoofFunctionMethod = ""
SpoofFunctionSelfToReturn = "self"

SpoofFunctionArgs = {}

--------------------------------------------------------------------------------

function GetExploitFunction(Function, CustomFunction)
    if typeof(Function) == "function" then
        return Function
    end
    return CustomFunction
end

QueueOnTeleport = GetExploitFunction(queueonteleport or queue_on_teleport or (syn and syn.queue_on_teleport) or (fluxus and fluxus.queue_on_teleport))
HttpRequest = GetExploitFunction(request or httprequest or (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request))
HttpGet = GetExploitFunction(httpget or HttpGet or http_get)
SetHidden = GetExploitFunction(sethiddenproperty or set_hidden_property or set_hidden_prop)
GetHidden = GetExploitFunction(gethiddenproperty or get_hidden_property or get_hidden_prop)
SaveInstance = GetExploitFunction(saveinstance)
Hookmetamethod = GetExploitFunction(hookmetamethod)
HookFunction = GetExploitFunction(hookfunction)
GetNameCallMethod = GetExploitFunction(getnamecallmethod)
SetFPSCap = GetExploitFunction(setfpscap or fpscap, function(FPSCap) if Connections.TidalWave.FPSCapLoop then task.cancel(Connections.TidalWave.FPSCapLoop); Connections.TidalWave.FPSCapLoop = nil end; Connections.TidalWave.FPSCapLoop = task.spawn(function() local timer = os.clock(); while true and Connections.FPSCapLoop do if os.clock() >= timer + 1 / FPSCap then timer = os.clock(); task.wait() end end end) end)
SetConstant = GetExploitFunction(setconstant or debug.setconstant)
GetConstants = GetExploitFunction(getconstants or debug.getconstants)
Getgc = GetExploitFunction(getgc or getgarbagecollection)
GetConnections = GetExploitFunction(getconnections or get_signal_cons)
ReadFile = GetExploitFunction(readfile)
WriteFile = GetExploitFunction(writefile)
AppendFile = GetExploitFunction(appendfile, function(Path, Str) if WriteFile and ReadFile then WriteFile(Path, ReadFile(Path) .. Str) end end)
LoadFile = GetExploitFunction(loadfile, function(Path) if ReadFile then loadstring(ReadFile(Path)) end end)
ListFiles = GetExploitFunction(listfiles)
IsFile = GetExploitFunction(isfile, function(Path) return pcall(function() ReadFile(Path) end) == true end)
IsFolder = GetExploitFunction(isfolder)
MakeFolder = GetExploitFunction(makefolder)
DeleteFolder = GetExploitFunction(deletefolder)
DeleteFile = GetExploitFunction(deletefile)
ClipboardFunc = GetExploitFunction(setclipboard or toclipboard or set_clipboard or (Clipboard and Clipboard.set))
GetHui = GetExploitFunction(get_hidden_gui or gethui, function() return CoreGui:FindFirstChild("RobloxGui") or CoreGui end)
GetCustomAsset = GetExploitFunction(getcustomasset)
MouseMoveRel = GetExploitFunction(mousemoverel)
Mouse1Down = GetExploitFunction(mouse1down)
Mouse1Up = GetExploitFunction(mouse1up)
Mouse1Click = GetExploitFunction(mouse1click)
NewCClosure = GetExploitFunction(newcclosure, function(f) return f end)
CheckCaller = GetExploitFunction(checkcaller)
GetCallingScript = GetExploitFunction(getcallingscript)
FireProximityPrompt = GetExploitFunction(fireproximityprompt)
FireClickDetector = GetExploitFunction(fireclickdetector)
IdentifyExecutor = GetExploitFunction(identifyexecutor)
FireTouchInterest = GetExploitFunction(firetouchinterest)
KeyPress = GetExploitFunction(keypress)
KeyRelease = GetExploitFunction(keyrelease)
CompareInstances = GetExploitFunction(compareinstances, function(a, b)
	if a == b then
		return true
	end
	if typeof(a) == "Instance" and typeof(b) == "Instance" then
		local aFullName = GetFullName(a)
		local bFullName = GetFullName(b)
		if a.Name == b.Name and a.ClassName == b.ClassName and a.Parent == b.Parent and aFullName == bFullName and a.Archivable == b.Archivable then
			return true
		end
	end
	return false
end)
if not HttpGet then
    local Success, GameHttpGet = pcall(function()
        return game.HttpGet
    end)
    if Success then
        HttpGet = function(Str, Arg)
            return GameHttpGet(game, Str, Arg)
        end
    end
end
Loadstring = pcall(function() loadstring("") end) and loadstring or nil
if Loadstring == nil then
    local luaP = {};luaP.OpMode = { iABC = 0, iABx = 1, iAsBx = 2 };luaP.SIZE_C  = 9;luaP.SIZE_B  = 9;luaP.SIZE_Bx = luaP.SIZE_C + luaP.SIZE_B;luaP.SIZE_A  = 8;luaP.SIZE_OP = 6;luaP.POS_OP = 0
    luaP.POS_A  = luaP.POS_OP + luaP.SIZE_OP;luaP.POS_C  = luaP.POS_A + luaP.SIZE_A;luaP.POS_B  = luaP.POS_C + luaP.SIZE_C;luaP.POS_Bx = luaP.POS_C;luaP.MAXARG_Bx  = math.ldexp(1, luaP.SIZE_Bx) - 1
    luaP.MAXARG_sBx = math.floor(luaP.MAXARG_Bx / 2)  ;luaP.MAXARG_A = math.ldexp(1, luaP.SIZE_A) - 1;luaP.MAXARG_B = math.ldexp(1, luaP.SIZE_B) - 1;luaP.MAXARG_C = math.ldexp(1, luaP.SIZE_C) - 1
    function luaP:GET_OPCODE(i) return self.ROpCode[i.OP] end;function luaP:SET_OPCODE(i, o) i.OP = self.OpCode[o] end;function luaP:GETARG_A(i) return i.A end;function luaP:SETARG_A(i, u) i.A = u end
    function luaP:GETARG_B(i) return i.B end;function luaP:SETARG_B(i, b) i.B = b end;function luaP:GETARG_C(i) return i.C end;function luaP:SETARG_C(i, b) i.C = b end;function luaP:GETARG_Bx(i) return i.Bx end
    function luaP:SETARG_Bx(i, b) i.Bx = b end;function luaP:GETARG_sBx(i) return i.Bx - self.MAXARG_sBx end;function luaP:SETARG_sBx(i, b) i.Bx = b + self.MAXARG_sBx end;function luaP:CREATE_ABC(o,a,b,c) return {OP = self.OpCode[o], A = a, B = b, C = c} end
    function luaP:CREATE_ABx(o,a,bc) return {OP = self.OpCode[o], A = a, Bx = bc} end;function luaP:CREATE_Inst(c) local o = c % 64; c = (c - o) / 64; local a = c % 256; c = (c - a) / 256; return self:CREATE_ABx(o, a, c) end
    function luaP:Instruction(i) if i.Bx then i.C = i.Bx % 512; i.B = (i.Bx - i.C) / 512 end; local I = i.A * 64 + i.OP; local c0 = I % 256;I = i.C * 64 + (I - c0) / 256;local c1 = I % 256;I = i.B * 128 + (I - c1) / 256;local c2 = I % 256;local c3 = (I - c2) / 256;return string.char(c0, c1, c2, c3)end
    function luaP:DecodeInst(x)local byte = string.byte;local i = {};local I = byte(x, 1);local op = I % 64;i.OP = op;I = byte(x, 2) * 4 + (I - op) / 64  ;local a = I % 256;i.A = a;I = byte(x, 3) * 4 + (I - a) / 256;local c = I % 512;i.C = c;i.B = byte(x, 4) * 2 + (I - c) / 512 ;local opmode = self.OpMode[tonumber(string.sub(self.opmodes[op + 1], 7, 7))];if opmode ~= "iABC" then i.Bx = i.B * 512 + i.C end;return i;end
    luaP.BITRK = math.ldexp(1, luaP.SIZE_B - 1);function luaP:ISK(x) return x >= self.BITRK end;function luaP:INDEXK(x) return x - self.BITRK end;luaP.MAXINDEXRK = luaP.BITRK - 1;function luaP:RKASK(x) return x + self.BITRK end
    luaP.NO_REG = luaP.MAXARG_A;luaP.opnames = {};luaP.OpCode = {};luaP.ROpCode = {};local i = 0
    for v in string.gmatch("MOVE LOADK LOADBOOL LOADNIL GETUPVAL GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE NEWTABLE SELF ADD SUB MUL DIV MOD POW UNM NOT LEN CONCAT JMP EQ LT LE TEST TESTSET CALL TAILCALL RETURN FORLOOP FORPREP TFORLOOP SETLIST CLOSE CLOSURE VARARG", "%S+") do
        local n = "OP_"..v;luaP.opnames[i] = v;luaP.OpCode[n] = i;luaP.ROpCode[i] = n;i = i + 1
    end;luaP.NUM_OPCODES = i;luaP.OpArgMask = { OpArgN = 0, OpArgU = 1, OpArgR = 2, OpArgK = 3 };function luaP:getOpMode(m) return self.opmodes[self.OpCode[m]] % 4 end
    function luaP:getBMode(m) return math.floor(self.opmodes[self.OpCode[m]] / 16) % 4 end;function luaP:getCMode(m) return math.floor(self.opmodes[self.OpCode[m]] / 4) % 4 end;function luaP:testAMode(m) return math.floor(self.opmodes[self.OpCode[m]] / 64) % 2 end
    function luaP:testTMode(m) return math.floor(self.opmodes[self.OpCode[m]] / 128) end;luaP.LFIELDS_PER_FLUSH = 50;local function opmode(t, a, b, c, m) local luaP = luaP; return t * 128 + a * 64 + luaP.OpArgMask[b] * 16 + luaP.OpArgMask[c] * 4 + luaP.OpMode[m] end
    luaP.opmodes = {opmode(0, 1, "OpArgK", "OpArgN", "iABx"),opmode(0, 1, "OpArgU", "OpArgU", "iABC"),opmode(0, 1, "OpArgR", "OpArgN", "iABC"),opmode(0, 1, "OpArgU", "OpArgN", "iABC"),opmode(0, 1, "OpArgK", "OpArgN", "iABx"),opmode(0, 1, "OpArgR", "OpArgK", "iABC"),opmode(0, 0, "OpArgK", "OpArgN", "iABx"),    
        opmode(0, 0, "OpArgU", "OpArgN", "iABC"),opmode(0, 0, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgU", "OpArgU", "iABC"),opmode(0, 1, "OpArgR", "OpArgK", "iABC"),opmode(0, 1, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
        opmode(0, 1, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgR", "OpArgN", "iABC"),opmode(0, 1, "OpArgR", "OpArgN", "iABC"),opmode(0, 1, "OpArgR", "OpArgN", "iABC"),opmode(0, 1, "OpArgR", "OpArgR", "iABC"),opmode(0, 0, "OpArgR", "OpArgN", "iAsBx"),opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     
        opmode(1, 0, "OpArgK", "OpArgK", "iABC"),opmode(1, 0, "OpArgK", "OpArgK", "iABC"),opmode(1, 1, "OpArgR", "OpArgU", "iABC"),opmode(1, 1, "OpArgR", "OpArgU", "iABC"),opmode(0, 1, "OpArgU", "OpArgU", "iABC"),opmode(0, 1, "OpArgU", "OpArgU", "iABC"),opmode(0, 0, "OpArgU", "OpArgN", "iABC"),opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),
        opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),opmode(1, 0, "OpArgN", "OpArgU", "iABC"),opmode(0, 0, "OpArgU", "OpArgU", "iABC"),opmode(0, 0, "OpArgN", "OpArgN", "iABC"),opmode(0, 1, "OpArgU", "OpArgN", "iABx"),opmode(0, 1, "OpArgU", "OpArgN", "iABC"),     
    }
    luaP.opmodes[0] = opmode(0, 1, "OpArgR", "OpArgN", "iABC");local luaU = {};luaU.LUA_SIGNATURE = "\27Lua";luaU.LUA_TNUMBER  = 3;luaU.LUA_TSTRING  = 4;luaU.LUA_TNIL     = 0;luaU.LUA_TBOOLEAN = 1
    luaU.LUA_TNONE = -1;luaU.LUAC_VERSION = 0x51;luaU.LUAC_FORMAT = 0;luaU.LUAC_HEADERSIZE = 12;function luaU:make_setS()local buff = {};buff.data = "";local writer = function(s, buff) if not s then return 0 end;buff.data = buff.data..s;return 0;end;return writer, buff;end
    function luaU:ttype(o)local tt = type(o.value);if tt == "number" then return self.LUA_TNUMBER elseif tt == "string" then return self.LUA_TSTRING elseif tt == "nil" then return self.LUA_TNIL elseif tt == "boolean" then return self.LUA_TBOOLEAN else return self.LUA_TNONE   end end
    function luaU:from_double(x)local function grab_byte(v)local c = v % 256;return (v - c) / 256, string.char(c)end;local sign = 0;if x < 0 then sign = 1; x = -x end;local mantissa, exponent = math.frexp(x);if x == 0 then mantissa, exponent = 0, 0 elseif x == 1/0 then mantissa, exponent = 0, 2047 else mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53); exponent = exponent + 1022 end
        local v, byte = "", nil;x = math.floor(mantissa);for i = 1,6 do x, byte = grab_byte(x); v = v..byte end;x, byte = grab_byte(exponent * 16 + x); v = v..byte ;x, byte = grab_byte(sign * 128 + x); v = v..byte ;return v
    end
    function luaU:from_int(x)local v = "";x = math.floor(x);if x < 0 then x = 4294967296 + x end ;for i = 1, 4 do local c = x % 256;v = v..string.char(c); x = math.floor(x / 256) end return v end
    function luaU:DumpBlock(b, D)if D.status == 0 then D.status = D.write(b, D.data) end end
    function luaU:DumpChar(y, D) self:DumpBlock(string.char(y), D) end
    function luaU:DumpInt(x, D) self:DumpBlock(self:from_int(x), D) end
    function luaU:DumpNumber(x, D) self:DumpBlock(self:from_double(x), D) end
    function luaU:DumpString(s, D) if s == nil then self:DumpInt(0, D) else s = s.."\0"; self:DumpInt(#s, D); self:DumpBlock(s, D) end end
    function luaU:DumpCode(f, D)local n = f.sizecode; self:DumpInt(n, D); for i = 0, n - 1 do self:DumpBlock(luaP:Instruction(f.code[i]), D) end end
    function luaU:DumpConstants(f, D)local n = f.sizek;self:DumpInt(n, D);for i = 0, n - 1 do local o = f.k[i];local tt = self:ttype(o);self:DumpChar(tt, D);if tt == self.LUA_TNIL then elseif tt == self.LUA_TBOOLEAN then self:DumpChar(o.value and 1 or 0, D) elseif tt == self.LUA_TNUMBER then self:DumpNumber(o.value, D) elseif tt == self.LUA_TSTRING then self:DumpString(o.value, D) else end end;n = f.sizep;self:DumpInt(n, D);for i = 0, n - 1 do self:DumpFunction(f.p[i], f.source, D) end end
    function luaU:DumpDebug(f, D) local n = D.strip and 0 or f.sizelineinfo;self:DumpInt(n, D);for i = 0, n - 1 do self:DumpInt(f.lineinfo[i], D) end;n = D.strip and 0 or f.sizelocvars;self:DumpInt(n, D);for i = 0, n - 1 do self:DumpString(f.locvars[i].varname, D);self:DumpInt(f.locvars[i].startpc, D);self:DumpInt(f.locvars[i].endpc, D) end;n = D.strip and 0 or f.sizeupvalues;self:DumpInt(n, D);for i = 0, n - 1 do self:DumpString(f.upvalues[i], D)end end
    function luaU:DumpFunction(f, p, D)local source = f.source;if source == p or D.strip then source = nil end; self:DumpString(source, D);self:DumpInt(f.lineDefined, D);self:DumpInt(f.lastlinedefined, D);self:DumpChar(f.nups, D);self:DumpChar(f.numparams, D);self:DumpChar(f.is_vararg, D);self:DumpChar(f.maxstacksize, D);self:DumpCode(f, D);self:DumpConstants(f, D);self:DumpDebug(f, D)end
    function luaU:DumpHeader(D)local h = self:header();assert(#h == self.LUAC_HEADERSIZE) ;self:DumpBlock(h, D)end
    function luaU:header()local x = 1;return self.LUA_SIGNATURE..string.char(self.LUAC_VERSION,self.LUAC_FORMAT,x,4,4, 4,8,0)                    end
    function luaU:dump(L, f, w, data, strip)local D = {};D.L = L;D.write = w;D.data = data;D.strip = strip;D.status = 0;self:DumpHeader(D);self:DumpFunction(f, nil, D);D.write(nil, D.data);return D.status end;local luaZ = {}
    function luaZ:make_getS(buff)local b = buff;return function()if not b then return nil end;local data = b;b = nil;return data end end
    function luaZ:init(reader, data, name)if not reader then return end;local z = {};z.reader = reader;z.data = data or "";z.name = name;if not data or data == "" then z.n = 0 else z.n = #data end;z.p = 0;return z end
    function luaZ:fill(z)local buff = z.reader();z.data = buff;if not buff or buff == "" then return "EOZ" end;z.n, z.p = #buff - 1, 1;return string.sub(buff, 1, 1) end
    function luaZ:zgetc(z)local n, p = z.n, z.p + 1;if n > 0 then z.n, z.p = n - 1, p; return string.sub(z.data, p, p) else return self:fill(z) end end
    local Select = select;local Byte = string.byte;local Sub = string.sub;local Opcode = {'ABC','ABx','ABC','ABC','ABC','ABx','ABC','ABx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','AsBx','ABC','ABC','ABC','ABx','ABC'}
    local function gBit(Bit, Start, End) if End then local Res = (Bit / 2 ^ (Start - 1)) % 2 ^ ((End - 1) - (Start - 1) + 1);return Res - Res % 1;else local Plc = 2 ^ (Start - 1);if (Bit % (Plc + Plc) >= Plc) then return 1;else return 0;end;end;end;
    local function GetMeaning(ByteString)
        local Pos= 1;local gSizet;local gInt;local function gBits8() local F= Byte(ByteString, Pos, Pos);Pos = Pos + 1;return F;end;local function gBits32()local W, X, Y, Z= Byte(ByteString, Pos, Pos + 3);Pos	= Pos + 4;return (Z * 16777216) + (Y * 65536) + (X * 256) + W;end;
        local function gBits64()return gBits32() * 4294967296 + gBits32();end;
        local function gFloat()local Left = gBits32();local Right = gBits32();local IsNormal = 1;local Mantissa = (gBit(Right, 1, 20) * (2 ^ 32))+ Left;local Exponent = gBit(Right, 21, 31);local Sign = ((-1) ^ gBit(Right, 32));
            if (Exponent == 0) then if (Mantissa == 0) then return Sign * 0  else Exponent = 1;IsNormal = 0 end elseif (Exponent == 2047) then if (Mantissa == 0) then return Sign * (1 / 0)  else return Sign * (0 / 0) end end; return math.ldexp(Sign, Exponent - 1023) * (IsNormal + (Mantissa / (2 ^ 52)))
        end;
        local function gString(Len)local Str;if Len then Str	= Sub(ByteString, Pos, Pos + Len - 1);Pos = Pos + Len;else Len = gSizet();if (Len == 0) then return; end;Str	= Sub(ByteString, Pos, Pos + Len - 1);Pos = Pos + Len;end;return Str;end;
        local function ChunkDecode()local Instr	= {};local Const= {};local Proto= {};local Chunk= {Instr	= Instr; Const	= Const;Proto	= Proto; Lines	= {}; Name	= gString(); FirstL	= gInt(); LastL	= gInt(); Upvals	= gBits8(); Args	= gBits8(); Vargs	= gBits8(); Stack	= gBits8(); };
            if Chunk.Name then Chunk.Name	= Sub(Chunk.Name, 1, -2);end;for Idx = 1, gInt() do local Data	= gBits32();local Opco	= gBit(Data, 1, 6);local Type	= Opcode[Opco + 1];local Inst;if Type then Inst = {Enum = Opco;gBit(Data, 7, 14); };if (Type == 'ABC') then Inst[2]	= gBit(Data, 24, 32);Inst[3]= gBit(Data, 15, 23);elseif (Type == 'ABx') then Inst[2]= gBit(Data, 15, 32);elseif (Type == 'AsBx') then Inst[2]= gBit(Data, 15, 32) - 131071;end;else Inst = Data; end;Instr[Idx] = Inst;end;
            for Idx = 1, gInt() do local Type	= gBits8();local Cons;if (Type == 1) then Cons= (gBits8() ~= 0);elseif (Type == 3) then Cons = gFloat();elseif (Type == 4) then Cons = Sub(gString(), 1, -2);end;Const[Idx - 1]	= Cons;end;for Idx = 1, gInt() do Proto[Idx - 1]	= ChunkDecode();end;
            do local Lines	= Chunk.Lines;for Idx = 1, gInt() do Lines[Idx]	= gBits32();end;for _ = 1, gInt() do gString(); gBits32(); gBits32(); end;for _ = 1, gInt() do gString(); end;end;return Chunk; 
        end;
        do assert(gString(4) == "\27Lua", "Lua bytecode expected.");assert(gBits8() == 0x51, "Only Lua 5.1 is supported.");gBits8(); gBits8(); local IntSize	= gBits8(); local Sizet		= gBits8(); if (IntSize == 4) then gInt	= gBits32;elseif (IntSize == 8) then gInt	= gBits64;else error('Integer size not supported', 2);end;if (Sizet == 4) then gSizet	= gBits32;elseif (Sizet == 8) then gSizet= gBits64;else error('Sizet size not supported', 2);end;assert(gString(3) == "\4\8\0", "Unsupported bytecode target platform");end;return ChunkDecode();
    end;local function _Returns(...)return Select('#', ...), {...};end;
    local function Wrap(Chunk, Env, Upvalues)
        local Instr= Chunk.Instr;local Const= Chunk.Const;local Proto= Chunk.Proto;local function OnError(Err, Position) local Name= Chunk.Name or 'Code';local Line= Chunk.Lines[Position] or '?';Err	= tostring(Err):match'^.+:%s*(.+)' or Err;error(string.format('%s (%s): %s', Name, Line, Err), 0);end;
        return function(...)
            local InstrPoint, Top= 1, -1;local Vararg, Varargsz	= {}, Select('#', ...) - 1;local GStack	= {};local Lupvals	= {};local Stack= setmetatable({}, {__index	= GStack;__newindex	= function(_, Key, Value)if (Key > Top) then Top	= Key;end;GStack[Key]	= Value;end;});
            local function Loop()
                local Inst, Enum;
                while true do
                    Inst= Instr[InstrPoint]; Enum= Inst.Enum;InstrPoint	= InstrPoint + 1;
                    if (Enum == 0) then
                        Stack[Inst[1]]	= Stack[Inst[2]];
                    elseif (Enum == 1) then
                        Stack[Inst[1]]	= Const[Inst[2]];
                    elseif (Enum == 2) then
                        Stack[Inst[1]]	= (Inst[2] ~= 0);if (Inst[3] ~= 0) then InstrPoint	= InstrPoint + 1;end;
                    elseif (Enum == 3) then
                        local Stk= Stack;for Idx = Inst[1], Inst[2] do Stk[Idx]	= nil;end;
                    elseif (Enum == 4) then
                        Stack[Inst[1]]	= Upvalues[Inst[2]];
                    elseif (Enum == 5) then
                        Stack[Inst[1]]	= Env[Const[Inst[2]]];
                    elseif (Enum == 6) then
                        local C	= Inst[3];local Stk	= Stack;if (C > 255) then C	= Const[C - 256];else C= Stk[C];end;Stk[Inst[1]]= Stk[Inst[2]][C];
                    elseif (Enum == 7) then 
                        Env[Const[Inst[2]]]	= Stack[Inst[1]];
                    elseif (Enum == 8) then 
                        Upvalues[Inst[2]]	= Stack[Inst[1]];
                    elseif (Enum == 9) then 
                        local B, C	= Inst[2], Inst[3];local Stk	= Stack;if (B > 255) then B= Const[B-256];else B= Stk[B];end;if (C > 255) then C= Const[C - 256];else C=Stk[C];end;Stk[Inst[1]][B]= C;
                    elseif (Enum == 10) then 
                        Stack[Inst[1]]	= {};
                    elseif (Enum == 11) then 
                        local A= Inst[1];local B= Inst[2];local C= Inst[3];local Stk= Stack;B = Stk[B];if (C > 255) then C= Const[C-256];else C= Stk[C];end;Stk[A+1]= B;Stk[A]= B[C];
                    elseif (Enum == 12) then 
                        local B= Inst[2];local C= Inst[3];local Stk = Stack;if (B > 255) then B= Const[B - 256];else B= Stk[B];end;if (C > 255) then C= Const[C - 256];else C= Stk[C];end;Stk[Inst[1]]= B + C;
                    elseif (Enum == 13) then 
                        local B= Inst[2];local C= Inst[3];local Stk = Stack;if (B > 255) then B= Const[B - 256];else B= Stk[B];end;if (C > 255) then C=Const[C - 256];else C= Stk[C];end;Stk[Inst[1]]= B - C;
                    elseif (Enum == 14) then 
                        local B= Inst[2];local C= Inst[3];local Stk = Stack;if (B > 255) then B= Const[B - 256];else B= Stk[B];end;if (C > 255) then C= Const[C - 256];else C= Stk[C];end;Stk[Inst[1]]	= B * C;
                    elseif (Enum == 15) then 
                        local B= Inst[2];local C= Inst[3];local Stk = Stack;if (B > 255) then B	= Const[B - 256];else B=Stk[B];end;if (C > 255) then C	= Const[C - 256];else C=Stk[C];end;Stk[Inst[1]]=B/C;
                    elseif (Enum == 16) then 
                        local B= Inst[2];local C= Inst[3];local Stk = Stack;if (B > 255) then B= Const[B - 256];else B= Stk[B];end;if (C > 255) then C= Const[C - 256];else C= Stk[C];end;Stk[Inst[1]]	= B % C;
                    elseif (Enum == 17) then 
                        local B= Inst[2];local C= Inst[3];local Stk = Stack;if (B > 255) then B= Const[B - 256];else B= Stk[B];end;if (C > 255) then C= Const[C - 256];else C= Stk[C];end;Stk[Inst[1]]	= B ^ C;
                    elseif (Enum == 18) then 
                        Stack[Inst[1]]	= -Stack[Inst[2]];
                    elseif (Enum == 19) then 
                        Stack[Inst[1]]	= (not Stack[Inst[2]]);
                    elseif (Enum == 20) then 
                        Stack[Inst[1]]	= #Stack[Inst[2]];
                    elseif (Enum == 21) then 
                        local Stk= Stack;local B= Inst[2];local K= Stk[B];for Idx = B + 1, Inst[3] do K = K .. Stk[Idx];end;Stack[Inst[1]]	= K;
                    elseif (Enum == 22) then 
                        InstrPoint	= InstrPoint + Inst[2];
                    elseif (Enum == 23) then 
                        local A	= Inst[1] ~= 0;local B	= Inst[2];local C	= Inst[3];local Stk = Stack;if (B > 255) then B= Const[B - 256];else B= Stk[B];end;if (C > 255) then C= Const[C - 256];else C= Stk[C];end;if (B == C) ~= A then InstrPoint	= InstrPoint + 1;end;
                    elseif (Enum == 24) then 
                        local A	= Inst[1] ~= 0;local B	= Inst[2];local C	= Inst[3];local Stk = Stack;if (B > 255) then B= Const[B - 256];else B= Stk[B];end;if (C > 255) then C= Const[C - 256];else C= Stk[C];end;if (B < C) ~= A then InstrPoint	= InstrPoint + 1;end;
                    elseif (Enum == 25) then
                        local A	= Inst[1] ~= 0;local B	= Inst[2];local C	= Inst[3];local Stk = Stack;if (B > 255) then B= Const[B - 256];else B= Stk[B];end;if (C > 255) then C= Const[C - 256];else C= Stk[C];end;if (B <= C) ~= A then InstrPoint	= InstrPoint + 1;end;
                    elseif (Enum == 26) then 
                        if (not not Stack[Inst[1]]) == (Inst[3] == 0) then InstrPoint	= InstrPoint + 1;end;
                    elseif (Enum == 27) then 
                        local B	= Stack[Inst[2]];if (not not B) == (Inst[3] == 0) then InstrPoint	= InstrPoint + 1;else Stack[Inst[1]] = B;end;
                    elseif (Enum == 28) then 
                        local A	= Inst[1];local B=Inst[2];local C= Inst[3];local Stk= Stack;local Args,Results;local Limit,Loop;Args={};if (B ~= 1) then if (B ~= 0) then Limit = A + B - 1;else Limit = Top;end; Loop= 0; for Idx = A + 1, Limit do Loop = Loop + 1; Args[Loop] = Stk[Idx];end;
                        Limit, Results = _Returns(Stk[A](unpack(Args, 1, Limit - A)));else Limit, Results = _Returns(Stk[A]());end;Top = A - 1;if (C ~= 1) then if (C ~= 0) then Limit = A + C - 2;else Limit = Limit + A - 1;end; Loop= 0; for Idx = A, Limit do Loop = Loop + 1; Stk[Idx] = Results[Loop];end;end;
                    elseif (Enum == 29) then 
                        local A	= Inst[1];local B	= Inst[2];local Stk	= Stack;local Args, Results;local Limit, Loop;local Rets = 0;Args = {};if (B ~= 1) then if (B ~= 0) then Limit = A + B - 1;else Limit = Top;end;Loop = 0;for Idx = A + 1, Limit do Loop = Loop + 1;Args[#Args + 1] = Stk[Idx];end; Results = {Stk[A](unpack(Args, 1, Limit - A))};else Results = {Stk[A]()};end;for Index in next, Results do if (Index > Rets) then Rets = Index;end;end;return Results, Rets;
                    elseif (Enum == 30) then 
                        local A	= Inst[1];local B	= Inst[2];local Stk	= Stack;local Loop, Output;local Limit;if (B == 1) then return;elseif (B == 0) then Limit= Top;else Limit= A + B - 2;end;Output = {};Loop = 0;for Idx = A, Limit do Loop= Loop + 1;Output[Loop] = Stk[Idx];end;return Output, Loop;
                    elseif (Enum == 31) then 
                        local A	= Inst[1];local Stk	= Stack;local Step= Stk[A + 2];local Index= Stk[A] + Step;Stk[A]= Index;if (Step > 0) then if Index <= Stk[A+1] then InstrPoint= InstrPoint+Inst[2];Stk[A+3] = Index;end;else if Index >= Stk[A + 1] then InstrPoint	= InstrPoint + Inst[2];Stk[A + 3] = Index;end;end;
                    elseif (Enum == 32) then 
                        local A	= Inst[1];local Stk= Stack;Stk[A] = assert(tonumber(Stk[A]), '"for" initial value must be a number');Stk[A + 1] = assert(tonumber(Stk[A + 1]), '"for" limit must be a number');Stk[A + 2] = assert(tonumber(Stk[A + 2]), '"for" step must be a number');Stk[A]	= Stk[A] - Stk[A + 2];InstrPoint	= InstrPoint + Inst[2];
                    elseif (Enum == 33) then 
                        local A= Inst[1];local C= Inst[3];local Stk= Stack;local Offset= A + 2;local Result= {Stk[A](Stk[A + 1], Stk[A + 2])};for Idx = 1, C do Stack[Offset + Idx] = Result[Idx];end;if (Stk[A + 3] ~= nil) then Stk[A + 2]= Stk[A + 3];else InstrPoint= InstrPoint + 1;end;
                    elseif (Enum == 34) then 
                        local A	= Inst[1];local B= Inst[2];local C	= Inst[3];local Stk= Stack;if (C == 0) then InstrPoint= InstrPoint + 1;C= Instr[InstrPoint]; end;local Offset	= (C - 1) * 50;local T= Stk[A]; if (B == 0) then B= Top;end;for Idx = 1, B do T[Offset + Idx] = Stk[A + Idx];end;
                    elseif (Enum == 35) then 
                        local A	= Inst[1];local Cls= {};for Idx = 1, #Lupvals do local List = Lupvals[Idx];for Idz = 0, #List do local Upv= List[Idz];local Stk= Upv[1];local Pos= Upv[2];if (Stk == Stack) and (Pos >= A) then Cls[Pos]= Stk[Pos];Upv[1]=Cls;end;end;end;
                    elseif (Enum == 36) then 
                        local NewProto= Proto[Inst[2]];local Stk= Stack;local Indexes;local NewUvals;if(NewProto.Upvals ~= 0) then Indexes= {};NewUvals= setmetatable({}, {__index = function(_, Key)local Val	= Indexes[Key];return Val[1][Val[2]];end,__newindex = function(_, Key, Value)local Val	= Indexes[Key];Val[1][Val[2]]= Value;end;});
                        for Idx = 1, NewProto.Upvals do local Mvm	= Instr[InstrPoint];if (Mvm.Enum == 0) then  Indexes[Idx - 1] = {Stk, Mvm[2]};elseif (Mvm.Enum == 4) then  Indexes[Idx - 1] = {Upvalues, Mvm[2]};end;InstrPoint	= InstrPoint + 1;end;Lupvals[#Lupvals + 1]	= Indexes;end;Stk[Inst[1]]= Wrap(NewProto, Env, NewUvals);elseif (Enum == 37) then local A	= Inst[1];local B	= Inst[2];local Stk, Vars	= Stack, Vararg;Top = A - 1;for Idx = A, A + (B > 0 and B - 1 or Varargsz) do Stk[Idx]= Vars[Idx - A];end;
                    end;
                end;
            end;
            local Args	= {...};for Idx = 0, Varargsz do if (Idx >= Chunk.Args) then Vararg[Idx - Chunk.Args] = Args[Idx + 1];else Stack[Idx] = Args[Idx + 1];end;end;local A, B, C	= pcall(Loop); if A then if B and (C > 0) then  return unpack(B, 1, C);end;return;else OnError(B, InstrPoint - 1); end;
        end;
    end;
    local luaX = {}
    luaZ.RESERVED = "TK_AND and\nTK_BREAK break\nTK_DO do\nTK_ELSE else\nTK_ELSEIF elseif\nTK_END end\nTK_FALSE false\nTK_FOR for\nTK_FUNCTION function\nTK_IF if\nTK_IN in\nTK_LOCAL local\nTK_NIL nil\nTK_NOT not\nTK_OR or\nTK_REPEAT repeat\nTK_RETURN return\nTK_THEN then\nTK_TRUE true\nTK_UNTIL until\nTK_WHILE while\nTK_CONCAT ..\nTK_DOTS ...\nTK_EQ ==\nTK_GE >=\nTK_LE <=\nTK_NE ~=\nTK_NAME <name>\nTK_NUMBER <number>\nTK_STRING <string>\nTK_EOS <eof>";
    luaX.MAXSRC = 80;luaX.MAX_INT = 2147483645;luaX.LUA_QS = "'%s'";luaX.LUA_COMPAT_LSTR = 1;
    function luaX:init()
        local tokens, enums = {}, {};
        for v in string.gmatch(self.RESERVED, "[^\n]+") do
            local _, _, tok, str = string.find(v, "(%S+)%s+(%S+)");
            tokens[tok] = str;
            enums[str] = tok;
        end;
        self.tokens = tokens;
        self.enums = enums;
    end;
    function luaX:chunkid(source, bufflen)
        local out;
        local first = string.sub(source, 1, 1);
        if first == "=" then
            out = string.sub(source, 2, bufflen);
        else  
            if first == "@" then
                source = string.sub(source, 2);
                bufflen = bufflen - #" '...' ";
                local l = #source;
                out = "";
                if l > bufflen then
                    source = string.sub(source, 1 + l - bufflen);
                    out = out.."...";
                end;
                out = out..source;
            else  
                local len = string.find(source, "[\n\r]");
                len = len and (len - 1) or #source;
                bufflen = bufflen - #(" [string \"...\"] ");
                if len > bufflen then len = bufflen end;
                out = "[string \"";
                if len < #source then  
                    out = out..string.sub(source, 1, len).."...";
                else
                    out = out..source;
                end;
                out = out.."\"]";
            end;
        end;
        return out;
    end;
    function luaX:token2str(ls, token)
        if string.sub(token, 1, 3) ~= "TK_" then
            if string.find(token, "%c") then
                return string.format("char(%d)", string.byte(token));
            end
            return token;
        end;
        return self.tokens[token];
    end;
    function luaX:lexerror(ls, msg, token)
        local function txtToken(ls, token)
            if token == "TK_NAME" or token == "TK_STRING" or token == "TK_NUMBER" then
                return ls.buff;
            else
                return self:token2str(ls, token);
            end
        end
        local buff = self:chunkid(ls.source, self.MAXSRC);
        msg = string.format("%s:%d: %s", buff, ls.linenumber, msg);
        if token then
            msg = string.format("%s near "..self.LUA_QS, msg, txtToken(ls, token));
        end;

        error(msg);
    end;
    function luaX:syntaxerror(ls, msg)
        self:lexerror(ls, msg, ls.t.token);
    end;
    function luaX:currIsNewline(ls)
        return ls.current == "\n" or ls.current == "\r";
    end;
    function luaX:inclinenumber(ls)
        local old = ls.current;

        self:nextc(ls);
        if self:currIsNewline(ls) and ls.current ~= old then
            self:nextc(ls);
        end
        ls.linenumber = ls.linenumber + 1;
        if ls.linenumber >= self.MAX_INT then
            self:syntaxerror(ls, "chunk has too many lines");
        end;
    end;
    function luaX:setinput(L, ls, z, source)
        if not ls then ls = {}; end;
        if not ls.lookahead then ls.lookahead = {}; end;
        if not ls.t then ls.t = {}; end;
        ls.decpoint = ".";
        ls.L = L;
        ls.lookahead.token = "TK_EOS";
        ls.z = z;
        ls.fs = nil;
        ls.linenumber = 1;
        ls.lastline = 1;
        ls.source = source;
        self:nextc(ls);
    end;
    function luaX:check_next(ls, set)
        if not string.find(set, ls.current, 1) then
            return false;
        end;
        self:save_and_next(ls);
        return true;
    end;
    function luaX:next(ls)
        ls.lastline = ls.linenumber;
        if ls.lookahead.token ~= "TK_EOS" then  
            ls.t.seminfo = ls.lookahead.seminfo;
            ls.t.token = ls.lookahead.token;
            ls.lookahead.token = "TK_EOS";
        else
            ls.t.token = self:llex(ls, ls.t);
        end;
    end;
    function luaX:lookahead(ls)
        ls.lookahead.token = self:llex(ls, ls.lookahead);
    end;
    function luaX:nextc(ls)
        local c = luaZ:zgetc(ls.z);
        ls.current = c;
        return c;
    end;
    function luaX:save(ls, c)
        local buff = ls.buff;
        ls.buff = buff..c;
    end;
    function luaX:save_and_next(ls)
        self:save(ls, ls.current);
        return self:nextc(ls);
    end;
    function luaX:str2d(s)
        local result = tonumber(s);
        if result then return result; end;
        if string.lower(string.sub(s, 1, 2)) == "0x" then  
            result = tonumber(s, 16);
            if result then return result; end;
        end;
        return nil;
    end;
    function luaX:buffreplace(ls, from, to)
        local result, buff = "", ls.buff;
        for p = 1, #buff do
            local c = string.sub(buff, p, p);
            if c == from then c = to; end;
            result = result..c;
        end;
        ls.buff = result;
    end;

    function luaX:trydecpoint(ls, Token)
        local old = ls.decpoint;
        self:buffreplace(ls, old, ls.decpoint)  ;
        local seminfo = self:str2d(ls.buff);
        Token.seminfo = seminfo;
        if not seminfo then
            self:buffreplace(ls, ls.decpoint, ".");
            self:lexerror(ls, "malformed number", "TK_NUMBER");
        end;
    end;

    function luaX:read_numeral(ls, Token)
        repeat
            self:save_and_next(ls);
        until string.find(ls.current, "%D") and ls.current ~= ".";
        if self:check_next(ls, "Ee") then  
            self:check_next(ls, "+-");
        end;
        while string.find(ls.current, "^%w$") or ls.current == "_" do
            self:save_and_next(ls);
        end;
        self:buffreplace(ls, ".", ls.decpoint);
        local seminfo = self:str2d(ls.buff);
        Token.seminfo = seminfo;
        if not seminfo then
            self:trydecpoint(ls, Token);
        end;
    end;
    function luaX:skip_sep(ls)
        local count = 0;
        local s = ls.current;
        self:save_and_next(ls);
        while ls.current == "=" do
            self:save_and_next(ls);
            count = count + 1;
        end;
        return (ls.current == s) and count or (-count) - 1;
    end;
    function luaX:read_long_string(ls, Token, sep)
        local cont = 0;
        self:save_and_next(ls);
        if self:currIsNewline(ls) then  
            self:inclinenumber(ls);
        end;
        while true do
            local c = ls.current;
            if c == "EOZ" then
                self:lexerror(ls, Token and "unfinished long string" or"unfinished long comment", "TK_EOS");
            elseif c == "[" then
                if self.LUA_COMPAT_LSTR then
                    if self:skip_sep(ls) == sep then
                        self:save_and_next(ls);
                        cont = cont + 1;
                        if self.LUA_COMPAT_LSTR == 1 then
                            if sep == 0 then
                                self:lexerror(ls, "nesting of [[...]] is deprecated", "[");
                            end;
                        end;
                    end;
                end;
            elseif c == "]" then
                if self:skip_sep(ls) == sep then
                    self:save_and_next(ls);
                    if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR == 2 then
                        cont = cont - 1;
                        if sep == 0 and cont >= 0 then break; end;
                    end;
                    break;
                end;
            elseif self:currIsNewline(ls) then
                self:save(ls, "\n");
                self:inclinenumber(ls);
                if not Token then ls.buff = ""; end;
            else
                if Token then
                    self:save_and_next(ls);
                else
                    self:nextc(ls);
                end;
            end
        end
        if Token then
            local p = 3 + sep;
            Token.seminfo = string.sub(ls.buff, p, -p);
        end;
    end;
    function luaX:read_string(ls, del, Token)
        self:save_and_next(ls);
        while ls.current ~= del do
            local c = ls.current;
            if c == "EOZ" then
                self:lexerror(ls, "unfinished string", "TK_EOS");
            elseif self:currIsNewline(ls) then
                self:lexerror(ls, "unfinished string", "TK_STRING");
            elseif c == "\\" then
                c = self:nextc(ls);
                if self:currIsNewline(ls) then  
                    self:save(ls, "\n");
                    self:inclinenumber(ls);
                else
                    local i = string.find("abfnrtv", c, 1);
                    if i then
                        self:save(ls, string.sub("\a\b\f\n\r\t\v", i, i));
                        self:nextc(ls);
                    elseif not string.find(c, "%d") then
                        self:save_and_next(ls);
                    else
                        c, i = 0, 0;
                        repeat
                            c = 10 * c + ls.current;
                            self:nextc(ls);
                            i = i + 1;
                        until i >= 3 or not string.find(ls.current, "%d");
                        if c > 255 then  
                            self:lexerror(ls, "escape sequence too large", "TK_STRING");
                        end;
                        self:save(ls, string.char(c));
                    end;
                end;
            else
                self:save_and_next(ls);
            end;
        end;
        self:save_and_next(ls);
        Token.seminfo = string.sub(ls.buff, 2, -2);
    end;
    function luaX:llex(ls, Token)
        ls.buff = "";
        while true do
            local c = ls.current;
            if self:currIsNewline(ls) then
                self:inclinenumber(ls);
            elseif c == "-" then
                c = self:nextc(ls);
                if c ~= "-" then return "-"; end;
                local sep = -1;
                if self:nextc(ls) == '[' then
                    sep = self:skip_sep(ls);
                    ls.buff = "";
                end;
                if sep >= 0 then
                    self:read_long_string(ls, nil, sep);
                    ls.buff = "";
                else  
                    while not self:currIsNewline(ls) and ls.current ~= "EOZ" do
                        self:nextc(ls);
                    end;
                end;
            elseif c == "[" then
                local sep = self:skip_sep(ls);
                if sep >= 0 then
                    self:read_long_string(ls, Token, sep);
                    return "TK_STRING";
                elseif sep == -1 then
                    return "[";
                else
                    self:lexerror(ls, "invalid long string delimiter", "TK_STRING");
                end;
            elseif c == "=" then
                c = self:nextc(ls);
                if c ~= "=" then return "=";else self:nextc(ls); return "TK_EQ"; end;
            elseif c == "<" then
                c = self:nextc(ls);if c ~= "=" then return "<" else self:nextc(ls); return "TK_LE" end;
            elseif c == ">" then
                c = self:nextc(ls);if c ~= "=" then return ">" else self:nextc(ls); return "TK_GE" end;
            elseif c == "~" then
                c = self:nextc(ls);if c ~= "=" then return "~" else self:nextc(ls); return "TK_NE" end;
            elseif c == "\"" or c == "'" then
                self:read_string(ls, c, Token);return "TK_STRING"
            elseif c == "." then
                c = self:save_and_next(ls);
                if self:check_next(ls, ".") then
                    if self:check_next(ls, ".") then return "TK_DOTS"; else return "TK_CONCAT"; end;
                elseif not string.find(c, "%d") then
                    return ".";
                else
                    self:read_numeral(ls, Token)
                    return "TK_NUMBER";
                end;
            elseif c == "EOZ" then
                return "TK_EOS";
            else  
                if string.find(c, "%s") then
                    self:nextc(ls);
                elseif string.find(c, "%d") then
                    self:read_numeral(ls, Token);
                    return "TK_NUMBER";
                elseif string.find(c, "[_%a]") then
                    repeat
                        c = self:save_and_next(ls);
                    until c == "EOZ" or not string.find(c, "[_%w]");
                    local ts = ls.buff;
                    local tok = self.enums[ts];
                    if tok then return tok; end;
                    Token.seminfo = ts;
                    return "TK_NAME";
                else
                    self:nextc(ls);
                    return c;
                end;
            end;
        end;
    end;
    local luaK = {};
    local luaY;
    luaK.MAXSTACK = 250;
    function luaK:ttisnumber(o)
        if o then return type(o.value) == "number"; else return false; end;
    end
    function luaK:nvalue(o) return o.value end;
    function luaK:setnilvalue(o) o.value = nil end;
    function luaK:setsvalue(o, x) o.value = x end;
    luaK.setnvalue = luaK.setsvalue;
    luaK.sethvalue = luaK.setsvalue;
    luaK.setbvalue = luaK.setsvalue;
    function luaK:numadd(a, b) return a + b end;
    function luaK:numsub(a, b) return a - b end;
    function luaK:nummul(a, b) return a * b end;
    function luaK:numdiv(a, b) return a / b end;
    function luaK:nummod(a, b) return a % b end;
    function luaK:numpow(a, b) return a ^ b end;
    function luaK:numunm(a) return -a end;
    function luaK:numisnan(a) return a ~= a end;
    luaK.NO_JUMP = -1;
    luaK.BinOpr = {
        OPR_ADD = 0, OPR_SUB = 1, OPR_MUL = 2, OPR_DIV = 3, OPR_MOD = 4, OPR_POW = 5,
        OPR_CONCAT = 6,
        OPR_NE = 7, OPR_EQ = 8,
        OPR_LT = 9, OPR_LE = 10, OPR_GT = 11, OPR_GE = 12,
        OPR_AND = 13, OPR_OR = 14,
        OPR_NOBINOPR = 15,
    };
    luaK.UnOpr = {
        OPR_MINUS = 0, OPR_NOT = 1, OPR_LEN = 2, OPR_NOUNOPR = 3
    };
    function luaK:getcode(fs, e)
        return fs.f.code[e.info];
    end;
    function luaK:codeAsBx(fs, o, A, sBx)
        return self:codeABx(fs, o, A, sBx + luaP.MAXARG_sBx);
    end;
    function luaK:setmultret(fs, e)
        self:setreturns(fs, e, luaY.LUA_MULTRET);
    end;
    function luaK:hasjumps(e)
        return e.t ~= e.f;
    end;
    function luaK:isnumeral(e)
        return e.k == "VKNUM" and e.t == self.NO_JUMP and e.f == self.NO_JUMP;
    end;
    function luaK:_nil(fs, from, n)
        if fs.pc > fs.lasttarget then
            if fs.pc == 0 then
                if from >= fs.nactvar then
                    return
                end
            else
                local previous = fs.f.code[fs.pc - 1]
                if luaP:GET_OPCODE(previous) == "OP_LOADNIL" then
                    local pfrom = luaP:GETARG_A(previous)
                    local pto = luaP:GETARG_B(previous)
                    if pfrom <= from and from <= pto + 1 then
                        if from + n - 1 > pto then
                            luaP:SETARG_B(previous, from + n - 1)
                        end
                        return
                    end
                end
            end
        end
        self:codeABC(fs, "OP_LOADNIL", from, from + n - 1, 0)
    end
    function luaK:jump(fs)
        local jpc = fs.jpc  
        fs.jpc = self.NO_JUMP
        local j = self:codeAsBx(fs, "OP_JMP", 0, self.NO_JUMP)
        j = self:concat(fs, j, jpc)  
        return j
    end
    function luaK:ret(fs, first, nret)
        self:codeABC(fs, "OP_RETURN", first, nret + 1, 0)
    end
    function luaK:condjump(fs, op, A, B, C)
        self:codeABC(fs, op, A, B, C)
        return self:jump(fs)
    end
    function luaK:fixjump(fs, pc, dest)
        local jmp = fs.f.code[pc]
        local offset = dest - (pc + 1)
        assert(dest ~= self.NO_JUMP)
        if math.abs(offset) > luaP.MAXARG_sBx then
            luaX:syntaxerror(fs.ls, "control structure too long")
        end
        luaP:SETARG_sBx(jmp, offset)
    end
    function luaK:getlabel(fs)
        fs.lasttarget = fs.pc
        return fs.pc
    end
    function luaK:getjump(fs, pc)
        local offset = luaP:GETARG_sBx(fs.f.code[pc])
        if offset == self.NO_JUMP then
            return self.NO_JUMP
        else
            return (pc + 1) + offset
        end
    end
    function luaK:getjumpcontrol(fs, pc)
        local pi = fs.f.code[pc]
        local ppi = fs.f.code[pc - 1]
        if pc >= 1 and luaP:testTMode(luaP:GET_OPCODE(ppi)) ~= 0 then
            return ppi
        else
            return pi
        end
    end
    function luaK:need_value(fs, list)
        while list ~= self.NO_JUMP do
            local i = self:getjumpcontrol(fs, list)
            if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then return true end
            list = self:getjump(fs, list)
        end
        return false  
    end
    function luaK:patchtestreg(fs, node, reg)
        local i = self:getjumpcontrol(fs, node)
        if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
            return false  
        end
        if reg ~= luaP.NO_REG and reg ~= luaP:GETARG_B(i) then
            luaP:SETARG_A(i, reg)
        else
            luaP:SET_OPCODE(i, "OP_TEST")
            local b = luaP:GETARG_B(i)
            luaP:SETARG_A(i, b)
            luaP:SETARG_B(i, 0)
        end
        return true
    end
    function luaK:removevalues(fs, list)
        while list ~= self.NO_JUMP do
            self:patchtestreg(fs, list, luaP.NO_REG)
            list = self:getjump(fs, list)
        end
    end
    function luaK:patchlistaux(fs, list, vtarget, reg, dtarget)
        while list ~= self.NO_JUMP do
            local _next = self:getjump(fs, list)
            if self:patchtestreg(fs, list, reg) then
                self:fixjump(fs, list, vtarget)
            else
                self:fixjump(fs, list, dtarget)
            end
            list = _next
        end
    end
    function luaK:dischargejpc(fs)
        self:patchlistaux(fs, fs.jpc, fs.pc, luaP.NO_REG, fs.pc)
        fs.jpc = self.NO_JUMP
    end
    function luaK:patchlist(fs, list, target)
        if target == fs.pc then
            self:patchtohere(fs, list)
        else
            assert(target < fs.pc)
            self:patchlistaux(fs, list, target, luaP.NO_REG, target)
        end
    end
    function luaK:patchtohere(fs, list)
        self:getlabel(fs)
        fs.jpc = self:concat(fs, fs.jpc, list)
    end
    function luaK:concat(fs, l1, l2)
        if l2 == self.NO_JUMP then return l1
        elseif l1 == self.NO_JUMP then
            return l2
        else
            local list = l1
            local _next = self:getjump(fs, list)
            while _next ~= self.NO_JUMP do  
                list = _next
                _next = self:getjump(fs, list)
            end
            self:fixjump(fs, list, l2)
        end
        return l1
    end

    function luaK:checkstack(fs, n)
        local newstack = fs.freereg + n
        if newstack > fs.f.maxstacksize then
            if newstack >= self.MAXSTACK then
                luaX:syntaxerror(fs.ls, "function or expression too complex")
            end
            fs.f.maxstacksize = newstack
        end
    end

    function luaK:reserveregs(fs, n)
        self:checkstack(fs, n)
        fs.freereg = fs.freereg + n
    end

    function luaK:freereg(fs, reg)
        if not luaP:ISK(reg) and reg >= fs.nactvar then
            fs.freereg = fs.freereg - 1
            assert(reg == fs.freereg)
        end
    end

    function luaK:freeexp(fs, e)
        if e.k == "VNONRELOC" then
            self:freereg(fs, e.info)
        end
    end

    function luaK:addk(fs, k, v)
        local L = fs.L
        local idx = fs.h[k.value]

        local f = fs.f
        if self:ttisnumber(idx) then

            return self:nvalue(idx)
        else 
            idx = {}
            self:setnvalue(idx, fs.nk)
            fs.h[k.value] = idx

            luaY:growvector(L, f.k, fs.nk, f.sizek, nil,
                luaP.MAXARG_Bx, "constant table overflow")

            f.k[fs.nk] = v

            local nk = fs.nk
            fs.nk = fs.nk + 1
            return nk
        end

    end

    function luaK:stringK(fs, s)
        local o = {}  
        self:setsvalue(o, s)
        return self:addk(fs, o, o)
    end

    function luaK:numberK(fs, r)
        local o = {}  
        self:setnvalue(o, r)
        return self:addk(fs, o, o)
    end

    function luaK:boolK(fs, b)
        local o = {}  
        self:setbvalue(o, b)
        return self:addk(fs, o, o)
    end

    function luaK:nilK(fs)
        local k, v = {}, {}  
        self:setnilvalue(v)

        self:sethvalue(k, fs.h)
        return self:addk(fs, k, v)
    end

    function luaK:setreturns(fs, e, nresults)
        if e.k == "VCALL" then  
            luaP:SETARG_C(self:getcode(fs, e), nresults + 1)
        elseif e.k == "VVARARG" then
            luaP:SETARG_B(self:getcode(fs, e), nresults + 1);
            luaP:SETARG_A(self:getcode(fs, e), fs.freereg);
            luaK:reserveregs(fs, 1)
        end
    end

    function luaK:setoneret(fs, e)
        if e.k == "VCALL" then  
            e.k = "VNONRELOC"
            e.info = luaP:GETARG_A(self:getcode(fs, e))
        elseif e.k == "VVARARG" then
            luaP:SETARG_B(self:getcode(fs, e), 2)
            e.k = "VRELOCABLE"  
        end
    end

    function luaK:dischargevars(fs, e)
        local k = e.k
        if k == "VLOCAL" then
            e.k = "VNONRELOC"
        elseif k == "VUPVAL" then
            e.info = self:codeABC(fs, "OP_GETUPVAL", 0, e.info, 0)
            e.k = "VRELOCABLE"
        elseif k == "VGLOBAL" then
            e.info = self:codeABx(fs, "OP_GETGLOBAL", 0, e.info)
            e.k = "VRELOCABLE"
        elseif k == "VINDEXED" then
            self:freereg(fs, e.aux)
            self:freereg(fs, e.info)
            e.info = self:codeABC(fs, "OP_GETTABLE", 0, e.info, e.aux)
            e.k = "VRELOCABLE"
        elseif k == "VVARARG" or k == "VCALL" then
            self:setoneret(fs, e)
        else

        end
    end

    function luaK:code_label(fs, A, b, jump)
        self:getlabel(fs)  
        return self:codeABC(fs, "OP_LOADBOOL", A, b, jump)
    end

    function luaK:discharge2reg(fs, e, reg)
        self:dischargevars(fs, e)
        local k = e.k
        if k == "VNIL" then
            self:_nil(fs, reg, 1)
        elseif k == "VFALSE" or k == "VTRUE" then
            self:codeABC(fs, "OP_LOADBOOL", reg, (e.k == "VTRUE") and 1 or 0, 0)
        elseif k == "VK" then
            self:codeABx(fs, "OP_LOADK", reg, e.info)
        elseif k == "VKNUM" then
            self:codeABx(fs, "OP_LOADK", reg, self:numberK(fs, e.nval))
        elseif k == "VRELOCABLE" then
            local pc = self:getcode(fs, e)
            luaP:SETARG_A(pc, reg)
        elseif k == "VNONRELOC" then
            if reg ~= e.info then
                self:codeABC(fs, "OP_MOVE", reg, e.info, 0)
            end
        else
            assert(e.k == "VVOID" or e.k == "VJMP")
            return  
        end
        e.info = reg
        e.k = "VNONRELOC"
    end

    function luaK:discharge2anyreg(fs, e)
        if e.k ~= "VNONRELOC" then
            self:reserveregs(fs, 1)
            self:discharge2reg(fs, e, fs.freereg - 1)
        end
    end

    function luaK:exp2reg(fs, e, reg)
        self:discharge2reg(fs, e, reg)
        if e.k == "VJMP" then
            e.t = self:concat(fs, e.t, e.info)  
        end
        if self:hasjumps(e) then
            local final  
            local p_f = self.NO_JUMP  
            local p_t = self.NO_JUMP  
            if self:need_value(fs, e.t) or self:need_value(fs, e.f) then
                local fj = (e.k == "VJMP") and self.NO_JUMP or self:jump(fs)
                p_f = self:code_label(fs, reg, 0, 1)
                p_t = self:code_label(fs, reg, 1, 0)
                self:patchtohere(fs, fj)
            end
            final = self:getlabel(fs)
            self:patchlistaux(fs, e.f, final, reg, p_f)
            self:patchlistaux(fs, e.t, final, reg, p_t)
        end
        e.f, e.t = self.NO_JUMP, self.NO_JUMP
        e.info = reg
        e.k = "VNONRELOC"
    end

    function luaK:exp2nextreg(fs, e)
        self:dischargevars(fs, e)
        self:freeexp(fs, e)
        self:reserveregs(fs, 1)
        self:exp2reg(fs, e, fs.freereg - 1)
    end

    function luaK:exp2anyreg(fs, e)
        self:dischargevars(fs, e)
        if e.k == "VNONRELOC" then
            if not self:hasjumps(e) then  
                return e.info
            end
            if e.info >= fs.nactvar then  
                self:exp2reg(fs, e, e.info)  
                return e.info
            end
        end
        self:exp2nextreg(fs, e)  
        return e.info
    end

    function luaK:exp2val(fs, e)
        if self:hasjumps(e) then
            self:exp2anyreg(fs, e)
        else
            self:dischargevars(fs, e)
        end
    end

    function luaK:exp2RK(fs, e)
        self:exp2val(fs, e)
        local k = e.k
        if k == "VKNUM" or k == "VTRUE" or k == "VFALSE" or k == "VNIL" then
            if fs.nk <= luaP.MAXINDEXRK then  

                if e.k == "VNIL" then
                    e.info = self:nilK(fs)
                else
                    e.info = (e.k == "VKNUM") and self:numberK(fs, e.nval)
                        or self:boolK(fs, e.k == "VTRUE")
                end
                e.k = "VK"
                return luaP:RKASK(e.info)
            end
        elseif k == "VK" then
            if e.info <= luaP.MAXINDEXRK then  
                return luaP:RKASK(e.info)
            end
        else

        end

        return self:exp2anyreg(fs, e)
    end

    function luaK:storevar(fs, var, ex)
        local k = var.k
        if k == "VLOCAL" then
            self:freeexp(fs, ex)
            self:exp2reg(fs, ex, var.info)
            return
        elseif k == "VUPVAL" then
            local e = self:exp2anyreg(fs, ex)
            self:codeABC(fs, "OP_SETUPVAL", e, var.info, 0)
        elseif k == "VGLOBAL" then
            local e = self:exp2anyreg(fs, ex)
            self:codeABx(fs, "OP_SETGLOBAL", e, var.info)
        elseif k == "VINDEXED" then
            local e = self:exp2RK(fs, ex)
            self:codeABC(fs, "OP_SETTABLE", var.info, var.aux, e)
        else
            assert(0)  
        end
        self:freeexp(fs, ex)
    end

    function luaK:_self(fs, e, key)
        self:exp2anyreg(fs, e)
        self:freeexp(fs, e)
        local func = fs.freereg
        self:reserveregs(fs, 2)
        self:codeABC(fs, "OP_SELF", func, e.info, self:exp2RK(fs, key))
        self:freeexp(fs, key)
        e.info = func
        e.k = "VNONRELOC"
    end

    function luaK:invertjump(fs, e)
        local pc = self:getjumpcontrol(fs, e.info)
        assert(luaP:testTMode(luaP:GET_OPCODE(pc)) ~= 0 and
            luaP:GET_OPCODE(pc) ~= "OP_TESTSET" and
            luaP:GET_OPCODE(pc) ~= "OP_TEST")
        luaP:SETARG_A(pc, (luaP:GETARG_A(pc) == 0) and 1 or 0)
    end

    function luaK:jumponcond(fs, e, cond)
        if e.k == "VRELOCABLE" then
            local ie = self:getcode(fs, e)
            if luaP:GET_OPCODE(ie) == "OP_NOT" then
                fs.pc = fs.pc - 1  
                return self:condjump(fs, "OP_TEST", luaP:GETARG_B(ie), 0, cond and 0 or 1)
            end

        end
        self:discharge2anyreg(fs, e)
        self:freeexp(fs, e)
        return self:condjump(fs, "OP_TESTSET", luaP.NO_REG, e.info, cond and 1 or 0)
    end

    function luaK:goiftrue(fs, e)
        local pc  
        self:dischargevars(fs, e)
        local k = e.k
        if k == "VK" or k == "VKNUM" or k == "VTRUE" then
            pc = self.NO_JUMP  
        elseif k == "VFALSE" then
            pc = self:jump(fs)  
        elseif k == "VJMP" then
            self:invertjump(fs, e)
            pc = e.info
        else
            pc = self:jumponcond(fs, e, false)
        end
        e.f = self:concat(fs, e.f, pc)  
        self:patchtohere(fs, e.t)
        e.t = self.NO_JUMP
    end

    function luaK:goiffalse(fs, e)
        local pc  
        self:dischargevars(fs, e)
        local k = e.k
        if k == "VNIL" or k == "VFALSE"then
            pc = self.NO_JUMP  
        elseif k == "VTRUE" then
            pc = self:jump(fs)  
        elseif k == "VJMP" then
            pc = e.info
        else
            pc = self:jumponcond(fs, e, true)
        end
        e.t = self:concat(fs, e.t, pc)  
        self:patchtohere(fs, e.f)
        e.f = self.NO_JUMP
    end

    function luaK:codenot(fs, e)
        self:dischargevars(fs, e)
        local k = e.k
        if k == "VNIL" or k == "VFALSE" then
            e.k = "VTRUE"
        elseif k == "VK" or k == "VKNUM" or k == "VTRUE" then
            e.k = "VFALSE"
        elseif k == "VJMP" then
            self:invertjump(fs, e)
        elseif k == "VRELOCABLE" or k == "VNONRELOC" then
            self:discharge2anyreg(fs, e)
            self:freeexp(fs, e)
            e.info = self:codeABC(fs, "OP_NOT", 0, e.info, 0)
            e.k = "VRELOCABLE"
        else
            assert(0)  
        end

        e.f, e.t = e.t, e.f
        self:removevalues(fs, e.f)
        self:removevalues(fs, e.t)
    end

    function luaK:indexed(fs, t, k)
        t.aux = self:exp2RK(fs, k)
        t.k = "VINDEXED"
    end

    function luaK:constfolding(op, e1, e2)
        local r
        if not self:isnumeral(e1) or not self:isnumeral(e2) then return false end
        local v1 = e1.nval
        local v2 = e2.nval
        if op == "OP_ADD" then
            r = self:numadd(v1, v2)
        elseif op == "OP_SUB" then
            r = self:numsub(v1, v2)
        elseif op == "OP_MUL" then
            r = self:nummul(v1, v2)
        elseif op == "OP_DIV" then
            if v2 == 0 then return false end  
            r = self:numdiv(v1, v2)
        elseif op == "OP_MOD" then
            if v2 == 0 then return false end  
            r = self:nummod(v1, v2)
        elseif op == "OP_POW" then
            r = self:numpow(v1, v2)
        elseif op == "OP_UNM" then
            r = self:numunm(v1)
        elseif op == "OP_LEN" then
            return false  
        else
            assert(0)
            r = 0
        end
        if self:numisnan(r) then return false end  
        e1.nval = r
        return true
    end

    function luaK:codearith(fs, op, e1, e2)
        if self:constfolding(op, e1, e2) then
            return
        else
            local o2 = (op ~= "OP_UNM" and op ~= "OP_LEN") and self:exp2RK(fs, e2) or 0
            local o1 = self:exp2RK(fs, e1)
            if o1 > o2 then
                self:freeexp(fs, e1)
                self:freeexp(fs, e2)
            else
                self:freeexp(fs, e2)
                self:freeexp(fs, e1)
            end
            e1.info = self:codeABC(fs, op, 0, o1, o2)
            e1.k = "VRELOCABLE"
        end
    end

    function luaK:codecomp(fs, op, cond, e1, e2)
        local o1 = self:exp2RK(fs, e1)
        local o2 = self:exp2RK(fs, e2)
        self:freeexp(fs, e2)
        self:freeexp(fs, e1)
        if cond == 0 and op ~= "OP_EQ" then

            o1, o2 = o2, o1  
            cond = 1
        end
        e1.info = self:condjump(fs, op, cond, o1, o2)
        e1.k = "VJMP"
    end

    function luaK:prefix(fs, op, e)
        local e2 = {}  
        e2.t, e2.f = self.NO_JUMP, self.NO_JUMP
        e2.k = "VKNUM"
        e2.nval = 0
        if op == "OPR_MINUS" then
            if not self:isnumeral(e) then
                self:exp2anyreg(fs, e)  
            end
            self:codearith(fs, "OP_UNM", e, e2)
        elseif op == "OPR_NOT" then
            self:codenot(fs, e)
        elseif op == "OPR_LEN" then
            self:exp2anyreg(fs, e)  
            self:codearith(fs, "OP_LEN", e, e2)
        else
            assert(0)
        end
    end

    function luaK:infix(fs, op, v)
        if op == "OPR_AND" then
            self:goiftrue(fs, v)
        elseif op == "OPR_OR" then
            self:goiffalse(fs, v)
        elseif op == "OPR_CONCAT" then
            self:exp2nextreg(fs, v)  
        elseif op == "OPR_ADD" or op == "OPR_SUB" or
            op == "OPR_MUL" or op == "OPR_DIV" or
            op == "OPR_MOD" or op == "OPR_POW" then
            if not self:isnumeral(v) then self:exp2RK(fs, v) end
        else
            self:exp2RK(fs, v)
        end
    end

    luaK.arith_op = {
        OPR_ADD = "OP_ADD", OPR_SUB = "OP_SUB", OPR_MUL = "OP_MUL",
        OPR_DIV = "OP_DIV", OPR_MOD = "OP_MOD", OPR_POW = "OP_POW",
    }
    luaK.comp_op = {
        OPR_EQ = "OP_EQ", OPR_NE = "OP_EQ", OPR_LT = "OP_LT",
        OPR_LE = "OP_LE", OPR_GT = "OP_LT", OPR_GE = "OP_LE",
    }
    luaK.comp_cond = {
        OPR_EQ = 1, OPR_NE = 0, OPR_LT = 1,
        OPR_LE = 1, OPR_GT = 0, OPR_GE = 0,
    }
    function luaK:posfix(fs, op, e1, e2)

        local function copyexp(e1, e2)
            e1.k = e2.k
            e1.info = e2.info; e1.aux = e2.aux
            e1.nval = e2.nval
            e1.t = e2.t; e1.f = e2.f
        end
        if op == "OPR_AND" then
            assert(e1.t == self.NO_JUMP)  
            self:dischargevars(fs, e2)
            e2.f = self:concat(fs, e2.f, e1.f)
            copyexp(e1, e2)
        elseif op == "OPR_OR" then
            assert(e1.f == self.NO_JUMP)  
            self:dischargevars(fs, e2)
            e2.t = self:concat(fs, e2.t, e1.t)
            copyexp(e1, e2)
        elseif op == "OPR_CONCAT" then
            self:exp2val(fs, e2)
            if e2.k == "VRELOCABLE" and luaP:GET_OPCODE(self:getcode(fs, e2)) == "OP_CONCAT" then
                assert(e1.info == luaP:GETARG_B(self:getcode(fs, e2)) - 1)
                self:freeexp(fs, e1)
                luaP:SETARG_B(self:getcode(fs, e2), e1.info)
                e1.k = "VRELOCABLE"
                e1.info = e2.info
            else
                self:exp2nextreg(fs, e2)  
                self:codearith(fs, "OP_CONCAT", e1, e2)
            end
        else

            local arith = self.arith_op[op]
            if arith then
                self:codearith(fs, arith, e1, e2)
            else
                local comp = self.comp_op[op]
                if comp then
                    self:codecomp(fs, comp, self.comp_cond[op], e1, e2)
                else
                    assert(0)
                end
            end
        end
    end

    function luaK:fixline(fs, line)
        fs.f.lineinfo[fs.pc - 1] = line
    end

    function luaK:code(fs, i, line)
        local f = fs.f
        self:dischargejpc(fs)  

        luaY:growvector(fs.L, f.code, fs.pc, f.sizecode, nil,
            luaY.MAX_INT, "code size overflow")
        f.code[fs.pc] = i

        luaY:growvector(fs.L, f.lineinfo, fs.pc, f.sizelineinfo, nil,
            luaY.MAX_INT, "code size overflow")
        f.lineinfo[fs.pc] = line
        local pc = fs.pc
        fs.pc = fs.pc + 1
        return pc
    end

    function luaK:codeABC(fs, o, a, b, c)
        assert(luaP:getOpMode(o) == luaP.OpMode.iABC)
        assert(luaP:getBMode(o) ~= luaP.OpArgMask.OpArgN or b == 0)
        assert(luaP:getCMode(o) ~= luaP.OpArgMask.OpArgN or c == 0)
        return self:code(fs, luaP:CREATE_ABC(o, a, b, c), fs.ls.lastline)
    end

    function luaK:codeABx(fs, o, a, bc)
        assert(luaP:getOpMode(o) == luaP.OpMode.iABx or
            luaP:getOpMode(o) == luaP.OpMode.iAsBx)
        assert(luaP:getCMode(o) == luaP.OpArgMask.OpArgN)
        return self:code(fs, luaP:CREATE_ABx(o, a, bc), fs.ls.lastline)
    end

    function luaK:setlist(fs, base, nelems, tostore)
        local c = math.floor((nelems - 1)/luaP.LFIELDS_PER_FLUSH) + 1
        local b = (tostore == luaY.LUA_MULTRET) and 0 or tostore
        assert(tostore ~= 0)
        if c <= luaP.MAXARG_C then
            self:codeABC(fs, "OP_SETLIST", base, b, c)
        else
            self:codeABC(fs, "OP_SETLIST", base, b, 0)
            self:code(fs, luaP:CREATE_Inst(c), fs.ls.lastline)
        end
        fs.freereg = base + 1  
    end

    luaY = {}
    luaY.LUA_QS = luaX.LUA_QS or "'%s'"  
    luaY.SHRT_MAX = 32767 
    luaY.LUAI_MAXVARS = 200  
    luaY.LUAI_MAXUPVALUES = 60  
    luaY.MAX_INT = luaX.MAX_INT or 2147483645  

    luaY.LUAI_MAXCCALLS = 200  

    luaY.VARARG_HASARG = 1  

    luaY.HASARG_MASK = 2 
    luaY.VARARG_ISVARARG = 2

    luaY.VARARG_NEEDSARG = 4

    luaY.LUA_MULTRET = -1  

    function luaY:LUA_QL(x)
        return "'"..x.."'"
    end

    function luaY:growvector(L, v, nelems, size, t, limit, e)
        if nelems >= limit then
            error(e)  
        end
    end

    function luaY:newproto(L)
        local f = {} 

        f.k = {}
        f.sizek = 0
        f.p = {}
        f.sizep = 0
        f.code = {}
        f.sizecode = 0
        f.sizelineinfo = 0
        f.sizeupvalues = 0
        f.nups = 0
        f.upvalues = {}
        f.numparams = 0
        f.is_vararg = 0
        f.maxstacksize = 0
        f.lineinfo = {}
        f.sizelocvars = 0
        f.locvars = {}
        f.lineDefined = 0
        f.lastlinedefined = 0
        f.source = nil
        return f
    end

    function luaY:int2fb(x)
        local e = 0  
        while x >= 16 do
            x = math.floor((x + 1) / 2)
            e = e + 1
        end
        if x < 8 then
            return x
        else
            return ((e + 1) * 8) + (x - 8)
        end
    end

    function luaY:hasmultret(k)
        return k == "VCALL" or k == "VVARARG"
    end

    function luaY:getlocvar(fs, i)
        return fs.f.locvars[ fs.actvar[i] ]
    end

    function luaY:checklimit(fs, v, l, m)
        if v > l then self:errorlimit(fs, l, m) end
    end

    function luaY:anchor_token(ls)
        if ls.t.token == "TK_NAME" or ls.t.token == "TK_STRING" then

        end
    end

    function luaY:error_expected(ls, token)
        luaX:syntaxerror(ls,
            string.format(self.LUA_QS.." expected", luaX:token2str(ls, token)))
    end

    function luaY:errorlimit(fs, limit, what)
        local msg = (fs.f.linedefined == 0) and
            string.format("main function has more than %d %s", limit, what) or
            string.format("function at line %d has more than %d %s",
                fs.f.linedefined, limit, what)
        luaX:lexerror(fs.ls, msg, 0)
    end

    function luaY:testnext(ls, c)
        if ls.t.token == c then
            luaX:next(ls)
            return true
        else
            return false
        end
    end

    function luaY:check(ls, c)
        if ls.t.token ~= c then
            self:error_expected(ls, c)
        end
    end

    function luaY:checknext(ls, c)
        self:check(ls, c)
        luaX:next(ls)
    end

    function luaY:check_condition(ls, c, msg)
        if not c then luaX:syntaxerror(ls, msg) end
    end

    function luaY:check_match(ls, what, who, where)
        if not self:testnext(ls, what) then
            if where == ls.linenumber then
                self:error_expected(ls, what)
            else
                luaX:syntaxerror(ls, string.format(
                    self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",
                    luaX:token2str(ls, what), luaX:token2str(ls, who), where))
            end
        end
    end

    function luaY:str_checkname(ls)
        self:check(ls, "TK_NAME")
        local ts = ls.t.seminfo
        luaX:next(ls)
        return ts
    end

    function luaY:init_exp(e, k, i)
        e.f, e.t = luaK.NO_JUMP, luaK.NO_JUMP
        e.k = k
        e.info = i
    end

    function luaY:codestring(ls, e, s)
        self:init_exp(e, "VK", luaK:stringK(ls.fs, s))
    end

    function luaY:checkname(ls, e)
        self:codestring(ls, e, self:str_checkname(ls))
    end

    function luaY:registerlocalvar(ls, varname)
        local fs = ls.fs
        local f = fs.f
        self:growvector(ls.L, f.locvars, fs.nlocvars, f.sizelocvars,
            nil, self.SHRT_MAX, "too many local variables")

        f.locvars[fs.nlocvars] = {} 
        f.locvars[fs.nlocvars].varname = varname

        local nlocvars = fs.nlocvars
        fs.nlocvars = fs.nlocvars + 1
        return nlocvars
    end

    function luaY:new_localvarliteral(ls, v, n)
        self:new_localvar(ls, v, n)
    end

    function luaY:new_localvar(ls, name, n)
        local fs = ls.fs
        self:checklimit(fs, fs.nactvar + n + 1, self.LUAI_MAXVARS, "local variables")
        fs.actvar[fs.nactvar + n] = self:registerlocalvar(ls, name)
    end

    function luaY:adjustlocalvars(ls, nvars)
        local fs = ls.fs
        fs.nactvar = fs.nactvar + nvars
        for i = nvars, 1, -1 do
            self:getlocvar(fs, fs.nactvar - i).startpc = fs.pc
        end
    end

    function luaY:removevars(ls, tolevel)
        local fs = ls.fs
        while fs.nactvar > tolevel do
            fs.nactvar = fs.nactvar - 1
            self:getlocvar(fs, fs.nactvar).endpc = fs.pc
        end
    end

    function luaY:indexupvalue(fs, name, v)
        local f = fs.f
        for i = 0, f.nups - 1 do
            if fs.upvalues[i].k == v.k and fs.upvalues[i].info == v.info then
                assert(f.upvalues[i] == name)
                return i
            end
        end

        self:checklimit(fs, f.nups + 1, self.LUAI_MAXUPVALUES, "upvalues")
        self:growvector(fs.L, f.upvalues, f.nups, f.sizeupvalues,
            nil, self.MAX_INT, "")

        f.upvalues[f.nups] = name

        assert(v.k == "VLOCAL" or v.k == "VUPVAL")

        fs.upvalues[f.nups] = { k = v.k, info = v.info }
        local nups = f.nups
        f.nups = f.nups + 1
        return nups
    end

    function luaY:searchvar(fs, n)
        for i = fs.nactvar - 1, 0, -1 do
            if n == self:getlocvar(fs, i).varname then
                return i
            end
        end
        return -1  
    end

    function luaY:markupval(fs, level)
        local bl = fs.bl
        while bl and bl.nactvar > level do bl = bl.previous end
        if bl then bl.upval = true end
    end

    function luaY:singlevaraux(fs, n, var, base)
        if fs == nil then  
            self:init_exp(var, "VGLOBAL", luaP.NO_REG)  
            return "VGLOBAL"
        else
            local v = self:searchvar(fs, n)  
            if v >= 0 then
                self:init_exp(var, "VLOCAL", v)
                if base == 0 then
                    self:markupval(fs, v)  
                end
                return "VLOCAL"
            else  
                if self:singlevaraux(fs.prev, n, var, 0) == "VGLOBAL" then
                    return "VGLOBAL"
                end
                var.info = self:indexupvalue(fs, n, var)  
                var.k = "VUPVAL"  
                return "VUPVAL"
            end
        end
    end

    function luaY:singlevar(ls, var)
        local varname = self:str_checkname(ls)
        local fs = ls.fs
        if self:singlevaraux(fs, varname, var, 1) == "VGLOBAL" then
            var.info = luaK:stringK(fs, varname)  
        end
    end

    function luaY:adjust_assign(ls, nvars, nexps, e)
        local fs = ls.fs
        local extra = nvars - nexps
        if self:hasmultret(e.k) then
            extra = extra + 1  
            if extra <= 0 then extra = 0 end
            luaK:setreturns(fs, e, extra)  
            if extra > 1 then luaK:reserveregs(fs, extra - 1) end
        else
            if e.k ~= "VVOID" then luaK:exp2nextreg(fs, e) end  
            if extra > 0 then
                local reg = fs.freereg
                luaK:reserveregs(fs, extra)
                luaK:_nil(fs, reg, extra)
            end
        end
    end

    function luaY:enterlevel(ls)
        ls.L.nCcalls = ls.L.nCcalls + 1
        if ls.L.nCcalls > self.LUAI_MAXCCALLS then
            luaX:lexerror(ls, "chunk has too many syntax levels", 0)
        end
    end

    function luaY:leavelevel(ls)
        ls.L.nCcalls = ls.L.nCcalls - 1
    end

    function luaY:enterblock(fs, bl, isbreakable)
        bl.breaklist = luaK.NO_JUMP
        bl.isbreakable = isbreakable
        bl.nactvar = fs.nactvar
        bl.upval = false
        bl.previous = fs.bl
        fs.bl = bl
        assert(fs.freereg == fs.nactvar)
    end

    function luaY:leaveblock(fs)
        local bl = fs.bl
        fs.bl = bl.previous
        self:removevars(fs.ls, bl.nactvar)
        if bl.upval then
            luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
        end

        assert(not bl.isbreakable or not bl.upval)
        assert(bl.nactvar == fs.nactvar)
        fs.freereg = fs.nactvar  
        luaK:patchtohere(fs, bl.breaklist)
    end

    function luaY:pushclosure(ls, func, v)
        local fs = ls.fs
        local f = fs.f
        self:growvector(ls.L, f.p, fs.np, f.sizep, nil,
            luaP.MAXARG_Bx, "constant table overflow")

        f.p[fs.np] = func.f
        fs.np = fs.np + 1

        self:init_exp(v, "VRELOCABLE", luaK:codeABx(fs, "OP_CLOSURE", 0, fs.np - 1))
        for i = 0, func.f.nups - 1 do
            local o = (func.upvalues[i].k == "VLOCAL") and "OP_MOVE" or "OP_GETUPVAL"
            luaK:codeABC(fs, o, 0, func.upvalues[i].info, 0)
        end
    end

    function luaY:open_func(ls, fs)
        local L = ls.L
        local f = self:newproto(ls.L)
        fs.f = f
        fs.prev = ls.fs  
        fs.ls = ls
        fs.L = L
        ls.fs = fs
        fs.pc = 0
        fs.lasttarget = -1
        fs.jpc = luaK.NO_JUMP
        fs.freereg = 0
        fs.nk = 0
        fs.np = 0
        fs.nlocvars = 0
        fs.nactvar = 0
        fs.bl = nil
        f.source = ls.source
        f.maxstacksize = 2  
        fs.h = {}  

    end

    function luaY:close_func(ls)
        local L = ls.L
        local fs = ls.fs
        local f = fs.f
        self:removevars(ls, 0)
        luaK:ret(fs, 0, 0)  

        f.sizecode = fs.pc
        f.sizelineinfo = fs.pc
        f.sizek = fs.nk
        f.sizep = fs.np
        f.sizelocvars = fs.nlocvars
        f.sizeupvalues = f.nups

        assert(fs.bl == nil)
        ls.fs = fs.prev

        if fs then self:anchor_token(ls) end
    end

    function luaY:parser(L, z, buff, name)
        local lexstate = {}  
        lexstate.t = {}
        lexstate.lookahead = {}
        local funcstate = {}  
        funcstate.upvalues = {}
        funcstate.actvar = {}

        L.nCcalls = 0
        lexstate.buff = buff
        luaX:setinput(L, lexstate, z, name)
        self:open_func(lexstate, funcstate)
        funcstate.f.is_vararg = self.VARARG_ISVARARG  
        luaX:next(lexstate)  
        self:chunk(lexstate)
        self:check(lexstate, "TK_EOS")
        self:close_func(lexstate)
        assert(funcstate.prev == nil)
        assert(funcstate.f.nups == 0)
        assert(lexstate.fs == nil)
        return funcstate.f
    end

    function luaY:field(ls, v)

        local fs = ls.fs
        local key = {}  
        luaK:exp2anyreg(fs, v)
        luaX:next(ls)  
        self:checkname(ls, key)
        luaK:indexed(fs, v, key)
    end

    function luaY:yindex(ls, v)

        luaX:next(ls)  
        self:expr(ls, v)
        luaK:exp2val(ls.fs, v)
        self:checknext(ls, "]")
    end

    function luaY:recfield(ls, cc)

        local fs = ls.fs
        local reg = ls.fs.freereg
        local key, val = {}, {}  
        if ls.t.token == "TK_NAME" then
            self:checklimit(fs, cc.nh, self.MAX_INT, "items in a constructor")
            self:checkname(ls, key)
        else  
            self:yindex(ls, key)
        end
        cc.nh = cc.nh + 1
        self:checknext(ls, "=")
        local rkkey = luaK:exp2RK(fs, key)
        self:expr(ls, val)
        luaK:codeABC(fs, "OP_SETTABLE", cc.t.info, rkkey, luaK:exp2RK(fs, val))
        fs.freereg = reg  
    end

    function luaY:closelistfield(fs, cc)
        if cc.v.k == "VVOID" then return end  
        luaK:exp2nextreg(fs, cc.v)
        cc.v.k = "VVOID"
        if cc.tostore == luaP.LFIELDS_PER_FLUSH then
            luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)  
            cc.tostore = 0  
        end
    end

    function luaY:lastlistfield(fs, cc)
        if cc.tostore == 0 then return end
        if self:hasmultret(cc.v.k) then
            luaK:setmultret(fs, cc.v)
            luaK:setlist(fs, cc.t.info, cc.na, self.LUA_MULTRET)
            cc.na = cc.na - 1  
        else
            if cc.v.k ~= "VVOID" then
                luaK:exp2nextreg(fs, cc.v)
            end
            luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
        end
    end

    function luaY:listfield(ls, cc)
        self:expr(ls, cc.v)
        self:checklimit(ls.fs, cc.na, self.MAX_INT, "items in a constructor")
        cc.na = cc.na + 1
        cc.tostore = cc.tostore + 1
    end

    function luaY:constructor(ls, t)

        local fs = ls.fs
        local line = ls.linenumber
        local pc = luaK:codeABC(fs, "OP_NEWTABLE", 0, 0, 0)
        local cc = {}  
        cc.v = {}
        cc.na, cc.nh, cc.tostore = 0, 0, 0
        cc.t = t
        self:init_exp(t, "VRELOCABLE", pc)
        self:init_exp(cc.v, "VVOID", 0)  
        luaK:exp2nextreg(ls.fs, t)  
        self:checknext(ls, "{")
        repeat
            assert(cc.v.k == "VVOID" or cc.tostore > 0)
            if ls.t.token == "}" then break end
            self:closelistfield(fs, cc)
            local c = ls.t.token

            if c == "TK_NAME" then  
                luaX:lookahead(ls)
                if ls.lookahead.token ~= "=" then  
                    self:listfield(ls, cc)
                else
                    self:recfield(ls, cc)
                end
            elseif c == "[" then  
                self:recfield(ls, cc)
            else  
                self:listfield(ls, cc)
            end
        until not self:testnext(ls, ",") and not self:testnext(ls, ";")
        self:check_match(ls, "}", "{", line)
        self:lastlistfield(fs, cc)
        luaP:SETARG_B(fs.f.code[pc], self:int2fb(cc.na)) 
        luaP:SETARG_C(fs.f.code[pc], self:int2fb(cc.nh)) 
    end

    function luaY:parlist(ls)

        local fs = ls.fs
        local f = fs.f
        local nparams = 0
        f.is_vararg = 0
        if ls.t.token ~= ")" then  
            repeat
                local c = ls.t.token
                if c == "TK_NAME" then  
                    self:new_localvar(ls, self:str_checkname(ls), nparams)
                    nparams = nparams + 1
                elseif c == "TK_DOTS" then  
                    luaX:next(ls)

                    self:new_localvarliteral(ls, "arg", nparams)
                    nparams = nparams + 1
                    f.is_vararg = self.VARARG_HASARG + self.VARARG_NEEDSARG

                    f.is_vararg = f.is_vararg + self.VARARG_ISVARARG
                else
                    luaX:syntaxerror(ls, "<name> or "..self:LUA_QL("...").." expected")
                end
            until f.is_vararg ~= 0 or not self:testnext(ls, ",")
        end
        self:adjustlocalvars(ls, nparams)

        f.numparams = fs.nactvar - (f.is_vararg % self.HASARG_MASK)
        luaK:reserveregs(fs, fs.nactvar)  
    end

    function luaY:body(ls, e, needself, line)

        local new_fs = {}  
        new_fs.upvalues = {}
        new_fs.actvar = {}
        self:open_func(ls, new_fs)
        new_fs.f.lineDefined = line
        self:checknext(ls, "(")
        if needself then
            self:new_localvarliteral(ls, "self", 0)
            self:adjustlocalvars(ls, 1)
        end
        self:parlist(ls)
        self:checknext(ls, ")")
        self:chunk(ls)
        new_fs.f.lastlinedefined = ls.linenumber
        self:check_match(ls, "TK_END", "TK_FUNCTION", line)
        self:close_func(ls)
        self:pushclosure(ls, new_fs, e)
    end

    function luaY:explist1(ls, v)

        local n = 1  
        self:expr(ls, v)
        while self:testnext(ls, ",") do
            luaK:exp2nextreg(ls.fs, v)
            self:expr(ls, v)
            n = n + 1
        end
        return n
    end

    function luaY:funcargs(ls, f)
        local fs = ls.fs
        local args = {}  
        local nparams
        local line = ls.linenumber
        local c = ls.t.token
        if c == "(" then  
            if line ~= ls.lastline then
                luaX:syntaxerror(ls, "ambiguous syntax (function call x new statement)")
            end
            luaX:next(ls)
            if ls.t.token == ")" then  
                args.k = "VVOID"
            else
                self:explist1(ls, args)
                luaK:setmultret(fs, args)
            end
            self:check_match(ls, ")", "(", line)
        elseif c == "{" then  
            self:constructor(ls, args)
        elseif c == "TK_STRING" then  
            self:codestring(ls, args, ls.t.seminfo)
            luaX:next(ls)  
        else
            luaX:syntaxerror(ls, "function arguments expected")
            return
        end
        assert(f.k == "VNONRELOC")
        local base = f.info  
        if self:hasmultret(args.k) then
            nparams = self.LUA_MULTRET  
        else
            if args.k ~= "VVOID" then
                luaK:exp2nextreg(fs, args)  
            end
            nparams = fs.freereg - (base + 1)
        end
        self:init_exp(f, "VCALL", luaK:codeABC(fs, "OP_CALL", base, nparams + 1, 2))
        luaK:fixline(fs, line)
        fs.freereg = base + 1  

    end

    function luaY:prefixexp(ls, v)

        local c = ls.t.token
        if c == "(" then
            local line = ls.linenumber
            luaX:next(ls)
            self:expr(ls, v)
            self:check_match(ls, ")", "(", line)
            luaK:dischargevars(ls.fs, v)
        elseif c == "TK_NAME" then
            self:singlevar(ls, v)
        else
            luaX:syntaxerror(ls, "unexpected symbol")
        end
        return
    end

    function luaY:primaryexp(ls, v)

        local fs = ls.fs
        self:prefixexp(ls, v)
        while true do
            local c = ls.t.token
            if c == "." then  
                self:field(ls, v)
            elseif c == "[" then  
                local key = {}  
                luaK:exp2anyreg(fs, v)
                self:yindex(ls, key)
                luaK:indexed(fs, v, key)
            elseif c == ":" then  
                local key = {}  
                luaX:next(ls)
                self:checkname(ls, key)
                luaK:_self(fs, v, key)
                self:funcargs(ls, v)
            elseif c == "(" or c == "TK_STRING" or c == "{" then  
                luaK:exp2nextreg(fs, v)
                self:funcargs(ls, v)
            else
                return
            end
        end
    end

    function luaY:simpleexp(ls, v)
        local c = ls.t.token
        if c == "TK_NUMBER" then
            self:init_exp(v, "VKNUM", 0)
            v.nval = ls.t.seminfo
        elseif c == "TK_STRING" then
            self:codestring(ls, v, ls.t.seminfo)
        elseif c == "TK_NIL" then
            self:init_exp(v, "VNIL", 0)
        elseif c == "TK_TRUE" then
            self:init_exp(v, "VTRUE", 0)
        elseif c == "TK_FALSE" then
            self:init_exp(v, "VFALSE", 0)
        elseif c == "TK_DOTS" then  
            local fs = ls.fs
            self:check_condition(ls, fs.f.is_vararg ~= 0,
                "cannot use "..self:LUA_QL("...").." outside a vararg function");

            local is_vararg = fs.f.is_vararg
            if is_vararg >= self.VARARG_NEEDSARG then
                fs.f.is_vararg = is_vararg - self.VARARG_NEEDSARG  
            end
            self:init_exp(v, "VVARARG", luaK:codeABC(fs, "OP_VARARG", 0, 1, 0))
        elseif c == "{" then  
            self:constructor(ls, v)
            return
        elseif c == "TK_FUNCTION" then
            luaX:next(ls)
            self:body(ls, v, false, ls.linenumber)
            return
        else
            self:primaryexp(ls, v)
            return
        end
        luaX:next(ls)
    end

    function luaY:getunopr(op)
        if op == "TK_NOT" then
            return "OPR_NOT"
        elseif op == "-" then
            return "OPR_MINUS"
        elseif op == "#" then
            return "OPR_LEN"
        else
            return "OPR_NOUNOPR"
        end
    end

    luaY.getbinopr_table = {
        ["+"] = "OPR_ADD",
        ["-"] = "OPR_SUB",
        ["*"] = "OPR_MUL",
        ["/"] = "OPR_DIV",
        ["%"] = "OPR_MOD",
        ["^"] = "OPR_POW",
        ["TK_CONCAT"] = "OPR_CONCAT",
        ["TK_NE"] = "OPR_NE",
        ["TK_EQ"] = "OPR_EQ",
        ["<"] = "OPR_LT",
        ["TK_LE"] = "OPR_LE",
        [">"] = "OPR_GT",
        ["TK_GE"] = "OPR_GE",
        ["TK_AND"] = "OPR_AND",
        ["TK_OR"] = "OPR_OR",
    }
    function luaY:getbinopr(op)
        local opr = self.getbinopr_table[op]
        if opr then return opr else return "OPR_NOBINOPR" end
    end

    luaY.priority = {
        {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7}, 
        {10, 9}, {5, 4},                 
        {3, 3}, {3, 3},                  
        {3, 3}, {3, 3}, {3, 3}, {3, 3},  
        {2, 2}, {1, 1}                   
    }

    luaY.UNARY_PRIORITY = 8  

    function luaY:subexpr(ls, v, limit)
        self:enterlevel(ls)
        local uop = self:getunopr(ls.t.token)
        if uop ~= "OPR_NOUNOPR" then
            luaX:next(ls)
            self:subexpr(ls, v, self.UNARY_PRIORITY)
            luaK:prefix(ls.fs, uop, v)
        else
            self:simpleexp(ls, v)
        end

        local op = self:getbinopr(ls.t.token)
        while op ~= "OPR_NOBINOPR" and self.priority[luaK.BinOpr[op] + 1][1] > limit do
            local v2 = {}  
            luaX:next(ls)
            luaK:infix(ls.fs, op, v)

            local nextop = self:subexpr(ls, v2, self.priority[luaK.BinOpr[op] + 1][2])
            luaK:posfix(ls.fs, op, v, v2)
            op = nextop
        end
        self:leavelevel(ls)
        return op  
    end

    function luaY:expr(ls, v)
        self:subexpr(ls, v, 0)
    end

    function luaY:block_follow(token)
        if token == "TK_ELSE" or token == "TK_ELSEIF" or token == "TK_END"
            or token == "TK_UNTIL" or token == "TK_EOS" then
            return true
        else
            return false
        end
    end

    function luaY:block(ls)

        local fs = ls.fs
        local bl = {}  
        self:enterblock(fs, bl, false)
        self:chunk(ls)
        assert(bl.breaklist == luaK.NO_JUMP)
        self:leaveblock(fs)
    end

    function luaY:check_conflict(ls, lh, v)
        local fs = ls.fs
        local extra = fs.freereg  
        local conflict = false
        while lh do
            if lh.v.k == "VINDEXED" then
                if lh.v.info == v.info then  
                    conflict = true
                    lh.v.info = extra  
                end
                if lh.v.aux == v.info then  
                    conflict = true
                    lh.v.aux = extra  
                end
            end
            lh = lh.prev
        end
        if conflict then
            luaK:codeABC(fs, "OP_MOVE", fs.freereg, v.info, 0)  
            luaK:reserveregs(fs, 1)
        end
    end

    function luaY:assignment(ls, lh, nvars)
        local e = {}  

        local c = lh.v.k
        self:check_condition(ls, c == "VLOCAL" or c == "VUPVAL" or c == "VGLOBAL"
            or c == "VINDEXED", "syntax error")
        if self:testnext(ls, ",") then  
            local nv = {}  
            nv.v = {}
            nv.prev = lh
            self:primaryexp(ls, nv.v)
            if nv.v.k == "VLOCAL" then
                self:check_conflict(ls, lh, nv.v)
            end
            self:checklimit(ls.fs, nvars, self.LUAI_MAXCCALLS - ls.L.nCcalls,
                "variables in assignment")
            self:assignment(ls, nv, nvars + 1)
        else  
            self:checknext(ls, "=")
            local nexps = self:explist1(ls, e)
            if nexps ~= nvars then
                self:adjust_assign(ls, nvars, nexps, e)
                if nexps > nvars then
                    ls.fs.freereg = ls.fs.freereg - (nexps - nvars)  
                end
            else
                luaK:setoneret(ls.fs, e)  
                luaK:storevar(ls.fs, lh.v, e)
                return  
            end
        end
        self:init_exp(e, "VNONRELOC", ls.fs.freereg - 1)  
        luaK:storevar(ls.fs, lh.v, e)
    end

    function luaY:cond(ls)

        local v = {}  
        self:expr(ls, v)  
        if v.k == "VNIL" then v.k = "VFALSE" end  
        luaK:goiftrue(ls.fs, v)
        return v.f
    end

    function luaY:breakstat(ls)

        local fs = ls.fs
        local bl = fs.bl
        local upval = false
        while bl and not bl.isbreakable do
            if bl.upval then upval = true end
            bl = bl.previous
        end
        if not bl then
            luaX:syntaxerror(ls, "no loop to break")
        end
        if upval then
            luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
        end
        bl.breaklist = luaK:concat(fs, bl.breaklist, luaK:jump(fs))
    end

    function luaY:whilestat(ls, line)

        local fs = ls.fs
        local bl = {}  
        luaX:next(ls)  
        local whileinit = luaK:getlabel(fs)
        local condexit = self:cond(ls)
        self:enterblock(fs, bl, true)
        self:checknext(ls, "TK_DO")
        self:block(ls)
        luaK:patchlist(fs, luaK:jump(fs), whileinit)
        self:check_match(ls, "TK_END", "TK_WHILE", line)
        self:leaveblock(fs)
        luaK:patchtohere(fs, condexit)  
    end

    function luaY:repeatstat(ls, line)

        local fs = ls.fs
        local repeat_init = luaK:getlabel(fs)
        local bl1, bl2 = {}, {}  
        self:enterblock(fs, bl1, true)  
        self:enterblock(fs, bl2, false)  
        luaX:next(ls)  
        self:chunk(ls)
        self:check_match(ls, "TK_UNTIL", "TK_REPEAT", line)
        local condexit = self:cond(ls)  
        if not bl2.upval then  
            self:leaveblock(fs)  
            luaK:patchlist(ls.fs, condexit, repeat_init)  
        else  
            self:breakstat(ls)  
            luaK:patchtohere(ls.fs, condexit)  
            self:leaveblock(fs)  
            luaK:patchlist(ls.fs, luaK:jump(fs), repeat_init)  
        end
        self:leaveblock(fs)  
    end

    function luaY:exp1(ls)
        local e = {}  
        self:expr(ls, e)
        local k = e.k
        luaK:exp2nextreg(ls.fs, e)
        return k
    end

    function luaY:forbody(ls, base, line, nvars, isnum)

        local bl = {}  
        local fs = ls.fs
        self:adjustlocalvars(ls, 3)  
        self:checknext(ls, "TK_DO")
        local prep = isnum and luaK:codeAsBx(fs, "OP_FORPREP", base, luaK.NO_JUMP)
            or luaK:jump(fs)
        self:enterblock(fs, bl, false)  
        self:adjustlocalvars(ls, nvars)
        luaK:reserveregs(fs, nvars)
        self:block(ls)
        self:leaveblock(fs)  
        luaK:patchtohere(fs, prep)
        local endfor = isnum and luaK:codeAsBx(fs, "OP_FORLOOP", base, luaK.NO_JUMP)
            or luaK:codeABC(fs, "OP_TFORLOOP", base, 0, nvars)
        luaK:fixline(fs, line)  
        luaK:patchlist(fs, isnum and endfor or luaK:jump(fs), prep + 1)
    end

    function luaY:fornum(ls, varname, line)

        local fs = ls.fs
        local base = fs.freereg
        self:new_localvarliteral(ls, "(for index)", 0)
        self:new_localvarliteral(ls, "(for limit)", 1)
        self:new_localvarliteral(ls, "(for step)", 2)
        self:new_localvar(ls, varname, 3)
        self:checknext(ls, '=')
        self:exp1(ls)  
        self:checknext(ls, ",")
        self:exp1(ls)  
        if self:testnext(ls, ",") then
            self:exp1(ls)  
        else  
            luaK:codeABx(fs, "OP_LOADK", fs.freereg, luaK:numberK(fs, 1))
            luaK:reserveregs(fs, 1)
        end
        self:forbody(ls, base, line, 1, true)
    end

    function luaY:forlist(ls, indexname)

        local fs = ls.fs
        local e = {}  
        local nvars = 0
        local base = fs.freereg

        self:new_localvarliteral(ls, "(for generator)", nvars)
        nvars = nvars + 1
        self:new_localvarliteral(ls, "(for state)", nvars)
        nvars = nvars + 1
        self:new_localvarliteral(ls, "(for control)", nvars)
        nvars = nvars + 1

        self:new_localvar(ls, indexname, nvars)
        nvars = nvars + 1
        while self:testnext(ls, ",") do
            self:new_localvar(ls, self:str_checkname(ls), nvars)
            nvars = nvars + 1
        end
        self:checknext(ls, "TK_IN")
        local line = ls.linenumber
        self:adjust_assign(ls, 3, self:explist1(ls, e), e)
        luaK:checkstack(fs, 3)  
        self:forbody(ls, base, line, nvars - 3, false)
    end

    function luaY:forstat(ls, line)

        local fs = ls.fs
        local bl = {}  
        self:enterblock(fs, bl, true)  
        luaX:next(ls)  
        local varname = self:str_checkname(ls)  
        local c = ls.t.token
        if c == "=" then
            self:fornum(ls, varname, line)
        elseif c == "," or c == "TK_IN" then
            self:forlist(ls, varname)
        else
            luaX:syntaxerror(ls, self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")
        end
        self:check_match(ls, "TK_END", "TK_FOR", line)
        self:leaveblock(fs)  
    end

    function luaY:test_then_block(ls)

        luaX:next(ls)  
        local condexit = self:cond(ls)
        self:checknext(ls, "TK_THEN")
        self:block(ls)  
        return condexit
    end

    function luaY:ifstat(ls, line)

        local fs = ls.fs
        local escapelist = luaK.NO_JUMP
        local flist = self:test_then_block(ls)  
        while ls.t.token == "TK_ELSEIF" do
            escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
            luaK:patchtohere(fs, flist)
            flist = self:test_then_block(ls)  
        end
        if ls.t.token == "TK_ELSE" then
            escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
            luaK:patchtohere(fs, flist)
            luaX:next(ls)  
            self:block(ls)  
        else
            escapelist = luaK:concat(fs, escapelist, flist)
        end
        luaK:patchtohere(fs, escapelist)
        self:check_match(ls, "TK_END", "TK_IF", line)
    end

    function luaY:localfunc(ls)
        local v, b = {}, {}  
        local fs = ls.fs
        self:new_localvar(ls, self:str_checkname(ls), 0)
        self:init_exp(v, "VLOCAL", fs.freereg)
        luaK:reserveregs(fs, 1)
        self:adjustlocalvars(ls, 1)
        self:body(ls, b, false, ls.linenumber)
        luaK:storevar(fs, v, b)

        self:getlocvar(fs, fs.nactvar - 1).startpc = fs.pc
    end

    function luaY:localstat(ls)

        local nvars = 0
        local nexps
        local e = {}  
        repeat
            self:new_localvar(ls, self:str_checkname(ls), nvars)
            nvars = nvars + 1
        until not self:testnext(ls, ",")
        if self:testnext(ls, "=") then
            nexps = self:explist1(ls, e)
        else
            e.k = "VVOID"
            nexps = 0
        end
        self:adjust_assign(ls, nvars, nexps, e)
        self:adjustlocalvars(ls, nvars)
    end

    function luaY:funcname(ls, v)

        local needself = false
        self:singlevar(ls, v)
        while ls.t.token == "." do
            self:field(ls, v)
        end
        if ls.t.token == ":" then
            needself = true
            self:field(ls, v)
        end
        return needself
    end

    function luaY:funcstat(ls, line)

        local v, b = {}, {}  
        luaX:next(ls)  
        local needself = self:funcname(ls, v)
        self:body(ls, b, needself, line)
        luaK:storevar(ls.fs, v, b)
        luaK:fixline(ls.fs, line)  
    end

    function luaY:exprstat(ls)

        local fs = ls.fs
        local v = {}  
        v.v = {}
        self:primaryexp(ls, v.v)
        if v.v.k == "VCALL" then  
            luaP:SETARG_C(luaK:getcode(fs, v.v), 1)  
        else  
            v.prev = nil
            self:assignment(ls, v, 1)
        end
    end

    function luaY:retstat(ls)

        local fs = ls.fs
        local e = {}  
        local first, nret  
        luaX:next(ls)  
        if self:block_follow(ls.t.token) or ls.t.token == ";" then
            first, nret = 0, 0  
        else
            nret = self:explist1(ls, e)  
            if self:hasmultret(e.k) then
                luaK:setmultret(fs, e)
                if e.k == "VCALL" and nret == 1 then  
                    luaP:SET_OPCODE(luaK:getcode(fs, e), "OP_TAILCALL")
                    assert(luaP:GETARG_A(luaK:getcode(fs, e)) == fs.nactvar)
                end
                first = fs.nactvar
                nret = self.LUA_MULTRET  
            else
                if nret == 1 then  
                    first = luaK:exp2anyreg(fs, e)
                else
                    luaK:exp2nextreg(fs, e)  
                    first = fs.nactvar  
                    assert(nret == fs.freereg - first)
                end
            end
        end
        luaK:ret(fs, first, nret)
    end

    function luaY:statement(ls)
        local line = ls.linenumber  
        local c = ls.t.token
        if c == "TK_IF" then  
            self:ifstat(ls, line)
            return false
        elseif c == "TK_WHILE" then  
            self:whilestat(ls, line)
            return false
        elseif c == "TK_DO" then  
            luaX:next(ls)  
            self:block(ls)
            self:check_match(ls, "TK_END", "TK_DO", line)
            return false
        elseif c == "TK_FOR" then  
            self:forstat(ls, line)
            return false
        elseif c == "TK_REPEAT" then  
            self:repeatstat(ls, line)
            return false
        elseif c == "TK_FUNCTION" then  
            self:funcstat(ls, line)
            return false
        elseif c == "TK_LOCAL" then  
            luaX:next(ls)  
            if self:testnext(ls, "TK_FUNCTION") then  
                self:localfunc(ls)
            else
                self:localstat(ls)
            end
            return false
        elseif c == "TK_RETURN" then  
            self:retstat(ls)
            return true  
        elseif c == "TK_BREAK" then  
            luaX:next(ls)  
            self:breakstat(ls)
            return true  
        else
            self:exprstat(ls)
            return false  
        end
    end

    function luaY:chunk(ls)
        local islast = false
        self:enterlevel(ls)
        while not islast and not self:block_follow(ls.t.token) do
            islast = self:statement(ls)
            self:testnext(ls, ";")
            assert(ls.fs.f.maxstacksize >= ls.fs.freereg and
                ls.fs.freereg >= ls.fs.nactvar)
            ls.fs.freereg = ls.fs.nactvar  
        end
        self:leavelevel(ls)
    end

    local rerubi = function(BCode, Env)
        local Buffer = GetMeaning(BCode);
        return Wrap(Buffer, Env or getfenv(0)), Buffer;
    end
    Loadstring = function(str, env)
        luaX:init()
        local LuaState = {}

        local f,writer,buff,name
        local env = env or getfenv(2)
        local name = (env.script and GetFullName(env.script))
        local ran,error = pcall(function()
            local zio = luaZ:init(luaZ:make_getS(str), nil)
            if not zio then return error() end
            local func = luaY:parser(LuaState, zio, nil, name or "::Adonis::Loadstring::")
            writer, buff = luaU:make_setS()
            luaU:dump(LuaState, func, writer, buff)
            f = rerubi(buff.data, env)
        end)

        if ran then
            return f,buff.data
        else
            return nil,error
        end
    end
end

TidalWaveScreenGui = Instance.new("ScreenGui")
TidalWaveScreenGui.Name = "Tidal Wave v" .. CurrentVersion
TidalWaveScreenGui.IgnoreGuiInset = true
TidalWaveScreenGui.DisplayOrder = 69420

do
    if syn and syn.protect_gui then
        syn.protect_gui(TidalWaveScreenGui)
    end
	local Parent = nil
	if RunService:IsStudio() then
		Parent = Plr:FindFirstChildWhichIsA("PlayerGui")
	else
		Parent = GetHui()
	end
	TidalWaveScreenGui.Parent = Parent
end

FramesFolder = Instance.new("Folder")
FramesFolder.Name = "Frames"
FramesFolder.Parent = TidalWaveScreenGui

CategoryHolderFrame = Instance.new("Frame")
CategoryHolderFrame.Name = "Categories"
CategoryHolderFrame.BackgroundTransparency = 1
CategoryHolderFrame.Position = UDim2.fromOffset(0, 60)
CategoryHolderFrame.Size = UDim2.fromScale(1, 1)
CategoryHolderFrame.Parent = TidalWaveScreenGui

TidalWaveUIScale = Instance.new("UIScale")
TidalWaveUIScale.Scale = 1
TidalWaveUIScale.Parent = CategoryHolderFrame

SoundsFolder = Instance.new("Folder")
SoundsFolder.Name = "Sounds"
SoundsFolder.Parent = TidalWaveScreenGui

EspFolder = Instance.new("Folder")
EspFolder.Name = "Esp"
EspFolder.Parent = TidalWaveScreenGui

DrawingFolder = Instance.new("Folder")
DrawingFolder.Name = "Drawing"
DrawingFolder.Parent = TidalWaveScreenGui

StorageFolder = Instance.new("Folder")
StorageFolder.Name = "Storage"
StorageFolder.Parent = TidalWaveScreenGui

HoverInfoFrame = Instance.new("Frame")
HoverInfoFrame.Name = "HoverInfoFrame"
HoverInfoFrame.Size = UDim2.fromScale(0.25, 0.04)
HoverInfoFrame.ZIndex = 69
HoverInfoFrame.BorderSizePixel = 0
HoverInfoFrame.Visible = false
HoverInfoFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
HoverInfoFrame.BackgroundTransparency = 0.08
HoverInfoFrame.Interactable = false
HoverInfoFrame.Parent = FramesFolder

HoverInfoFrameUICorner = Instance.new("UICorner")
HoverInfoFrameUICorner.CornerRadius = UDim.new(0.25, 0)
HoverInfoFrameUICorner.Parent = HoverInfoFrame

HoverInfo = Instance.new("TextLabel")
HoverInfo.TextColor3 = Color3.fromRGB(255, 255, 255)
HoverInfo.BorderSizePixel = 0
HoverInfo.Size = UDim2.fromScale(1, 0.75)
HoverInfo.Position = UDim2.fromScale(0, 0.125)
HoverInfo.Text = ""
HoverInfo.Font = TextFont
HoverInfo.Name = "HoverInfo"
HoverInfo.AutomaticSize = Enum.AutomaticSize.XY
HoverInfo.ZIndex = HoverInfoFrame.ZIndex
HoverInfo.BackgroundTransparency = 1
HoverInfo.TextScaled = true
HoverInfo.Interactable = false
HoverInfo.Parent = HoverInfoFrame

HoverInfoTextSizeConstraint = Instance.new("UITextSizeConstraint")
HoverInfoTextSizeConstraint.MinTextSize = 8
HoverInfoTextSizeConstraint.MaxTextSize = HoverInfo.AbsoluteSize.Y / 2
HoverInfoTextSizeConstraint.Parent = HoverInfo

HackListFrame = Instance.new("Frame")
HackListFrame.Name = "HackListFrame"
HackListFrame.Position = UDim2.fromScale(0.875, 0.05)
HackListFrame.Size = UDim2.fromScale(0.1, 0.9)
HackListFrame.BorderSizePixel = 0
HackListFrame.BackgroundTransparency = 1
HackListFrame.ClipsDescendants = true
HackListFrame.Parent = FramesFolder

HackListTitleFrame = Instance.new("Frame")
HackListTitleFrame.Size = UDim2.fromScale(1, 0.05)
HackListTitleFrame.Name = "HackListTitleFrame"
HackListTitleFrame.BackgroundTransparency = 1
HackListTitleFrame.LayoutOrder = -69420
HackListTitleFrame.Parent = HackListFrame

HackListTitle = Instance.new("TextLabel")
HackListTitle.Name = "HackListTitle"
HackListTitle.BackgroundTransparency = 1
HackListTitle.Size = UDim2.fromScale(1, 0.5)
HackListTitle.Position = UDim2.fromScale(0, 0.25)
HackListTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
HackListTitle.Font = Enum.Font:FromName(BoldFont) or TextFont
HackListTitle.RichText = true
HackListTitle.Text = "<font color = 'rgb(255, 215, 0)'>Tidal</font> <font color = 'rgb(20, 135, 255)'>Wave</font> v" .. CurrentVersion
HackListTitle.TextScaled = true
HackListTitle.Parent = HackListTitleFrame

NotificationFrame = Instance.new("Frame")
NotificationFrame.Name = "Notifications"
NotificationFrame.Position = UDim2.fromScale(0.85, 0)
NotificationFrame.Size = UDim2.fromScale(0.15, 1)
NotificationFrame.BorderSizePixel = 0
NotificationFrame.BackgroundTransparency = 1
NotificationFrame.Parent = FramesFolder

function CreateMenu(Properties)
    local TopBar = Instance.new("TextButton")
    TopBar.BackgroundColor3 = Color3.fromRGB(20, 135, 255)
    TopBar.Size = UDim2.fromScale(0.4, 0.05)
    TopBar.Position = UDim2.fromScale(0.3, 0.2)
    TopBar.Name = Properties.Text .. "TopBar"
    TopBar.Text = Properties.Text or "nil"
    TopBar.TextColor3 = Color3.fromRGB(255, 255, 255)
    TopBar.Visible = Properties.Visible or false
    TopBar.BorderSizePixel = 0
    TopBar.ZIndex = Properties.ZIndex or 3
    TopBar.Font = Enum.Font:FromName(BoldFont) or Enum.Font:FromName(TextFont)
    TopBar.TextScaled = true
    TopBar.TextStrokeTransparency = 0
    TopBar.AutoButtonColor = false
    TopBar.Modal = true
    TopBar.Parent = Properties.Parent or FramesFolder

    local TopBarUICorner = Instance.new("UICorner")
    TopBarUICorner.CornerRadius = UDim.new(0.4, 0)
    TopBarUICorner.Parent = TopBar

    local TopBarFiller = Instance.new("Frame")
    TopBarFiller.BorderSizePixel = 0
    TopBarFiller.BackgroundColor3 = TopBar.BackgroundColor3
    TopBarFiller.Size = UDim2.fromScale(1, 0.5)
    TopBarFiller.Position = UDim2.fromScale(0, 0.5)
    TopBarFiller.Name = "Filler"
    TopBarFiller.ZIndex = TopBar.ZIndex - 1
    TopBarFiller.Parent = TopBar

    local ContentFrame = Instance.new("Frame")
    ContentFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    ContentFrame.BorderSizePixel = 0
    ContentFrame.Size = UDim2.fromScale(1, 13)
    ContentFrame.Position = UDim2.fromScale(0, 0)
    ContentFrame.Name = "ContentFrame"
    ContentFrame.ZIndex = TopBar.ZIndex - 2
    ContentFrame.Parent = TopBar

    local ContentFrameUICorner = Instance.new("UICorner")
    ContentFrameUICorner.CornerRadius = UDim.new(0.05, 0)
    ContentFrameUICorner.Parent = ContentFrame

    local ContentScrollingFrame = Instance.new("ScrollingFrame")
    ContentScrollingFrame.Size = UDim2.fromScale(1, 0.88)
    ContentScrollingFrame.Position = UDim2.fromScale(0, 0.08)
    ContentScrollingFrame.CanvasSize = UDim2.fromScale(1, 2)
    ContentScrollingFrame.BackgroundTransparency = 1
    ContentScrollingFrame.BorderSizePixel = 0
    ContentScrollingFrame.ScrollBarThickness = 6
    ContentScrollingFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
    ContentScrollingFrame.ScrollingDirection = Enum.ScrollingDirection.Y
    ContentScrollingFrame.ZIndex = ContentFrame.ZIndex
    ContentScrollingFrame.Parent = ContentFrame

    local ContentScrollingFrameUIListLayout = Instance.new("UIListLayout")
    ContentScrollingFrameUIListLayout.FillDirection = Enum.FillDirection.Horizontal
    ContentScrollingFrameUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    ContentScrollingFrameUIListLayout.Wraps = true
    ContentScrollingFrameUIListLayout.Padding = UDim.new(0, 3)
    ContentScrollingFrameUIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    ContentScrollingFrameUIListLayout.Parent = ContentScrollingFrame

    local CloseMenu = Instance.new("TextButton")
    CloseMenu.BackgroundTransparency = 1
    CloseMenu.Size = UDim2.fromScale(0.05, 1)
    CloseMenu.Position = UDim2.fromScale(0.95, 0)
    CloseMenu.Text = "X"
    CloseMenu.Font = Enum.Font.FredokaOne
    CloseMenu.TextColor3 = Color3.fromRGB(255, 255, 255)
    CloseMenu.ZIndex = TopBar.ZIndex
    CloseMenu.TextScaled = true
    CloseMenu.Name = "Close"
    CloseMenu.Parent = TopBar
    CloseMenu.MouseButton1Click:Connect(function()
        TopBar.Visible = false
        if Properties.OnClose then
            Properties.OnClose()
        elseif Properties.Closed then
            Properties.Closed()
        end
    end)

    local CloseMenuInfoUIStroke = Instance.new("UIStroke")
    CloseMenuInfoUIStroke.Parent = CloseMenu

    local Refs = {
        TopBar = TopBar,
        MainFrame = TopBar,
        TopBarUICorner = TopBarUICorner,
        UICorner = TopBarUICorner,
        TopBarFiller = TopBarFiller,
        Filler = TopBarFiller,
        ContentFrame = ContentFrame,
        Frame = ContentFrame,
        ContentScrollingFrame = ContentScrollingFrame,
        ScrollingFrame = ContentScrollingFrame,
        ContentScrollingFrameUIListLayout = ContentScrollingFrameUIListLayout,
        UIListLayout = ContentScrollingFrameUIListLayout,
        CloseMenu = CloseMenu,
        Exit = CloseMenu,
    }

    return Refs
end

------------------------------------------------------------------------------------------- Menus

ServerInfoMenu = CreateMenu({
    Text = "Server Info/Client Info",
    OnClose = function()
        ToggleButtonColor(ToggleServerInfo, false)
    end,
})

ProfileMenu = CreateMenu({
    Text = "Profiles",
})

SettingsMenu = CreateMenu({
    Text = "Settings",
})

------------------------------------------------------------------------------------------- Functions

function ShowHoverInfo(Text)
    if Text == nil then return end
    Text = tostring(Text)
    local MouseLocation = UIS:GetMouseLocation()
    HoverInfo.Text = Text
    local X = math.clamp(MouseLocation.X + 8, 0, Camera.ViewportSize.X - HoverInfoFrame.AbsoluteSize.X)
    local Y = math.clamp(MouseLocation.Y - HoverInfoFrame.AbsoluteSize.Y, 0, Camera.ViewportSize.Y - HoverInfoFrame.AbsoluteSize.Y)
	HoverInfoFrame.Position = UDim2.fromOffset(X, Y)
	HoverInfoFrame.Visible = true
	if Connections.Other.HoverInfoMouseMove then
		Connections.Other.HoverInfoMouseMove:Disconnect()
		Connections.Other.HoverInfoMouseMove = nil
	end
	Connections.Other.HoverInfoMouseMove = Mouse.Move:Connect(function()
        MouseLocation = UIS:GetMouseLocation()
        X = math.clamp(MouseLocation.X + 8, 0, Camera.ViewportSize.X - HoverInfoFrame.AbsoluteSize.X)
        Y = math.clamp(MouseLocation.Y - HoverInfoFrame.AbsoluteSize.Y, 0, Camera.ViewportSize.Y - HoverInfoFrame.AbsoluteSize.Y)
		HoverInfoFrame.Position = UDim2.fromOffset(X, Y)
	end)
end

function HideHoverInfo()
	HoverInfoFrame.Visible = false
	if Connections.Other.HoverInfoMouseMove then
		Connections.Other.HoverInfoMouseMove:Disconnect()
		Connections.Other.HoverInfoMouseMove = nil
	end
end

do
    local PrevMouseIconEnabled = UIS.MouseIconEnabled
    local PrevEnabled = false

    function UpdateMouseIconEnabled(Bool)
        if Bool == PrevEnabled then return end
        PrevEnabled = Bool
        if Bool == true then
            PrevMouseIconEnabled = UIS.MouseIconEnabled
            UIS.MouseIconEnabled = true
        else
            UIS.MouseIconEnabled = PrevMouseIconEnabled
        end
    end
end

function PlayClickSound()
    local ClickSFX = Instance.new("Sound")
    ClickSFX.Volume = 0.5
    ClickSFX.SoundId = "rbxassetid://552900451"
    ClickSFX.Parent = SoundsFolder
    ClickSFX:Play()
    Debris:AddItem(ClickSFX, 0.1)
end

function CreateCategory(Properties)
	local CategoryTopBar = Instance.new("TextButton")
	CategoryTopBar.BackgroundColor3 = GuiColors.CategoryTopBar
	CategoryTopBar.Size = (Properties.Size and UDim2.fromScale(0.09 * Properties.Size.X.Scale, 0.03)) or UDim2.fromScale(0.1, 0.03)
	CategoryTopBar.Position = Properties.ClosedPos or UDim2.fromScale(0.005, 0.1)
	CategoryTopBar.Text = ""
	CategoryTopBar.Name = Properties.Name or "Category"
	CategoryTopBar.BorderSizePixel = 0
	CategoryTopBar.ZIndex = #CategoryHolderFrame:GetChildren() + 1
	CategoryTopBar.Visible = false
	CategoryTopBar.Modal = true
	CategoryTopBar.Parent = CategoryHolderFrame

	local CategoryTopBarUICorner = Instance.new("UICorner")
	CategoryTopBarUICorner.CornerRadius = UDim.new(0.3, 0)
	CategoryTopBarUICorner.Parent = CategoryTopBar

	local FillerFrame = Instance.new("Frame")
	FillerFrame.BackgroundColor3 = CategoryTopBar.BackgroundColor3
	FillerFrame.Size = UDim2.fromScale(1, 0.5)
	FillerFrame.Position = UDim2.fromScale(0, 0.5)
	FillerFrame.BorderSizePixel = 0
	FillerFrame.ZIndex = CategoryTopBar.ZIndex
	FillerFrame.Name = "FillerFrame"
	FillerFrame.Parent = CategoryTopBar

	local HideCategory = Instance.new("ImageButton")
	HideCategory.BackgroundTransparency = 1
	HideCategory.ZIndex = CategoryTopBar.ZIndex
	HideCategory.Name = "HideCategory"
	HideCategory.Size = UDim2.fromScale(0.125, 1)
	HideCategory.Position = UDim2.fromScale(0.85, 0)
	HideCategory.Image = "rbxassetid://4841250241"
	HideCategory.Rotation = 270
	HideCategory.Parent = CategoryTopBar

	local CategoryName = Instance.new("TextLabel")
	CategoryName.BackgroundTransparency = 1
	CategoryName.Size = UDim2.fromScale(0.95, 0.8)
	CategoryName.Position = UDim2.fromScale(0.025, 0.1)
	CategoryName.TextColor3 = Color3.fromRGB(255, 255, 255)
	CategoryName.Text = Properties.Name or "nil"
	CategoryName.Name = "CategoryName"
	CategoryName.ZIndex = CategoryTopBar.ZIndex
	CategoryName.TextScaled = true
	CategoryName.Font = BoldFont
	CategoryName.Parent = CategoryTopBar

	local CategoryNameUIPadding = Instance.new("UIPadding")
	CategoryNameUIPadding.PaddingLeft = UDim.new(0.1, 0)
	CategoryNameUIPadding.PaddingRight = UDim.new(0.1, 0)
	CategoryNameUIPadding.Parent = CategoryName

	local CategoryNameUIStroke = Instance.new("UIStroke")
	CategoryNameUIStroke.Parent = CategoryName

	local ContentFrame = Instance.new("Frame")
	ContentFrame.Name = "ContentFrame"
	ContentFrame.BackgroundColor3 = GuiColors.CategoryBackground
	ContentFrame.Position = UDim2.fromScale(0, 1)
	ContentFrame.Size = Properties.Size and UDim2.fromScale(1, Properties.Size.Y.Scale * 25) or UDim2.fromScale(1, 25)
	ContentFrame.BorderSizePixel = 0
	ContentFrame.ClipsDescendants = true
	ContentFrame.ZIndex = CategoryTopBar.ZIndex
	ContentFrame.Parent = CategoryTopBar

	local ContentFrameUICorner = Instance.new("UICorner")
	ContentFrameUICorner.CornerRadius = UDim.new(0.065, 0)
	ContentFrameUICorner.Parent = ContentFrame

	local FillerFrame2 = Instance.new("Frame")
	FillerFrame2.BackgroundColor3 = GuiColors.CategoryBackground
	FillerFrame2.Size = UDim2.fromScale(1, 1)
	FillerFrame2.Position = UDim2.fromScale(0, 1)
	FillerFrame2.BorderSizePixel = 0
	FillerFrame2.ZIndex = CategoryTopBar.ZIndex - 1
	FillerFrame2.Name = "FillerFrame2"
	FillerFrame2.Parent = CategoryTopBar

	local ContentScrollingFrame = Instance.new("ScrollingFrame")
	ContentScrollingFrame.Name = "ContentScrollingFrame"
	ContentScrollingFrame.BackgroundTransparency = 1
	ContentScrollingFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	ContentScrollingFrame.Size = UDim2.fromScale(1, 0.98)
	ContentScrollingFrame.Position = UDim2.new(0, 0, 0, 3)
	ContentScrollingFrame.ScrollBarThickness = 0
	ContentScrollingFrame.CanvasSize = UDim2.fromScale(1, 1)
	ContentScrollingFrame.ZIndex = CategoryTopBar.ZIndex
	ContentScrollingFrame.BorderSizePixel = 0
	ContentScrollingFrame.Parent = ContentFrame

	local ResizeButton = Instance.new("TextButton")
	ResizeButton.Size = UDim2.fromScale(0.9, 0.15)
	ResizeButton.Position = UDim2.fromScale(0.05, ContentFrame.Size.Y.Scale + 1.1 or 25)
	ResizeButton.Text = ""
	ResizeButton.BorderSizePixel = 0
	ResizeButton.AutoButtonColor = false
	ResizeButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	ResizeButton.Name = "ResizeButton"
	ResizeButton.Transparency = 0.8
	ResizeButton.Parent = CategoryTopBar
	ResizeButton.MouseEnter:Connect(function()
		TweenService:Create(ResizeButton, TweenInfo.new(0.25, Enum.EasingStyle.Quad), {Transparency = 0.4}):Play()
	end)
	ResizeButton.MouseLeave:Connect(function()
		TweenService:Create(ResizeButton, TweenInfo.new(0.25, Enum.EasingStyle.Quad), {Transparency = 0.8}):Play()
	end)

	local ResizeButtonUICorner = Instance.new("UICorner")
	ResizeButtonUICorner.CornerRadius = UDim.new(1, 0)
	ResizeButtonUICorner.Parent = ResizeButton

	local PrevSize = ContentFrame.Size

	local ResizeButtonUIDragDetector = Instance.new("UIDragDetector")
	ResizeButtonUIDragDetector.CursorIcon = "http://www.roblox.com/asset/?id=73330868899359"
	ResizeButtonUIDragDetector.ActivatedCursorIcon = "http://www.roblox.com/asset/?id=73330868899359"
	ResizeButtonUIDragDetector.DragStyle = Enum.UIDragDetectorDragStyle.TranslateLine
	ResizeButtonUIDragDetector.DragAxis = Vector2.new(0, 1)
	ResizeButtonUIDragDetector.ResponseStyle = Enum.UIDragDetectorResponseStyle.Scale
    ResizeButtonUIDragDetector.BoundingUI = CategoryHolderFrame
	ResizeButtonUIDragDetector.Parent = ResizeButton
	ResizeButtonUIDragDetector.DragContinue:Connect(function()
		ResizeButton.Position = UDim2.fromScale(ResizeButton.Position.X.Scale, math.clamp(ResizeButton.Position.Y.Scale, 3, 100))
		ContentFrame.Size = UDim2.fromScale(1, ResizeButton.Position.Y.Scale - ContentFrame.Position.Y.Scale)
		PrevSize = ContentFrame.Size
	end)

	local ContentScrollingFrameUIListLayout = Instance.new("UIListLayout")
	ContentScrollingFrameUIListLayout.Padding = UDim.new(0, 3)
	ContentScrollingFrameUIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	ContentScrollingFrameUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	ContentScrollingFrameUIListLayout.Parent = ContentScrollingFrame

	CategoryTopBar:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		ResizeButton.Position = UDim2.fromScale(ResizeButton.Position.X.Scale, math.clamp(ResizeButton.Position.Y.Scale, 3, 100))
	end)

	local DB = false
	local PrevPos = UDim2.new(Properties.Pos.X.Scale, Properties.Pos.X.Offset, Properties.Pos.Y.Scale, Properties.Pos.Y.Offset) or CategoryTopBar.Position

	local UIDragDetector = Instance.new("UIDragDetector")
	UIDragDetector.Parent = CategoryTopBar
	UIDragDetector.DragContinue:Connect(function()
		PrevPos = CategoryTopBar.Position
	end)

	HideCategory.MouseButton1Click:Connect(function()
		if DB then return end
		DB = true
		if AnimateCategories then
			if ContentFrame.Visible then
				local CloseTween = TweenService:Create(ContentFrame, TweenInfo.new(CategoryCloseSpeed, Enum.EasingStyle.Quad), {Size = UDim2.fromScale(ContentFrame.Size.X.Scale, 0)})
				local ResizeButtonTween = TweenService:Create(ResizeButton, TweenInfo.new(CategoryCloseSpeed, Enum.EasingStyle.Quad), {Position = UDim2.fromScale(0.05, 1)})
				local FillerFrame2Tween = TweenService:Create(FillerFrame2, TweenInfo.new(CategoryCloseSpeed, Enum.EasingStyle.Quad), {Position = UDim2.fromScale(0, 0.5), Size = UDim2.fromScale(1, 0.5)})
				local RotateTween = TweenService:Create(HideCategory, TweenInfo.new(CategoryCloseSpeed), {Rotation = 180})
                ResizeButtonTween:Play()
				CloseTween:Play()
                RotateTween:Play()
				FillerFrame2Tween:Play()
				CloseTween.Completed:Wait()
				ResizeButton.Visible = false
				ContentFrame.Visible = false
				FillerFrame.Visible = false
				FillerFrame2.Visible = false
				DB = false
			else
				ContentFrame.Visible = true
				ResizeButton.Visible = true
				FillerFrame.Visible = true
				FillerFrame2.Visible = true
				local OpenTween = TweenService:Create(ContentFrame, TweenInfo.new(CategoryCloseSpeed, Enum.EasingStyle.Quad), {Size = UDim2.fromScale(ContentFrame.Size.X.Scale, PrevSize.Y.Scale)})
				local ResizeButtonTween = TweenService:Create(ResizeButton, TweenInfo.new(CategoryCloseSpeed, Enum.EasingStyle.Quad), {Position = UDim2.fromScale(0.05, PrevSize.Y.Scale + 1)})
				local FillerFrame2Tween = TweenService:Create(FillerFrame2, TweenInfo.new(CategoryCloseSpeed, Enum.EasingStyle.Quad), {Position = UDim2.fromScale(0, 1), Size = UDim2.fromScale(1, 1)})
				local RotateTween = TweenService:Create(HideCategory, TweenInfo.new(CategoryCloseSpeed), {Rotation = 270})
                ResizeButtonTween:Play()
				OpenTween:Play()
				FillerFrame2Tween:Play()
                RotateTween:Play()
				OpenTween.Completed:Wait()
				DB = false
			end
		else
			if ContentFrame.Visible then
				ContentFrame.Visible = false
				ResizeButton.Visible = false
				FillerFrame.Visible = false
				FillerFrame2.Visible = false
				HideCategory.Rotation = 180
			else
				ContentFrame.Visible = true
				ResizeButton.Visible = true
				FillerFrame.Visible = true
				FillerFrame2.Visible = true
				HideCategory.Rotation = 270
			end
			DB = false
		end
	end)

	local MenuToggleDB = false
	local Buffer = false
	local Toggleable = true

	Connections.TidalWave["Toggle" .. CategoryName.Text .. "CategoryInputBeganConnection"] = UIS.InputBegan:Connect(function(Input)
		if (ChatboxFocused() or TidalWaveFocused or Rebinding or SettingsMenu.TopBar.Visible or ProfileMenu.TopBar.Visible) or not Toggleable then return end
		local MultiBinded = MenuKeybind:find("+") ~= nil
		local Keys = MultiBinded and MenuKeybind:split("+")
		local AllDown = true
		if MultiBinded then
			for i, v in ipairs(Keys) do
				if not UIS:IsKeyDown(v) then
					AllDown = false
				end
			end
		end
		if ((MultiBinded and AllDown) or (not MultiBinded and Input.KeyCode.Name == MenuKeybind)) then
			Buffer = true
			if MenuToggleDB then return end
			if AnimateWindows then
				MenuToggleDB = true
				if CategoryTopBar.Visible then
					HideHoverInfo()
                    UpdateMouseIconEnabled(false)
					Buffer = false
					local MenuCloseTween = TweenService:Create(CategoryTopBar, TweenInfo.new(MenuOpenSpeed, Enum.EasingStyle:FromName(MenuEasingStyle), Enum.EasingDirection:FromName(MenuCloseEasingDirection)), {Position = Properties.ClosedPos or UDim2.fromScale(-0.25, -1)})
					MenuCloseTween:Play()
					MenuCloseTween.Completed:Wait()
					CategoryTopBar.Visible = false
					MenuToggleDB = false
					if Buffer then
						Buffer = false
                        UpdateMouseIconEnabled(true)
						CategoryTopBar.Visible = true
						MenuToggleDB = true
						local MenuOpenTween = TweenService:Create(CategoryTopBar, TweenInfo.new(MenuOpenSpeed, Enum.EasingStyle:FromName(MenuEasingStyle), Enum.EasingDirection:FromName(MenuOpenEasingDirection)), {Position = PrevPos})
						MenuOpenTween:Play()
						MenuOpenTween.Completed:Wait()
						MenuToggleDB = false
					end
				else
					CategoryTopBar.Visible = true
                    UpdateMouseIconEnabled(true)
					Buffer = false
					MenuToggleDB = true
					local MenuOpenTween = TweenService:Create(CategoryTopBar, TweenInfo.new(MenuOpenSpeed, Enum.EasingStyle:FromName(MenuEasingStyle), Enum.EasingDirection:FromName(MenuOpenEasingDirection)), {Position = PrevPos})
					MenuOpenTween:Play()
					MenuOpenTween.Completed:Wait()
					MenuToggleDB = false
					if Buffer then
						Buffer = false
						HideHoverInfo()
                        UpdateMouseIconEnabled(false)
						MenuToggleDB = true
						local MenuCloseTween = TweenService:Create(CategoryTopBar, TweenInfo.new(MenuOpenSpeed, Enum.EasingStyle:FromName(MenuEasingStyle), Enum.EasingDirection:FromName(MenuCloseEasingDirection)), {Position = Properties.ClosedPos or UDim2.fromScale(-0.25, -1)})
						MenuCloseTween:Play()
						MenuCloseTween.Completed:Wait()
						CategoryTopBar.Visible = false
						MenuToggleDB = false
					end
				end
			else
				if CategoryTopBar.Visible then
					CategoryTopBar.Position = Properties.ClosedPos or UDim2.fromScale(-0.25, -1)
					CategoryTopBar.Visible = false
                    UpdateMouseIconEnabled(false)
				else
					CategoryTopBar.Position = PrevPos
					CategoryTopBar.Visible = true
                    UpdateMouseIconEnabled(true)
				end
			end
		end
	end)

	Connections.TidalWave["Toggle" .. CategoryName.Text .. "CategoryInputEndedConnection"] = UIS.InputEnded:Connect(function(Input)
        if (ChatboxFocused() or TidalWaveFocused or Rebinding or SettingsMenu.TopBar.Visible or ProfileMenu.TopBar.Visible) or not Toggleable then return end
        local MultiBinded = MenuKeybind:find("+") ~= nil
		local Keys = MultiBinded and MenuKeybind:split("+")
		local AllDown = true
		if MultiBinded then
			for i, v in ipairs(Keys) do
				if not UIS:IsKeyDown(v) then
					AllDown = false
				end
			end
		end
		if ((MultiBinded and not AllDown) or (not MultiBinded and Input.KeyCode.Name == MenuKeybind)) then
            Buffer = false
        end
	end)

	SettingsMenu.TopBar:GetPropertyChangedSignal("Visible"):Connect(function()
		CategoryTopBar.Visible = not SettingsMenu.TopBar.Visible
	end)

	ProfileMenu.TopBar:GetPropertyChangedSignal("Visible"):Connect(function()
		CategoryTopBar.Visible = not ProfileMenu.TopBar.Visible
	end)

	local Functions = {
		ContentFrame = ContentFrame,
		ScrollingFrame = ContentScrollingFrame,
		ContentScrollingFrame = ContentScrollingFrame,
		TopBar = CategoryTopBar,
	}

	function Functions:MakeToggleable(Bool)
		if Bool ~= nil and typeof(Bool) == "boolean" then
			Toggleable = Bool
		end
	end

	function Functions:CreateButton(BtnProperties)
		local Buttons = {}
        if not BtnProperties.NoKeybind then
            local RebindButton = CreateRebindButton({
                Keybind = BtnProperties.Text,
            })
        end
		local function ShowButtons()
			for i, v in ipairs(Buttons) do
				if typeof(v) == "Instance" and v:IsA("GuiObject") then
					v.Visible = true
				elseif typeof(v) == "table" and v.MainFrame then
					v.MainFrame.Visible = true
				end
			end
			RebindButton.Visible = true
		end
		local Button = CreateButton({
			Text = BtnProperties.Text,
			Name = BtnProperties.Name or BtnProperties.Text or nil,
			Info = BtnProperties.Info,
			Parent = ContentScrollingFrame,
			Tags = BtnProperties.Tags,
			ZIndex = ContentScrollingFrame.ZIndex,
            NoKeybind = BtnProperties.NoKeybind,
            NoSettings = BtnProperties.NoSettings,
            RichText = BtnProperties.RichText,
			Size = UDim2.new(0.975, 0, 0, (Camera.ViewportSize.Y / 40) * (BtnProperties.SizeMulti or 1)),
			Function = function()
				if BtnProperties.Function then
					BtnProperties.Function({NoNotify = false})
				elseif BtnProperties.MouseButton1Click then
					BtnProperties.MouseButton1Click({NoNotify = false})
				end
			end,
			Function2 = function()
				if BtnProperties.Function2 then
					BtnProperties.Function2({NoNotify = false})
				elseif BtnProperties.MouseButton2Click then
					BtnProperties.MouseButton2Click({NoNotify = false})
				end
                if BtnProperties.NoSettings then return end
				ShowButtons()
			end,
		})

		function Button:CreateToggle(Properties)
			local Toggle = CreateToggle({
				Parent = SettingsMenu.ScrollingFrame,
				Text = Properties.Text,
				Info = Properties.Info or "",
				ZIndex = SettingsMenu.ScrollingFrame.ZIndex,
                NoNotify = Properties.NoNotify,
				Boolean = Properties.Boolean or Properties.Bool or Properties.Default or Properties.EnabledIndicatorDefault or Properties.IndicatorDefault or Properties.EnabledDefault,
				Function = function(Bool)
					if Properties.Function then
						Properties.Function(Bool)
					elseif Properties.MouseButton1Click then
						Properties.MouseButton1Click(Bool)
					end
				end,
			})
			table.insert(Buttons, Toggle)
			return Toggle
		end

		function Button:CreateButton(Properties)
			local Button = CreateButton({
				Parent = SettingsMenu.ScrollingFrame,
				Text = Properties.Text,
				Info = Properties.Info or "",
				ZIndex = SettingsMenu.ScrollingFrame.ZIndex,
				Function = function(Bool)
					if Properties.Function then
						Properties.Function(Bool)
					elseif Properties.MouseButton1Click then
						Properties.MouseButton1Click(Bool)
					end
				end,
			})
			table.insert(Buttons, Button)
			return Button
		end

		function Button:CreateSlider(Properties)
			local Slider = CreateSlider({
				Text = Properties.Text,
				Default = Properties.Default,
				Min = Properties.Min,
				Max = Properties.Max,
				Function = Properties.Function,
				Function2 = Properties.Function2,
				ModuleName = Button.Button.Text,
			})
			table.insert(Buttons, Slider)
			return Slider
		end

		function Button:CreateTextbox(Properties)
			local Textbox = CreateTextbox({
				Text = Properties.Text,
				ButtonText = Properties.ButtonText or Properties.TextLabelText or Properties.LabelText,
				PlaceholderText = Properties.PlaceholderText,
				Function = Properties.Function or Properties.MouseButton1Click,
				Function2 = Properties.Function2 or Properties.MouseButton2Click,
				FocusLost = Properties.FocusLost,
				Focused = Properties.Focused,
			})
			table.insert(Buttons, Textbox)
			return Textbox
		end

		function Button:CreateDropdown(Properties)
			local Dropdown = CreateDropdown({
				Text = Properties.Text,
				Default = Properties.Default,
				AutoUpdateText = Properties.AutoUpdateText,
			})
			table.insert(Buttons, Dropdown)
			return Dropdown
		end

		function Button:CreateColorPicker(Properties)
			local ColorPicker = CreateColorPicker({
				Text = Properties.Text,
				Function = Properties.Function,
                ModuleName = Button.Button.Text,
                Default = Properties.Default,
			})
			table.insert(Buttons, ColorPicker)
			return ColorPicker
		end

		return Button
	end

	function Functions:CreateToggle(BtnProperties)
		local Buttons = {}
		local RebindButton = CreateRebindButton({
			Keybind = BtnProperties.Text,
		})
		local function ShowButtons()
			for i, v in ipairs(Buttons) do
				if typeof(v) == "Instance" and v:IsA("GuiObject") then
					v.Visible = true
				elseif typeof(v) == "table" and v.MainFrame then
					v.MainFrame.Visible = true
				end
			end
			RebindButton.Visible = true
		end
		local Button = CreateToggle({
			Text = BtnProperties.Text,
			Info = BtnProperties.Info or "",
			Parent = ContentScrollingFrame,
			ZIndex = ContentScrollingFrame.ZIndex,
			Size = UDim2.new(0.975, 0, 0, (Camera.ViewportSize.Y / 40) * (BtnProperties.SizeMulti or 1)),
			Tags = BtnProperties.Tags or "",
            NoNotify = BtnProperties.NoNotify,
			Boolean = BtnProperties.Boolean or BtnProperties.Bool or BtnProperties.Default or BtnProperties.EnabledIndicatorDefault or BtnProperties.IndicatorDefault or BtnProperties.EnabledDefault,
			Function = function(Bool)
				if BtnProperties.Function then
					BtnProperties.Function(Bool)
				elseif BtnProperties.MouseButton1Click then
					BtnProperties.MouseButton1Click(Bool)
				end
			end,
			Function2 = function()
				if BtnProperties.Function2 then
					BtnProperties.Function2()
				elseif BtnProperties.MouseButton2Click then
					BtnProperties.MouseButton2Click()
				end
				ShowButtons()
			end,
		})

		function Button:CreateToggle(Properties)
			local Toggle = CreateToggle({
				Parent = SettingsMenu.ScrollingFrame,
				Text = Properties.Text,
				Info = Properties.Info or "",
				ZIndex = SettingsMenu.ScrollingFrame.ZIndex,
                NoNotify = Properties.NoNotify,
				Boolean = Properties.Boolean or Properties.Bool or Properties.Default or Properties.EnabledIndicatorDefault or Properties.IndicatorDefault or Properties.EnabledDefault,
				Function = function(Bool)
					if Properties.Function then
						Properties.Function(Bool)
					elseif Properties.MouseButton1Click then
						Properties.MouseButton1Click(Bool)
					end
				end,
			})
			table.insert(Buttons, Toggle)
			return Toggle
		end

		function Button:CreateButton(Properties)
			local Button = CreateButton({
				Parent = SettingsMenu.ScrollingFrame,
				Text = Properties.Text,
				Info = Properties.Info or "",
				ZIndex = SettingsMenu.ScrollingFrame.ZIndex,
				Function = function(Bool)
					if Properties.Function then
						Properties.Function(Bool)
					elseif Properties.MouseButton1Click then
						Properties.MouseButton1Click(Bool)
					end
				end,
			})
			table.insert(Buttons, Button)
			return Button
		end

		function Button:CreateSlider(Properties)
			local Slider = CreateSlider({
				Text = Properties.Text,
				Default = Properties.Default,
				Min = Properties.Min,
				Max = Properties.Max,
				Function = Properties.Function,
				Function2 = Properties.Function2,
				ModuleName = Button.Button.Text,
			})
			table.insert(Buttons, Slider)
			return Slider
		end

		function Button:CreateTextbox(Properties)
			local Textbox = CreateTextbox({
				Text = Properties.Text,
				ButtonText = Properties.ButtonText or Properties.TextLabelText or Properties.LabelText,
				PlaceholderText = Properties.PlaceholderText,
				Function = Properties.Function or Properties.MouseButton1Click,
				Function2 = Properties.Function2 or Properties.MouseButton2Click,
				FocusLost = Properties.FocusLost,
				Focused = Properties.Focused,
			})
			table.insert(Buttons, Textbox)
			return Textbox
		end

		function Button:CreateDropdown(Properties)
			local Dropdown = CreateDropdown({
				Text = Properties.Text,
				Default = Properties.Default,
				AutoUpdateText = Properties.AutoUpdateText,
			})
			table.insert(Buttons, Dropdown)
			return Dropdown
		end

		function Button:CreateColorPicker(Properties)
			local ColorPicker = CreateColorPicker({
				Text = Properties.Text,
				Function = Properties.Function,
                ModuleName = Button.Button.Text,
                Default = Properties.Default,
			})
			table.insert(Buttons, ColorPicker)
			return ColorPicker
		end

		return Button
	end

	function Functions:CreateTextbox(BtnProperties)
		local Buttons = {}
		local function ShowButtons()
			for i, v in ipairs(Buttons) do
				if typeof(v) == "Instance" and v:IsA("GuiObject") then
					v.Visible = true
				elseif typeof(v) == "table" and v.MainFrame then
					v.MainFrame.Visible = true
				end
			end
		end
		local Textbox = CreateTextbox({
			Text = BtnProperties.Text or BtnProperties.TextboxText,
			ButtonText = BtnProperties.ButtonText or BtnProperties.TextLabelText or BtnProperties.LabelText,
			PlaceholderText = BtnProperties.PlaceholderText,
			Info = BtnProperties.Info or "",
			ZIndex = ContentScrollingFrame.ZIndex,
			Size = UDim2.new(0.975, 0, 0, (Camera.ViewportSize.Y / 40) * (BtnProperties.SizeMulti or 1)),
			Parent = ContentScrollingFrame,
			NoButton = BtnProperties.NoButton,
			EnabledIndicator = BtnProperties.EnabledIndicator,
			Tags = BtnProperties.Tags,
			Name = BtnProperties.Name,
            LayoutOrder = BtnProperties.LayoutOrder,
			Focused = function(Args)
				if BtnProperties.Focused then
					BtnProperties.Focused(Args)
				end
			end,
			FocusLost = function(Args)
				if BtnProperties.FocusLost then
					BtnProperties.FocusLost(Args)
				end
			end,
			MouseButton1Click = function(Args)
				if BtnProperties.MouseButton1Click then
					BtnProperties.MouseButton1Click(Args)
				elseif BtnProperties.Function then
					BtnProperties.Function(Args)
				end
			end,
			MouseButton2Click = function(Args)
				if BtnProperties.MouseButton2Click then
					BtnProperties.MouseButton2Click(Args)
				elseif BtnProperties.Function2 then
					BtnProperties.Function2(Args)
				end
				ShowButtons()
			end,
		})

		function Textbox:CreateToggle(Properties)
			local Toggle = CreateToggle({
				Parent = SettingsMenu.ScrollingFrame,
				Text = Properties.Text,
				Info = Properties.Info or "",
				ZIndex = SettingsMenu.ScrollingFrame.ZIndex,
                NoNotify = Properties.NoNotify,
				Boolean = Properties.Boolean or Properties.Bool or Properties.Default or Properties.EnabledIndicatorDefault or Properties.IndicatorDefault or Properties.EnabledDefault,
				Function = function(Bool)
					if Properties.Function then
						Properties.Function(Bool)
					elseif Properties.MouseButton1Click then
						Properties.MouseButton1Click(Bool)
					end
				end,
			})
			table.insert(Buttons, Toggle)
			return Toggle
		end

		function Textbox:CreateButton(Properties)
			local Button = CreateButton({
				Parent = SettingsMenu.ScrollingFrame,
				Text = Properties.Text,
				Info = Properties.Info or "",
				ZIndex = SettingsMenu.ScrollingFrame.ZIndex,
				Function = function(Bool)
					if Properties.Function then
						Properties.Function(Bool)
					elseif Properties.MouseButton1Click then
						Properties.MouseButton1Click(Bool)
					end
				end,
			})
			table.insert(Buttons, Button)
			return Button
		end

		function Textbox:CreateSlider(Properties)
			local Slider = CreateSlider({
				Text = Properties.Text,
				Default = Properties.Default,
				Min = Properties.Min,
				Max = Properties.Max,
				Function = Properties.Function,
				Function2 = Properties.Function2,
				ModuleName = Textbox.MainFrame.ButtonFrame.Text,
			})
			table.insert(Buttons, Slider)
			return Slider
		end

		function Textbox:CreateTextbox(Properties)
			local Textbox = CreateTextbox({
				Text = Properties.Text,
				ButtonText = Properties.ButtonText,
				PlaceholderText = Properties.PlaceholderText,
				Function = Properties.Function or Properties.MouseButton1Click,
				FocusLost = Properties.FocusLost,
				Focused = Properties.Focused,
			})
			table.insert(Buttons, Textbox)
			return Textbox
		end

		function Textbox:CreateDropdown(Properties)
			local Dropdown = CreateDropdown({
				Text = Properties.Text,
				Default = Properties.Default,
				AutoUpdateText = Properties.AutoUpdateText,
			})
			table.insert(Buttons, Dropdown)
			return Dropdown
		end

		function Textbox:CreateColorPicker(Properties)
			local ColorPicker = CreateColorPicker({
				Text = Properties.Text,
				Function = Properties.Function,
                ModuleName = Textbox.MainFrame.ButtonFrame.Text,
                Default = Properties.Default,
			})
			table.insert(Buttons, ColorPicker)
			return ColorPicker
		end

		return Textbox
	end

	function Functions:Toggle(Instant)
		task.spawn(function()
			if MenuToggleDB then return end
			if AnimateWindows and not Instant then
				MenuToggleDB = true
				if CategoryTopBar.Visible then
					HideHoverInfo()
					local MenuCloseTween = TweenService:Create(CategoryTopBar, TweenInfo.new(MenuOpenSpeed, Enum.EasingStyle:FromName(MenuEasingStyle), Enum.EasingDirection:FromName(MenuCloseEasingDirection)), {Position = Properties["ClosedPos"] or UDim2.fromScale(-0.25, -1)})
					MenuCloseTween:Play()
					MenuCloseTween.Completed:Wait()
					CategoryTopBar.Visible = false
					MenuToggleDB = false
				else
					CategoryTopBar.Visible = true
					MenuToggleDB = true
					local MenuOpenTween = TweenService:Create(CategoryTopBar, TweenInfo.new(MenuOpenSpeed, Enum.EasingStyle:FromName(MenuEasingStyle), Enum.EasingDirection:FromName(MenuOpenEasingDirection)), {Position = PrevPos})
					MenuOpenTween:Play()
					MenuOpenTween.Completed:Wait()
					MenuToggleDB = false
				end
			else
				if CategoryTopBar.Visible then
					CategoryTopBar.Position = Properties.ClosedPos or UDim2.fromScale(-0.25, -1)
					CategoryTopBar.Visible = false
				else
					CategoryTopBar.Position = PrevPos
					CategoryTopBar.Visible = false
				end
			end
		end)
	end

	function Functions:Show(Instant)
		task.spawn(function()
			if MenuToggleDB then return end
			if Instant then
				if CategoryTopBar.Visible then
					CategoryTopBar.Position = Properties.ClosedPos or UDim2.fromScale(-0.25, -1)
					CategoryTopBar.Visible = false
				else
					CategoryTopBar.Position = PrevPos
					CategoryTopBar.Visible = true
				end
			else
				if not CategoryTopBar.Visible then
					CategoryTopBar.Visible = true
					MenuToggleDB = true
					local MenuOpenTween = TweenService:Create(CategoryTopBar, TweenInfo.new(MenuOpenSpeed, Enum.EasingStyle:FromName(MenuEasingStyle), Enum.EasingDirection:FromName(MenuOpenEasingDirection)), {Position = PrevPos})
					MenuOpenTween:Play()
					MenuOpenTween.Completed:Wait()
					MenuToggleDB = false
				end
			end
		end)
	end

	function Functions:Hide(Instant)
		task.spawn(function()
			if MenuToggleDB then return end
			if Instant then
				if CategoryTopBar.Visible then
					CategoryTopBar.Position = Properties.ClosedPos or UDim2.fromScale(-0.25, -1)
					CategoryTopBar.Visible = false
				else
					CategoryTopBar.Position = PrevPos
					CategoryTopBar.Visible = false
				end
			else
				if CategoryTopBar.Visible then
					HideHoverInfo()
					local MenuCloseTween = TweenService:Create(CategoryTopBar, TweenInfo.new(MenuOpenSpeed, Enum.EasingStyle:FromName(MenuEasingStyle), Enum.EasingDirection:FromName(MenuCloseEasingDirection)), {Position = Properties["ClosedPos"] or UDim2.fromScale(-0.25, -1)})
					MenuCloseTween:Play()
					MenuCloseTween.Completed:Wait()
					CategoryTopBar.Visible = false
					MenuToggleDB = false
				end
			end
		end)
	end

	function Functions:IsVisible()
		return CategoryTopBar.Visible
	end

	return Functions
end

Signal = {}

do
	local Connection = {}
	Connection.__index = Connection
	Signal.__index = Signal
	local freeRunnerThread = nil
	local function acquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquiredRunnerThread = freeRunnerThread
		freeRunnerThread = nil
		fn(...)
		freeRunnerThread = acquiredRunnerThread
	end
	local function runEventHandlerInFreeThread()
		while true do
			acquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end
	function Connection.new(signal, fn)
		return setmetatable({
			_connected = true,
			_signal = signal,
			_fn = fn,
			_next = false,
		}, Connection)
	end
	function Connection:Disconnect()
		self._connected = false
		if self._signal._handlerListHead == self then
			self._signal._handlerListHead = self._next
		else
			local prev = self._signal._handlerListHead
			while prev and prev._next ~= self do
				prev = prev._next
			end
			if prev then
				prev._next = self._next
			end
		end
	end
	setmetatable(Connection, {
		__index = function(tb, key)
			error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
		end,
		__newindex = function(tb, key, value)
			error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
		end
	})
	function Signal.new()
		return setmetatable({
			_handlerListHead = false,
		}, Signal)
	end
	function Signal:Connect(fn)
		local connection = Connection.new(self, fn)
		if self._handlerListHead then
			connection._next = self._handlerListHead
			self._handlerListHead = connection
		else
			self._handlerListHead = connection
		end
		return connection
	end
	function Signal:DisconnectAll()
		self._handlerListHead = false
	end
	function Signal:Fire(...)
		local item = self._handlerListHead
		while item do
			if item._connected then
				if not freeRunnerThread then
					freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
					-- Get the freeRunnerThread to the first yield
					coroutine.resume(freeRunnerThread)
				end
				task.spawn(freeRunnerThread, item._fn, ...)
			end
			item = item._next
		end
	end
	function Signal:Wait()
		local waitingCoroutine = coroutine.running()
		local cn;
		cn = self:Connect(function(...)
			cn:Disconnect()
			task.spawn(waitingCoroutine, ...)
		end)
		return coroutine.yield()
	end
	function Signal:Once(fn)
		local cn;
		cn = self:Connect(function(...)
			if cn._connected then
				cn:Disconnect()
			end
			fn(...)
		end)
		return cn
	end
	setmetatable(Signal, {
		__index = function(tb, key)
			error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
		end,
		__newindex = function(tb, key, value)
			error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
		end
	})
end

do
	local Notifications = {}

	local function UpdateLayout()
		for i, v in ipairs(Notifications) do
			if v.Position.X.Scale == 1 then
				v.Position = UDim2.fromScale(v.Position.X.Scale, 0.96 - (i * 0.11))
			end
			local Info = TweenInfo.new(0.4, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out, 0)
			local Goal = {Position = UDim2.fromScale(0.02, 0.96 - (i * 0.11))}
			local OpenTween = TweenService:Create(v, Info, Goal)
			OpenTween:Play()
		end
	end
	
	function Notify(Properties)
		task.spawn(function()
			if not NotifyOn then return end
			local Frame = Instance.new("Frame")
			Frame.Size = UDim2.fromScale(1, 0.1)
			Frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
			Frame.BorderSizePixel = 0
			Frame.Name = Properties.Title or "Notification"
			local Index = #Notifications + 1
			table.insert(Notifications, Index, Frame)
			Frame.Position = UDim2.fromScale(1, 0.96 - (Index * 0.11))
			Frame.Parent = NotificationFrame

			local FrameUICorner = Instance.new("UICorner")
			FrameUICorner.CornerRadius = UDim.new(0.08, 0)
			FrameUICorner.Parent = Frame

			local TitleLabel = Instance.new("TextLabel")
			TitleLabel.Size = UDim2.fromScale(1, 0.3)
			TitleLabel.Position = UDim2.fromScale(0, 0)
			TitleLabel.BackgroundTransparency = 1
			TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			TitleLabel.Name = "Title"
			TitleLabel.Text = Properties.Title or "<font color = 'rgb(255, 215, 0)'>Tidal</font> <font color = 'rgb(20, 135, 255)'>Wave</font>"
			TitleLabel.Font = BoldFont
			TitleLabel.TextScaled = true
			TitleLabel.RichText = TitleLabel.Text ~= Properties.Title
			TitleLabel.Parent = Frame

			local TextLabel = Instance.new("TextLabel")
			TextLabel.Size = UDim2.fromScale(0.95, 0.6)
			TextLabel.Position = UDim2.fromScale(0.025, 0.3)
			TextLabel.BackgroundTransparency = 1
			TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel.Name = "Text"
			TextLabel.Font = TextFont
			TextLabel.Text = Properties.Text or ""
            TextLabel.TextScaled = true
            TextLabel.RichText = Properties.Text and (Properties.Text:find("<") or Properties.Text:find(">")) or false
			TextLabel.Parent = Frame

            local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
            UITextSizeConstraint.MinTextSize = 8
            UITextSizeConstraint.MaxTextSize = TextLabel.AbsoluteSize.Y / 3.25
            UITextSizeConstraint.Parent = TextLabel

            TextLabel:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                UITextSizeConstraint.MaxTextSize = TextLabel.AbsoluteSize.Y / 3.25
            end)
            
			local ProgressFrame = Instance.new("Frame")
			ProgressFrame.Name = "DurationBar"
			ProgressFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			ProgressFrame.BorderSizePixel = 0
			ProgressFrame.Size = UDim2.fromScale(0.99, 0.025)
			ProgressFrame.Position = UDim2.fromScale(0.01, 0.95)
			ProgressFrame.Parent = Frame

			local SoundID = Properties.SoundID or Properties.SoundId

            if SoundID then
                local Sound = Instance.new("Sound")
                Sound.SoundId = if typeof(SoundID) == "number" then `rbxassetid://{SoundID}` else SoundID
                Sound.Volume = Properties.Volume or 0.5
                Sound.Name = `{Properties.Title}_NotificationSound`
                Sound.Parent = SoundsFolder
                Sound.TimePosition = Properties.Start or 0
                Sound:Play()
                Debris:AddItem(Sound, math.clamp((Properties.End or 5) - (Properties.Start or 0), 0, (Properties.Duration or 3) + 0.8))
            end

            RunService.RenderStepped:Wait()
            
			UpdateLayout()

            task.wait(0.4)

			local ProgressBarTween = TweenService:Create(ProgressFrame, TweenInfo.new(Properties.Duration or 3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {Size = UDim2.fromScale(0, ProgressFrame.Size.Y.Scale)})
			ProgressBarTween:Play()
			ProgressBarTween.Completed:Wait()

            table.remove(Notifications, table.find(Notifications, Frame))
            UpdateLayout()

            local Info = TweenInfo.new(0.4, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
            local Goal = {Position = UDim2.fromScale(1, Frame.Position.Y.Scale)}
            local CloseTween = TweenService:Create(Frame, Info, Goal)
            CloseTween:Play()
            CloseTween.Completed:Wait()

			Frame:Destroy()
		end)
	end
end

function CreateDropdown(Properties)
	local SelectorMainFrame = Instance.new("Frame")
	SelectorMainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	SelectorMainFrame.BorderSizePixel = 0
	SelectorMainFrame.Size = Properties.Size or UDim2.fromScale(0.85, 0.1)
	SelectorMainFrame.Position = UDim2.fromScale(0, 0)
	SelectorMainFrame.Name = "SelectorMainFrame"
	SelectorMainFrame.ZIndex = Properties.ZIndex or 3
    SelectorMainFrame.LayoutOrder = Properties.LayoutOrder or 1
    SelectorMainFrame.Parent = Properties.Parent or SettingsMenu.ScrollingFrame
	
	local SelectorMainFrameUICorner = Instance.new("UICorner")
	SelectorMainFrameUICorner.CornerRadius = UDim.new(0.25, 0)
    SelectorMainFrameUICorner.Parent = SelectorMainFrame
	
	local SelectorTextLabel = Instance.new("TextLabel")
	SelectorTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	SelectorTextLabel.Font = TextFont
	SelectorTextLabel.Size = UDim2.fromScale(0.5, 0.6)
	SelectorTextLabel.Position = UDim2.fromScale(0.5, 0.2)
	SelectorTextLabel.ZIndex = SelectorMainFrame.ZIndex
	SelectorTextLabel.BackgroundTransparency = 1
	SelectorTextLabel.Text = Properties.Text
	SelectorTextLabel.TextScaled = true
    SelectorTextLabel.Parent = SelectorMainFrame
	
	local Filler = Instance.new("Frame")
	Filler.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	Filler.Size = UDim2.fromScale(0.1, 1)
	Filler.Position = UDim2.fromScale(0.45, 0)
	Filler.BorderSizePixel = 0
	Filler.ZIndex = SelectorMainFrame.ZIndex - 1
    Filler.Parent = SelectorMainFrame
	
	local OpenSelector = Instance.new("ImageButton")
	OpenSelector.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	OpenSelector.BorderSizePixel = 0
	OpenSelector.Size = UDim2.fromScale(0.5, 1)
	OpenSelector.Position = UDim2.fromScale(0, 0)
	OpenSelector.Name = "OpenDropdown"
	OpenSelector.ZIndex = SelectorMainFrame.ZIndex
	OpenSelector.AutoButtonColor = false
    OpenSelector.Parent = SelectorMainFrame
	
	local OpenSelectorUICorner = Instance.new("UICorner")
	OpenSelectorUICorner.CornerRadius = UDim.new(0.25, 0)
    OpenSelectorUICorner.Parent = OpenSelector

	local OpenSelectorTextLabel = Instance.new("TextLabel")
	OpenSelectorTextLabel.Size = UDim2.fromScale(0.9, 0.6)
	OpenSelectorTextLabel.Position = UDim2.fromScale(0.05, 0.2)
	OpenSelectorTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	OpenSelectorTextLabel.Font = TextFont
	OpenSelectorTextLabel.Name = "OpenDropdownText"
	OpenSelectorTextLabel.BackgroundTransparency = 1
	OpenSelectorTextLabel.Text = Properties.Default or ""
	OpenSelectorTextLabel.TextScaled = true
	OpenSelectorTextLabel.ZIndex = SelectorMainFrame.ZIndex
    OpenSelectorTextLabel.Parent = OpenSelector
	
	OpenSelector.MouseEnter:Connect(function()
		TweenService:Create(OpenSelector, TweenInfo.new(0.25,  Enum.EasingStyle.Quad), {BackgroundColor3 = Color3.fromRGB(40, 40, 40)}):Play()
	end)
	OpenSelector.MouseLeave:Connect(function()
		TweenService:Create(OpenSelector, TweenInfo.new(0.25,  Enum.EasingStyle.Quad), {BackgroundColor3 = Color3.fromRGB(20, 20, 20)}):Play()
	end)
	
	OpenSelector.MouseButton1Down:Connect(function()
		TweenService:Create(OpenSelector, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {BackgroundColor3 = Color3.fromRGB(20, 20, 20)}):Play()
	end)
	OpenSelector.MouseButton1Up:Connect(function()
		TweenService:Create(OpenSelector, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {BackgroundColor3 = Color3.fromRGB(40, 40, 40)}):Play()
	end)
	
	local ContentFrame = Instance.new("Frame")
	ContentFrame.Size = UDim2.fromScale(1, 8)
	ContentFrame.Position = UDim2.fromScale(0, 1)
	ContentFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	ContentFrame.BorderSizePixel = 0
	ContentFrame.Name = "ContentFrame"
	ContentFrame.Visible = false
	ContentFrame.Active = true
	ContentFrame.ZIndex = SelectorMainFrame.ZIndex + 1
	ContentFrame.Parent = OpenSelector

	local ContentFrameUICorner = Instance.new("UICorner")
	ContentFrameUICorner.CornerRadius = UDim.new(0, ContentFrame.AbsoluteSize.Y * 0.04)
    ContentFrameUICorner.Parent = ContentFrame
	
	local ContentFrameUIStroke = Instance.new("UIStroke")
	ContentFrameUIStroke.Thickness = 1
    ContentFrameUIStroke.Parent = ContentFrame
	
	local ArrowButton = Instance.new("ImageButton")
	ArrowButton.Size = UDim2.fromScale(0.125, 1)
	ArrowButton.Position = UDim2.fromScale(0.85, 0)
	ArrowButton.BackgroundTransparency = 1
	ArrowButton.BorderSizePixel = 0
	ArrowButton.Name = "ArrowButton"
	ArrowButton.ZIndex = SelectorMainFrame.ZIndex
    ArrowButton.Image = "rbxassetid://4841250241"
	ArrowButton.Interactable = false
	ArrowButton.Selectable = false
    ArrowButton.Rotation = 180
    ArrowButton.Parent = OpenSelector
	
	local ContentScrollingFrame = Instance.new("ScrollingFrame")
	ContentScrollingFrame.Size = UDim2.fromScale(0.975, 0.95)
	ContentScrollingFrame.Position = UDim2.fromScale(0.0125, 0.025)
	ContentScrollingFrame.BackgroundTransparency = 1
	ContentScrollingFrame.BorderSizePixel = 0
	ContentScrollingFrame.Name = "ContentScrollingFrame"
	ContentScrollingFrame.ScrollBarThickness = 5
	ContentScrollingFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	ContentScrollingFrame.ZIndex = ContentFrame.ZIndex
    ContentScrollingFrame.Parent = ContentFrame

	local ContentScrollingFrameUIGridLayout = Instance.new("UIGridLayout")
	ContentScrollingFrameUIGridLayout.CellSize = UDim2.new(0.95, 0, 0, ContentFrame.AbsoluteSize.Y * 0.1)
	ContentScrollingFrameUIGridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    ContentScrollingFrameUIGridLayout.Parent = ContentScrollingFrame
	ContentFrame.Size = UDim2.fromScale(1, 0)
	
	local OpenSelectorDB = false
	
	OpenSelector.MouseButton1Click:Connect(function()
		if OpenSelectorDB then return end
		OpenSelectorDB = true
		if ContentFrame.Visible then
			ContentScrollingFrameUIGridLayout.CellSize = UDim2.new(0.95, 0, 0, ContentFrame.AbsoluteSize.Y * 0.1)
			local Tween = TweenService:Create(ContentFrame, TweenInfo.new(0.25), {Size = UDim2.fromScale(1, 0)})
            local RotateTween = TweenService:Create(ArrowButton, TweenInfo.new(0.25), {Rotation = 180})
            RotateTween:Play()
			Tween:Play()
			Tween.Completed:Wait()
			ContentFrame.Visible = false
			OpenSelectorDB = false
		else
			ContentFrame.Visible = true
			local Tween = TweenService:Create(ContentFrame, TweenInfo.new(0.25), {Size = UDim2.fromScale(1, 8)})
            local RotateTween = TweenService:Create(ArrowButton, TweenInfo.new(0.25), {Rotation = 270})
			Tween:Play()
            RotateTween:Play()
			Tween.Completed:Wait()
			ContentScrollingFrameUIGridLayout.CellSize = UDim2.new(0.95, 0, 0.1, 0)
			OpenSelectorDB = false
		end
	end)

	local gSubbedText = (`{Properties.ModuleName or ""}_{Properties.Text or ""}`):gsub(" ", "")
	Values[gSubbedText] = {
		CurrentValue = Properties.Default or "",
		Values = {},
	}
	
	local Functions = {
		OpenBtn = OpenSelector,
		DropdownScrollingFrame = ContentScrollingFrame,
		MainFrame = SelectorMainFrame,
	}
	
	function Functions:CreateButton(BtnProperties)
		local BtnFunctions = {}
		if (BtnProperties.On or BtnProperties.OnFunction or BtnProperties.OnFunc) and (BtnProperties.Off or BtnProperties.OffFunc or BtnProperties.OffFunction) then
			local AddButton = Instance.new("TextButton")
            local function Add()
                Values[gSubbedText].Values[BtnProperties.Text].Selected = true
                AddButton.Text = "<font color = 'rgb(255, 0, 0)'>-</font>"
                if BtnProperties.On then
                    BtnProperties.On()
                elseif BtnProperties.OnFunction then
                    BtnProperties.OnFunction()
                elseif BtnProperties.OnFunc then
                    BtnProperties.OnFunc()
                end
            end
            local function Remove()
                Values[gSubbedText].Values[BtnProperties.Text].Selected = false
                AddButton.Text = "<font color = 'rgb(0, 255, 0)'>+</font>"
                if BtnProperties.Off then
                    BtnProperties.Off()
                elseif BtnProperties.OffFunction then
                    BtnProperties.OffFunction()
                elseif BtnProperties.OffFunc then
                    BtnProperties.OffFunc()
                end
            end
            Values[gSubbedText].Values[BtnProperties.Text] = {
                Selected = false,
                Add = Add,
                Remove = Remove,
            }
			local Button; Button = CreateButton({
				Text = BtnProperties.Text or "",
				Parent = ContentScrollingFrame,
				Info = BtnProperties.Info or "",
				ZIndex = ContentFrame.ZIndex,
				Function = function()
					if AddButton.ContentText == "+" then
						Add()
					else
						Remove()
					end
				end,
			})
			
			AddButton.BackgroundTransparency = 1
			AddButton.ZIndex = Button.Btn.ZIndex
			AddButton.TextColor3 = Color3.fromRGB(255, 255, 255)
			AddButton.Font = BoldFont
			AddButton.Size = UDim2.fromScale(0.25, 1)
			AddButton.Position = UDim2.fromScale(0.75, 0)
			AddButton.RichText = true
			AddButton.Active = false
			AddButton.Interactable = false
			AddButton.Selectable = false
			AddButton.Text = "<font color = 'rgb(0, 255, 0)'>+</font>"
			AddButton.TextScaled = true
			AddButton.Name = "AddButton"
            AddButton.Parent = Button.Btn

            function BtnFunctions:Add()
                Add()
            end
            function BtnFunctions:Remove()
                Remove()
            end
		else
            local Button
            local function OnClicked()
                if BtnProperties.Function then
                    BtnProperties.Function()
                elseif BtnProperties.MouseButton1Click then
                    BtnProperties.MouseButton1Click()
                end
                if Properties.AutoUpdateText or Properties.AutoUpdate then
                    OpenSelectorTextLabel.Text = Button.Btn.Text
                    Values[gSubbedText].CurrentValue = BtnProperties.Text
                end
            end
            Values[gSubbedText].Values[BtnProperties.Text] = OnClicked
			Button = CreateButton({
				Text = BtnProperties.Text,
				Parent = ContentScrollingFrame,
				Info = BtnProperties.Info or "",
				ZIndex = OpenSelector.ZIndex + 1,
				Function = OnClicked
			})
            function BtnFunctions:Set()
                OnClicked()
            end
		end
        
		return BtnFunctions
	end
	
	return Functions
end

do
    local function GetLowestLayoutOrder(Children)
        local LowestLayoutOrderObj
        local LowestLayoutOrder = math.huge
        for i, v in ipairs(Children) do
            if v.LayoutOrder < LowestLayoutOrder then
                LowestLayoutOrder = v.LayoutOrder
                LowestLayoutOrderObj = v
            end
        end
        return LowestLayoutOrderObj, LowestLayoutOrder
    end

    local Closing = {}

    local function ClearDuplicates()
        local Children = {}
        for i, v in ipairs(HackListFrame:GetChildren()) do
            if table.find(Children, v.Name) then
                v:Destroy()
            else
                if not table.find(Closing, v) then
                    table.insert(Children, v.Name)
                end
            end
        end
    end
    
    local function UpdateLayout()
        ClearDuplicates()
        local OrderedFrames = {}
        local Children = HackListFrame:GetChildren()
        table.remove(Children, table.find(Children, HackListTitleFrame))
        for i = 1, #Children do
            local LowestLayoutOrderObj = GetLowestLayoutOrder(Children)
            table.remove(Children, table.find(Children, LowestLayoutOrderObj))
            if not table.find(Closing, LowestLayoutOrderObj) then
                table.insert(OrderedFrames, LowestLayoutOrderObj)
            end
        end
        for i, v in ipairs(OrderedFrames) do
            if v.Position.X.Scale == 1 then
                v.Position = UDim2.fromScale(v.Position.X.Scale, (0.02 * i) + 0.03)
            end
            local Info = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            local Goal = {Position = UDim2.fromScale(0, (0.02 * i) + 0.03)}
            local Tween = TweenService:Create(v, Info, Goal)
            Tween:Play()
        end
    end
    
    function AddHackToList(Name)
        task.spawn(function()
            Name = tostring(Name)
            if not Name then return end
            local FoundHackFrame = HackListFrame:FindFirstChild(Name .. "Frame")
            if FoundHackFrame then
                local Index = table.find(Closing, FoundHackFrame)
                if Index then
                    table.remove(Closing, Index)
                    UpdateLayout()
                    return
                end
            end
            local HackFrame = Instance.new("Frame")
            HackFrame.BackgroundTransparency = 1
            HackFrame.Name = Name .. "Frame"
            HackFrame.Size = UDim2.fromScale(1, 0.02)
            HackFrame.Position = UDim2.fromScale(1, 0.05)
            HackFrame.Parent = HackListFrame

            local HackLabel = Instance.new("TextLabel")
            HackLabel.Size = UDim2.fromScale(0.9, 0.75)
            HackLabel.Position = UDim2.fromScale(0.05, 0.125)
            HackLabel.BackgroundTransparency = 1
            HackLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            HackLabel.Name = "HackLabel"
            HackLabel.TextXAlignment = Enum.TextXAlignment.Right
            HackLabel.Font = BoldFont or TextFont
            HackLabel.Text = Name
            HackLabel.TextScaled = true
            HackLabel.Parent = HackFrame
            HackFrame.LayoutOrder = HackLabel.TextBounds.X * -1

            local UIGradient = Instance.new("UIGradient")
            UIGradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
                ColorSequenceKeypoint.new(0.166, Color3.fromRGB(255, 255, 0)),
                ColorSequenceKeypoint.new(0.322, Color3.fromRGB(0, 255, 0)),
                ColorSequenceKeypoint.new(0.498, Color3.fromRGB(0, 255, 255)),
                ColorSequenceKeypoint.new(0.664, Color3.fromRGB(0, 0, 255)),
                ColorSequenceKeypoint.new(0.833, Color3.fromRGB(255, 0, 255)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0)),
            })
            UIGradient.Parent = HackLabel

            UpdateLayout()

            while HackFrame.Parent ~= nil and HackListRGBText and not StopScript do
                local Tween = TweenService:Create(UIGradient, TweenInfo.new(3, Enum.EasingStyle.Linear), {Offset = Vector2.new(1, 0)})
                Tween:Play()
                Tween.Completed:Wait()
                UIGradient.Offset = Vector2.new(HackLabel.Size.X.Scale * -1, 0)
            end
        end)
    end

    function RemoveHackFromList(Name)
        task.spawn(function()
            Name = tostring(Name)
            if not Name then return end

            local HackFrame = HackListFrame:FindFirstChild(Name .. "Frame")
            if not HackFrame then return end

            table.insert(Closing, HackFrame)

            local Info = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
            local Goal = {Position = UDim2.fromScale(1, HackFrame.Position.Y.Scale)}
            local Tween = TweenService:Create(HackFrame, Info, Goal)
            Tween:Play()
            UpdateLayout()
            Tween.Completed:Wait()

            local Index = table.find(Closing, HackFrame)

            if Index then
                table.remove(Closing, Index)
                HackFrame:Destroy()
            end
        end)
    end
end

type Button = {
    BackgroundColor: Color3 | nil,
    Name: string | nil,
    ZIndex: number | nil,
    Size: UDim2 | nil,
    TextColor: string | nil,
    Text: string,
    Font: Enum.Font | nil,
    TextXAlignment: Enum.TextXAlignment | nil,
    Parent: GuiObject,
    Tags: string | nil,
    Info: string | nil,
    RichText: boolean | nil,
    Function: ({NoNotify: boolean} | nil) -> () | nil,
    MouseButton1Click: ({NoNotify: boolean} | nil) -> () | nil,
    Function2: () -> () | nil,
    MouseButton2Click: () -> () | nil,
}

function CreateButton(Properties: Button)
	local Button = Instance.new("TextButton")
	Button.BackgroundColor3 = Properties.BackgroundColor or Color3.fromRGB(20, 20, 20)
	Button.Name = Properties.Name or "Button"
	Button.ZIndex = Properties.ZIndex or 1
	Button.Size = Properties.Size or UDim2.fromScale(0.85, 0.1)
	Button.BorderSizePixel = 0
    Button.AutoButtonColor = false
    Button.TextColor3 = Properties.TextColor or Color3.fromRGB(255, 255, 255)
    Button.Text = Properties.Text or "nil"
    Button.Font = TextFont
    Button.TextXAlignment = Enum.TextXAlignment.Left
    Button.TextScaled = true
    Button.RichText = Properties.RichText or false
    Button.Parent = Properties.Parent or SettingsMenu.ScrollingFrame

    local ButtonUIPadding = Instance.new("UIPadding")
    ButtonUIPadding.PaddingTop = UDim.new(0.2, 0)
    ButtonUIPadding.PaddingBottom = UDim.new(0.2, 0)
    ButtonUIPadding.PaddingLeft = UDim.new(0.025, 0)
    ButtonUIPadding.PaddingRight = UDim.new(0.025, 0)
    ButtonUIPadding.Parent = Button

	Button:SetAttribute("Button", true)
	Button:SetAttribute("Tags", Properties.Tags or "")

	local ButtonUICorner = Instance.new("UICorner")
	ButtonUICorner.CornerRadius = UDim.new(0.25, 0)
    ButtonUICorner.Parent = Button

	local MouseTouching = false

    local function OnMouseEnterTween()
        local Info = TweenInfo.new(0.25, Enum.EasingStyle.Quad)
        local Goal = {BackgroundColor3 = GuiColors.ButtonHover}
        local Tween = TweenService:Create(Button, Info, Goal)
		Tween:Play()
    end

	Button.MouseEnter:Connect(function()
		MouseTouching = true
        OnMouseEnterTween()
		task.delay(0.25, function()
			if not MouseTouching or not Properties or not Properties.Info or Properties.Info == "" then return end
			ShowHoverInfo(Properties.Info)
		end)
	end)
	
	local PrevBackgroundColor = Button.BackgroundColor3

    local function OnMouseLeaveTween()
        local Info = TweenInfo.new(0.25, Enum.EasingStyle.Quad)
        local Goal = {BackgroundColor3 = PrevBackgroundColor}
		local Tween = TweenService:Create(Button, Info, Goal)
        Tween:Play()
    end

	Button.MouseLeave:Connect(function()
		MouseTouching = false
		HideHoverInfo()
        OnMouseLeaveTween()
	end)

	Button.MouseButton1Down:Connect(OnMouseLeaveTween)

	Button.MouseButton1Up:Connect(OnMouseEnterTween)

	Button.MouseButton1Click:Connect(function()
		PlayClickSound()
		if Properties.Function then
			Properties.Function()
		elseif Properties.MouseButton1Click then
			Properties.MouseButton1Click()
		end
	end)
	
	Button.MouseButton2Click:Connect(function()
        if Properties.NoSettings then return end
		if Properties.Function2 then
			ClearSettings()
			SettingsMenu.TopBar.Text = Properties.Text
			Properties.Function2()
			SettingsMenu.TopBar.Visible = not SettingsMenu.TopBar.Visible
        elseif Properties.MouseButton2Click then
            ClearSettings()
			SettingsMenu.TopBar.Text = Properties.Text
			Properties.MouseButton2Click()
			SettingsMenu.TopBar.Visible = not SettingsMenu.TopBar.Visible
		end
	end)

	local Functions = {
		Btn = Button,
		MainFrame = Button,
		Button = Button,
        TextButton = Button,
		Frame = Button,
	}
    
    if not Properties.NoKeybind and Properties.Text and (Properties.Function2 or Properties.MouseButton2Click) then
        local Text = Properties.Text:gsub(" ", "")
        Toggles[Text] = {
            Toggle = Properties.Function or Properties.MouseButton1Click,
        }
    end
	
	function Functions:Toggle(Args)
		if Properties.Function then
			Properties.Function(Args)
        elseif Properties.MouseButton1Click then
            Properties.MouseButton1Click(Args)
		end
	end

	function Functions:Toggle2()
		if Properties.Function2 then
			Properties.Function2()
        elseif Properties.MouseButton1Click then
            Properties.MouseButton1Click()
		end
	end

	return Functions
end

type Toggle = {
    BackgroundColor: Color3 | nil,
    Name: string | nil,
    Size: UDim2 | nil,
    ZIndex: number | nil,
    TextColor: Color3 | nil,
    Text: string,
    Font: Enum.Font | nil,
    LayoutOrder: number | nil,
    TextXAlignment: Enum.TextXAlignment | nil,
    Parent: GuiObject | nil,
    Tags: string | nil,
    Info: string | nil,
    EnabledIndicatorDefault: boolean | nil,
    EnabledDefault: boolean | nil,
    IndicatorDefault: boolean | nil,
    Default: boolean | nil,
    Bool: boolean | nil,
    Boolean: boolean | nil,
    NoNotify: boolean | nil,
    Function: ({NoNotify: boolean} | nil) -> () | nil,
    MouseButton1Click: ({NoNotify: boolean} | nil) -> () | nil,
    Function2: () -> () | nil,
    MouseButton2Click: () -> () | nil,
}

function CreateToggle(Properties: Toggle)
    local Button = Instance.new("TextButton")
	Button.BackgroundColor3 = GuiColors.Button
	Button.Name = Properties.Name or "Toggle"
	Button.Size = Properties.Size or UDim2.fromScale(0.85, 0.1)
	Button.BorderSizePixel = 0
    Button.AutoButtonColor = false
    Button.ZIndex = Properties.ZIndex or (Properties.Parent and Properties.Parent.ZIndex) or SettingsMenu.ScrollingFrame.ZIndex
    Button.TextColor3 = GuiColors.Text
	Button.Text = Properties.Text or "nil"
	Button.Font = TextFont
    Button.LayoutOrder = Properties.LayoutOrder or 0
    Button.TextXAlignment = Enum.TextXAlignment.Left
    Button.TextScaled = true
    Button.Parent = Properties.Parent or SettingsMenu.ScrollingFrame
    
	Button:SetAttribute("Toggle", true)
	Button:SetAttribute("Tags", Properties.Tags or "")

    local ButtonUIPadding = Instance.new("UIPadding")
    ButtonUIPadding.PaddingTop = UDim.new(0.2, 0)
    ButtonUIPadding.PaddingBottom = UDim.new(0.2, 0)
    ButtonUIPadding.PaddingLeft = UDim.new(0.025, 0)
    ButtonUIPadding.PaddingRight = UDim.new(0.025, 0)
    ButtonUIPadding.Parent = Button

	local ButtonUICorner = Instance.new("UICorner")
	ButtonUICorner.CornerRadius = UDim.new(0.25, 0)
    ButtonUICorner.Parent = Button

    local Bool = Properties.Boolean or Properties.Bool or Properties.Default or Properties.EnabledIndicatorDefault or Properties.IndicatorDefault or Properties.EnabledDefault or false

	local ButtonEnabledIndicator = Instance.new("Frame")
	if Bool then
		ButtonEnabledIndicator.BackgroundColor3 = GuiColors.EnabledIndicatorOn
	else
		ButtonEnabledIndicator.BackgroundColor3 = GuiColors.EnabledIndicatorOff
	end
	ButtonEnabledIndicator.Size = UDim2.fromScale(0.015, 1.2)
	ButtonEnabledIndicator.Position = UDim2.fromScale(1, -0.1)
	ButtonEnabledIndicator.Name = "ButtonEnabledIndicator"
	ButtonEnabledIndicator.BorderSizePixel = 0
	ButtonEnabledIndicator.ZIndex = Button.ZIndex
    ButtonEnabledIndicator.Parent = Button

	local ButtonEnabledIndicatorUICorner = Instance.new("UICorner")
	ButtonEnabledIndicatorUICorner.CornerRadius = UDim.new(1, 0)
    ButtonEnabledIndicatorUICorner.Parent = ButtonEnabledIndicator
    
	local MouseTouching = false

	Button.MouseEnter:Connect(function()
		MouseTouching = true
		TweenService:Create(Button, TweenInfo.new(0.25, Enum.EasingStyle.Quad), {BackgroundColor3 = GuiColors.ButtonHover}):Play()
		task.delay(0.25, function()
			if not MouseTouching or not Properties or Properties.Info == "" then return end
			ShowHoverInfo(Properties.Info)
		end)
	end)
	Button.MouseLeave:Connect(function()
		MouseTouching = false
		TweenService:Create(Button, TweenInfo.new(0.25, Enum.EasingStyle.Quad), {BackgroundColor3 = GuiColors.Button}):Play()
		HideHoverInfo()
	end)
    local Text = string.gsub(Properties.Text, " ", "")
    local Functions = {
		Btn = Button,
		Button = Button,
		MainFrame = Button,
		Frame = Button,
	}
    local function Toggle(Args)
		Args = Args or {NoNotify = false}
        Toggles[Text].Boolean = not Toggles[Text].Boolean
        Toggles[Text].Enabled = Toggles[Text].Boolean == true
        Toggles[Text].Disabled = Toggles[Text].Boolean == false
		Functions.Boolean = Toggles[Text].Boolean
        Functions.Enabled = Toggles[Text].Boolean == true
        Functions.Disabled = Toggles[Text].Boolean == false
        if Properties.NoNotify or Properties.Exclude then
            ToggleButtonColor(Button, Toggles[Text].Boolean)
        else
            if Button.Parent == SettingsMenu.ScrollingFrame then
                ToggleButtonColor(Button, Toggles[Text].Boolean)
                NotifyModuleToggled(Properties.Text, Toggles[Text].Boolean)
            else
                ModuleToggled(Functions, Properties.Text, Toggles[Text].Boolean, Args.NoNotify)
            end
        end
		if Properties.Function then
			Properties.Function(Toggles[Text].Boolean)
		elseif Properties.MouseButton1Click then
			Properties.MouseButton1Click(Toggles[Text].Boolean)
		end
    end
	Button.MouseButton1Click:Connect(function()
		PlayClickSound()
        Toggle()
	end)
	Button.MouseButton1Down:Connect(function()
		TweenService:Create(Button, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {BackgroundColor3 = GuiColors.Button}):Play()
	end)
	Button.MouseButton1Up:Connect(function()
		TweenService:Create(Button, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {BackgroundColor3 = GuiColors.ButtonHover}):Play()
	end)
	Button.MouseButton2Click:Connect(function()
		if Properties.Function2 then
			ClearSettings()
			SettingsMenu.TopBar.Text = Properties.Text
			Properties.Function2()
			SettingsMenu.TopBar.Visible = not SettingsMenu.TopBar.Visible
		elseif Properties.MouseButton2Click then
			ClearSettings()
			SettingsMenu.TopBar.Text = Properties.Text
			Properties.MouseButton2Click()
			SettingsMenu.TopBar.Visible = not SettingsMenu.TopBar.Visible
		end
	end)
    
	Functions.Boolean = Bool
    Functions.Enabled = Bool == true
    Functions.Disabled = Bool == false
    
	function Functions:Toggle(Args)
        Toggle(Args)
	end

	function Functions:Enable(Args)
		if Functions.Disabled then
			Toggle(Args)
		end
	end

	function Functions:Disable(Args)
		if Functions.Enabled then
			Toggle(Args)
		end
	end

	Toggles[Text] = {
        Toggle = Toggle,
		Enable = Functions.Enable,
		Disable = Functions.Disable,
        Boolean = Bool,
        Enabled = Bool == true,
        Disabled = Bool == false,
    }

	function Functions:Toggle2()
		if Properties.Function2 then
			Properties.Function2()
		elseif Properties.MouseButton2Click then
			Properties.MouseButton2Click()
		end
	end

	return Functions
end

type Textbox = {
	Name: string | nil,
	TextboxText: string | nil,
	Text: string | nil,
	LayoutOrder: number | nil,
	ZIndex: number | nil,
	Size: UDim2 | nil,
	Parent: GuiObject | nil,
	Tags: string | nil,
	PlaceholderText: string | nil,
	Focused: ({GuiObject}) -> () | nil,
	FocusLost: ({GuiObject}) -> () | nil,
	NoButton: boolean | nil,
	ButtonText: string | nil,
	EnabledIndicator: boolean | nil,
	ButtonEnabledIndicator: boolean | nil,
	Bool: boolean | nil,
	Boolean: boolean | nil,
	Default: boolean | nil,
	EnabledIndicatorDefault: boolean | nil,
	IndicatorDefault: boolean | nil,
	Info: string | nil,
	Function: ({GuiObject}) -> () | nil,
	MouseButton1Click: ({GuiObject}) -> () | nil,
	Function2: () -> () | nil,
	MouseButton2Click: () -> () | nil,
}

function CreateTextbox(Properties: Textbox)
	local Frame = Instance.new("Frame")
	Frame.BackgroundColor3 = GuiColors.Button
	Frame.BorderSizePixel = 0
	Frame.Name = Properties.Name or Properties.TextboxText or Properties.Text or "Textbox"
	Frame.LayoutOrder = Properties.LayoutOrder or 0
	Frame.ZIndex = Properties.ZIndex or (Properties.Parent and Properties.Parent.ZIndex) or SettingsMenu.ScrollingFrame.ZIndex
	Frame.Size = Properties.Size or UDim2.fromScale(0.85, 0.1)
    Frame.Parent = Properties.Parent or SettingsMenu.ScrollingFrame

	Frame:SetAttribute("Textbox", true)
	Frame:SetAttribute("Tags", Properties.Tags or "")

	local FrameUICorner = Instance.new("UICorner")
	FrameUICorner.CornerRadius = UDim.new(0.25, 0)
    FrameUICorner.Parent = Frame
	
	local Textbox = Instance.new("TextBox")
	Textbox.BackgroundColor3 = GuiColors.TextboxBackground
    Textbox.BorderSizePixel = 0
	Textbox.Font = TextFont
	Textbox.PlaceholderText = Properties.PlaceholderText or ""
	Textbox.PlaceholderColor3 = GuiColors.TextboxPlaceholder
	Textbox.TextColor3 = GuiColors.Text
	Textbox.Text = Properties.TextboxText or Properties.Text or ""
	Textbox.Name = "Textbox"
	Textbox.ZIndex = Frame.ZIndex
	Textbox.Size =  UDim2.fromScale(0.45, 0.75)
	Textbox.Position = UDim2.fromScale(0.025, 0.125)
	Textbox.ClearTextOnFocus = false
	Textbox.TextScaled = true
    Textbox.Parent = Frame

    local TextboxUICorner = Instance.new("UICorner")
	TextboxUICorner.CornerRadius = UDim.new(0.25, 0)
    TextboxUICorner.Parent = Textbox

    local TextboxUIPadding = Instance.new("UIPadding")
    TextboxUIPadding.PaddingTop = UDim.new(0.1, 0)
    TextboxUIPadding.PaddingBottom = UDim.new(0.1, 0)
    TextboxUIPadding.PaddingLeft = UDim.new(0.025, 0)
    TextboxUIPadding.PaddingRight = UDim.new(0.025, 0)
    TextboxUIPadding.Parent = Textbox

	Textbox.Focused:Connect(function()
		TidalWaveFocused = true
		if Properties.Focused then
			Properties.Focused({
				Textbox = Textbox,
				MainFrame = Frame,
				Frame = Frame,
				TextboxText = Textbox.Text,
				Text = Textbox.Text,
			})
		end
	end)

	Textbox.FocusLost:Connect(function(Enter, Input)
		TidalWaveFocused = false
		if Properties.FocusLost then
			Properties.FocusLost({
				Textbox = Textbox,
				MainFrame = Frame,
				Frame = Frame,
				TextboxText = Textbox.Text,
				Text = Textbox.Text,
				EnterPressed = Enter,
				Enter = Enter,
				InputThatCausedFocusLost = Input,
				Input = Input,
			})
		end
	end)
	
	local ButtonFrame = nil

	if Properties.NoButton then
		Textbox.Size = UDim2.fromScale(0.95, 0.75)
	else
		ButtonFrame = Instance.new("TextButton")
		ButtonFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
		ButtonFrame.BorderSizePixel = 0
		ButtonFrame.ZIndex = Frame.ZIndex
		ButtonFrame.Size = UDim2.fromScale(0.475, 0.75)
		ButtonFrame.Position = UDim2.fromScale(0.5, 0.125)
		ButtonFrame.Name = "ButtonFrame"
		ButtonFrame.AutoButtonColor = false
		ButtonFrame.Text = Properties.ButtonText or "Enable"
		ButtonFrame.TextScaled = true
		ButtonFrame.TextColor3 = GuiColors.Text
        ButtonFrame.Parent = Frame

		local ButtonFrameUIPadding = Instance.new("UIPadding")
		ButtonFrameUIPadding.PaddingTop = UDim.new(0.125, 0)
		ButtonFrameUIPadding.PaddingBottom = UDim.new(0.125, 0)
		ButtonFrameUIPadding.PaddingLeft = UDim.new(0.025)
		ButtonFrameUIPadding.PaddingRight = UDim.new(0.025)
		ButtonFrameUIPadding.Parent = ButtonFrame

		local ButtonFrameUICorner = Instance.new("UICorner")
		ButtonFrameUICorner.CornerRadius = UDim.new(0.25, 0)
        ButtonFrameUICorner.Parent = ButtonFrame
	end

	local ButtonEnabledIndicator = nil

	local Bool = Properties.Bool or Properties.Boolean or Properties.Default or Properties.EnabledIndicatorDefault or Properties.IndicatorDefault or false

	if Properties.EnabledIndicator or Properties.ButtonEnabledIndicator then
		ButtonEnabledIndicator = Instance.new("Frame")
		if Bool then
			ButtonEnabledIndicator.BackgroundColor3 = GuiColors.EnabledIndicatorOn
		else
			ButtonEnabledIndicator.BackgroundColor3 = GuiColors.EnabledIndicatorOff
		end
		ButtonEnabledIndicator.Size = UDim2.fromScale(0.015, 0.8)
	    ButtonEnabledIndicator.Position = UDim2.fromScale(0.975, 0.1)
		ButtonEnabledIndicator.Name = "ButtonEnabledIndicator"
		ButtonEnabledIndicator.BorderSizePixel = 0
		ButtonEnabledIndicator.ZIndex = Frame.ZIndex
        ButtonEnabledIndicator.Parent = Frame

		local ButtonEnabledIndicatorUICorner = Instance.new("UICorner")
		ButtonEnabledIndicatorUICorner.CornerRadius = UDim.new(1, 0)
        ButtonEnabledIndicatorUICorner.Parent = ButtonEnabledIndicator
	end

	local Functions = {
		Textbox = Textbox,
		MainFrame = Frame,
		Frame = Frame,
		Boolean = Bool,
	}
	local Text
	if Properties.ButtonText then
		Text = string.gsub(Properties.ButtonText, " ", "")
	end

	local function Toggle(Args)
		if not Text then return end
        if Properties.ButtonText and ButtonEnabledIndicator then
            Args = Args or {NoNotify = false}
            Toggles[Text].Boolean = not Toggles[Text].Boolean
            Functions.Boolean = Toggles[Text].Boolean
            if Frame.Parent == SettingsMenu.ScrollingFrame then
                ToggleButtonColor(Frame, Toggles[Text].Boolean)
            else
                ModuleToggled(Functions, Properties.ButtonText, Toggles[Text].Boolean, Args.NoNotify)
            end
        end
		if Properties.Function then
			Properties.Function(Toggles[Text].Boolean)
		elseif Properties.MouseButton1Click then
			Properties.MouseButton1Click(Toggles[Text].Boolean)
		end
	end
	
	function Functions:Toggle(Args)
		Toggle(Args)
	end
	
	function Functions:Enable(Args)
		if Text and not Toggles[Text].Boolean then
			Toggle(Args)
		end
	end

	function Functions:Disable(Args)
		if Text and Toggles[Text].Boolean then
			Toggle(Args)
		end
	end
	
	if Text then
		Toggles[Text] = {
			Toggle = Functions.Toggle,
			Enable = Functions.Enable,
			Disable = Functions.Disable,
			Boolean = Bool,
		}
	end

	if ButtonFrame then
		ButtonFrame.MouseButton1Click:Connect(function()
			PlayClickSound()
			Toggle()
		end)
		
		ButtonFrame.MouseButton2Click:Connect(function()
			if Properties.Function2 then
				ClearSettings()
				SettingsMenu.TopBar.Text = Properties.Text or Properties.TextboxText or Properties.ButtonText or Properties.PlaceholderText
				Properties.Function2()
				SettingsMenu.TopBar.Visible = not SettingsMenu.TopBar.Visible
			elseif Properties.MouseButton2Click then
				ClearSettings()
				SettingsMenu.TopBar.Text = Properties.Text or Properties.TextboxText or Properties.ButtonText or Properties.PlaceholderText
				Properties.MouseButton2Click()
				SettingsMenu.TopBar.Visible = not SettingsMenu.TopBar.Visible
			end
		end)

		local PrevBackgroundColor = ButtonFrame.BackgroundColor3

		local function OnMouseEnterTween()
			local Info = TweenInfo.new(0.25, Enum.EasingStyle.Quad)
			local Goal = {BackgroundColor3 = GuiColors.ButtonHover}
			local Tween = TweenService:Create(ButtonFrame, Info, Goal)
			Tween:Play()
		end

		local function OnMouseLeaveTween()
			local Info = TweenInfo.new(0.25, Enum.EasingStyle.Quad)
			local Goal = {BackgroundColor3 = PrevBackgroundColor}
			local Tween = TweenService:Create(ButtonFrame, Info, Goal)
			Tween:Play()
		end
		
		ButtonFrame.MouseEnter:Connect(OnMouseEnterTween)
		ButtonFrame.MouseLeave:Connect(OnMouseLeaveTween)
		ButtonFrame.MouseButton1Down:Connect(OnMouseLeaveTween)
		ButtonFrame.MouseButton1Up:Connect(OnMouseEnterTween)
	end

	local TouchingFrame = false

	Frame.MouseEnter:Connect(function()
		TouchingFrame = true
		task.delay(0.25, function()
			if not TouchingFrame or not Properties.Info or Properties.Info == "" then return end
			ShowHoverInfo(Properties.Info)
		end)
	end)
	Frame.MouseLeave:Connect(function()
		TouchingFrame = false
		HideHoverInfo()
	end)
	
	return Functions
end

function ToggleButtonColor(Button, Value)
	if Button and typeof(Button) == "Instance" then
		local ButtonEnabledIndicator = Button:FindFirstChild("ButtonEnabledIndicator")
		if not ButtonEnabledIndicator then return end
		if Value ~= nil then
			if Value then
				TweenService:Create(ButtonEnabledIndicator, TweenInfo.new(0.25, Enum.EasingStyle.Quad), {BackgroundColor3 = GuiColors.EnabledIndicatorOn}):Play()
			else
				TweenService:Create(ButtonEnabledIndicator, TweenInfo.new(0.25, Enum.EasingStyle.Quad), {BackgroundColor3 = GuiColors.EnabledIndicatorOff}):Play()
			end
		end
	elseif Button and typeof(Button) == "table" and Button.MainFrame and typeof(Button.MainFrame) == "Instance" then
		local ButtonEnabledIndicator = Button.MainFrame:FindFirstChild("ButtonEnabledIndicator")
		if not ButtonEnabledIndicator then return end
		if Value ~= nil then
			if Value then
				TweenService:Create(ButtonEnabledIndicator, TweenInfo.new(0.25, Enum.EasingStyle.Quad), {BackgroundColor3 = GuiColors.EnabledIndicatorOn}):Play()
			else
				TweenService:Create(ButtonEnabledIndicator, TweenInfo.new(0.25, Enum.EasingStyle.Quad), {BackgroundColor3 = GuiColors.EnabledIndicatorOff}):Play()
			end
		end
	end
end

function GetClosestPlayer()
	local ClosestPlayerDistance = 1000000
	local ClosestPlayer = nil
	for i, Player in ipairs(Players:GetPlayers()) do
        if Player == Plr or Player.UserId == Plr.UserId then continue end
		local PlayerChar = GetChar(Player)
		local PlayerRoot = GetRoot(PlayerChar)
		local Char = GetChar(Plr)
		local Root = GetRoot(Char)
		if not (Char and Root and PlayerChar and PlayerRoot) then continue end
		local Magnitude = (PlayerRoot.Position - Root.Position).Magnitude
		if Magnitude < ClosestPlayerDistance then
			ClosestPlayerDistance = Magnitude
			ClosestPlayer = Player
		end
	end
	return ClosestPlayer
end

function GetClosestModelToMiddleOfScreen(Folder, ScreenX, ScreenY, ViewCheck, ExcludeWithProperty)
	local ClosestModelDistance = 1000000
	local ClosestModel = nil
	local ModelsWithinScreen = {}
	local Char = GetChar(Plr)
	local Root = GetRoot(Char)
	if not (Char and Root) then return end
	for i, Model in pairs(Folder:GetChildren()) do
		if Model:IsA("Model") then
            local ModelRoot = GetRoot(Model)
            if not ModelRoot then return end
            if ExcludeWithProperty then
                local Success, LoadedString = pcall(function()
                    return Loadstring(`return {ExcludeWithProperty}`)
                end)
                if Success and typeof(LoadedString) == "function" and LoadedString(Model) then
                    continue
                end
            end
            if ViewCheck then
                local Head = Char:FindFirstChild("Head") or Root
                local ModelHead = Model:FindFirstChild("Head") or ModelRoot
                local Origin = Head.Position
                local Direction = (ModelHead.Position - Head.Position).Unit
                local Params = RaycastParams.new()
                Params.IgnoreWater = true
                Params.RespectCanCollide = true
                Params.FilterDescendantsInstances = {Char}
                local Raycast = workspace:Raycast(Origin, Direction * 1000, Params)
                if Raycast and Raycast.Instance.Parent ~= Model then continue end
            end
			local Vector = Camera:WorldToViewportPoint(ModelRoot.Position)
			local WithinScreenRangeX = Vector.X > Camera.ViewportSize.X * (0.5 - ScreenX) and Vector.X < Camera.ViewportSize.X * (0.5 + ScreenX)
			local WithinScreenRangeY = Vector.Y > Camera.ViewportSize.Y * (0.5 - ScreenY) and Vector.Y < Camera.ViewportSize.Y * (0.5 + ScreenY)
			if WithinScreenRangeX and WithinScreenRangeY then
				table.insert(ModelsWithinScreen, Model)
			end
		end
	end
	for i, Model in ipairs(ModelsWithinScreen) do
		local ModelRoot = GetRoot(Model)
		if not ModelRoot then continue end
		local Magnitude = (Root.Position - ModelRoot.Position).Magnitude
		if Magnitude < ClosestModelDistance then
			ClosestModelDistance = Magnitude
			ClosestModel = Model
		end
	end
	return ClosestModel
end

function GetClosestPartToMiddleOfScreen(Folder, ScreenX, ScreenY)
	local ClosestPartDistance = 1000000
	local ClosestPart = nil
	local PartsWithinScreen = {}
	local Char = GetChar(Plr)
	local Root = GetRoot(Char)
	if not (Char and Root) then return end
	for i, Part in pairs(Folder:GetChildren()) do
		if Part:IsA("BasePart") then 
			local Vector = Camera:WorldToViewportPoint(Part.Position)
			local Middle = Vector2.new(Camera.ViewportSize.X * 0.5, Camera.ViewportSize.Y * 0.5)
			local WithinScreenRangeX = Vector.X > Middle.X - ScreenX and Vector.X < Middle.X + ScreenX
			local WithinScreenRangeY = Vector.Y > Middle.Y - ScreenY and Vector.Y < Middle.Y + ScreenY
			if WithinScreenRangeX and WithinScreenRangeY then
				table.insert(PartsWithinScreen, Part)
			end
		end
	end
	for i, Part in ipairs(PartsWithinScreen) do
		local Magnitude = (Part.Position - Root.Position).Magnitude
		if Magnitude < ClosestPartDistance then
			ClosestPartDistance = Magnitude
			ClosestPart = Part
		end
	end
	return ClosestPart
end

function GetClosestPlayerToMiddleOfScreen(ScreenX, ScreenY, ViewCheck)
	ScreenX = ScreenX * 0.5
	ScreenY = ScreenY * 0.5
	local ClosestPlayerDistance = math.huge
	local ClosestPlayerScreenPos
	local ClosestPlayer
	local PlayersWithinScreen = {}
	local Char = GetChar(Plr)
	local Root = GetRoot(Char)
	if not (Char and Root) then return end
	for i, Player in ipairs(Players:GetPlayers()) do
        if Player == Plr or Player.UserId == Plr.UserId then continue end
		local PlayerChar = GetChar(Player)
		local PlayerRoot = GetRoot(PlayerChar)
		
        if not (PlayerChar and PlayerRoot) then continue end

		if ViewCheck then
			local Head = Char:FindFirstChild("Head") or Root
			local PlayerHead = PlayerChar:FindFirstChild("Head") or PlayerRoot
			local Origin = Head.Position
			local Direction = (PlayerHead.Position - Head.Position).Unit
			local Params = RaycastParams.new()
			Params.IgnoreWater = true
			Params.RespectCanCollide = true
            Params.FilterDescendantsInstances = {Char}
			local Raycast = workspace:Raycast(Origin, Direction * 1000, Params)
			if Raycast and Raycast.Instance.Parent ~= PlayerHead.Parent then continue end
		end

		local Vector = Camera:WorldToViewportPoint(PlayerRoot.Position)
		local Middle = Vector2.new(Camera.ViewportSize.X * 0.5, Camera.ViewportSize.Y * 0.5)
		local WithinScreenRangeX = Vector.X > Middle.X - ScreenX and Vector.X < Middle.X + ScreenX
		local WithinScreenRangeY = Vector.Y > Middle.Y - ScreenY and Vector.Y < Middle.Y + ScreenY

		if WithinScreenRangeX and WithinScreenRangeY then 
			table.insert(PlayersWithinScreen, Player)
			ClosestPlayerScreenPos = Vector
		end
	end
	for i, Player in ipairs(PlayersWithinScreen) do
		local PlayerChar = GetChar(Player)
		local PlayerRoot = GetRoot(PlayerChar)
		if not (PlayerChar and PlayerRoot) then continue end
		local Magnitude = (Root.Position - PlayerRoot.Position).Magnitude
		if Magnitude < ClosestPlayerDistance then
			ClosestPlayer = Player
			ClosestPlayerDistance = Magnitude
		end
	end

	return ClosestPlayer, ClosestPlayerScreenPos
end

type Slider = {
    Name: string | nil,
    Size: UDim2 | nil,
    ZIndex: number | nil,
    Text: string,
    Parent: GuiObject | nil,
	LayoutOrder: number | nil,
    Default: number,
	Min: number,
	Max: number,
    ModuleName: string,
    Function: (number) -> (),
    Function2: (number) -> (),
}

function CreateSlider(Properties: Slider)
	local Frame = Instance.new("Frame")
	Frame.BorderSizePixel = 0
	Frame.BackgroundTransparency = 1
	Frame.ZIndex = Properties.ZIndex or 2
	Frame.Size = Properties.Size or UDim2.fromScale(0.85, 0.1)
	Frame.Name = Properties.Text or "SliderMainFrame"
	Frame.LayoutOrder = Properties.LayoutOrder or 2
    Frame.Parent = Properties.Parent or SettingsMenu.ScrollingFrame
	
	local TextFrame = Instance.new("Frame")
	TextFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	TextFrame.BackgroundTransparency = 0.25
	TextFrame.BorderSizePixel = 0
	TextFrame.Size = UDim2.fromScale(0.25, 1)
	TextFrame.Name = "LabelFrame"
	TextFrame.Parent = Frame

	local TextFrameUICorner = Instance.new("UICorner")
	TextFrameUICorner.CornerRadius = UDim.new(0.3, 0)
    TextFrameUICorner.Parent = TextFrame
	
	local TextLabel = Instance.new("TextLabel")
	TextLabel.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	TextLabel.BackgroundTransparency = 0.25
	TextLabel.BorderSizePixel = 0
	TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	TextLabel.Size = UDim2.fromScale(0.9, 0.4)
	TextLabel.ZIndex = Frame.ZIndex
	TextLabel.Name = "Label"
	TextLabel.Text = Properties.Text or "nil"
	TextLabel.Position = UDim2.fromScale(0.05, 0.3)
	TextLabel.TextScaled = true
    TextLabel.Parent = TextFrame
	
	local SliderFrame = Instance.new("Frame")
	SliderFrame.BorderSizePixel = 0
	SliderFrame.BackgroundTransparency = 1
	SliderFrame.ZIndex = Frame.ZIndex
	SliderFrame.Size = UDim2.fromScale(0.52, 0.3)
	SliderFrame.Position = UDim2.fromScale(0.48, 0.35)
	SliderFrame.Name = "SliderFrame"
    SliderFrame.Parent = Frame
	
	local SliderButton = Instance.new("ImageButton")
	SliderButton.BackgroundTransparency = 1
	SliderButton.BorderSizePixel = 0
	SliderButton.Size = UDim2.fromScale(0.043, 0.75)
	SliderButton.Position = UDim2.fromScale(math.clamp((math.clamp(Properties.Default, Properties.Min, Properties.Max) - Properties.Min) / (Properties.Max - Properties.Min), 0, 0.998 - SliderButton.Size.X.Scale), 0)
	SliderButton.ZIndex = Frame.ZIndex + 1
	SliderButton.Name = "Slider"
	SliderButton.Image = "rbxassetid://5552526748"
	SliderButton.ImageColor3 = Color3.fromRGB(20, 135, 255)
    SliderButton.Parent = SliderFrame
	
	local SliderBarBackground = Instance.new("Frame")
	SliderBarBackground.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	SliderBarBackground.BorderSizePixel = 0
	SliderBarBackground.Size = UDim2.fromScale(1, 0.5)
	SliderBarBackground.Position = UDim2.fromScale(0, 0.125)
	SliderBarBackground.Name = "SliderBarBackground"
	SliderBarBackground.ZIndex = Frame.ZIndex
    SliderBarBackground.Parent = SliderFrame
	
	local SliderBarBackgroundUICorner = Instance.new("UICorner")
	SliderBarBackgroundUICorner.CornerRadius = UDim.new(1, 0)
    SliderBarBackgroundUICorner.Parent = SliderBarBackground
	
	local NumberDisplayFrame = Instance.new("Frame")
	NumberDisplayFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	NumberDisplayFrame.BorderSizePixel = 0
	NumberDisplayFrame.Size = UDim2.fromScale(0.15, 0.5)
	NumberDisplayFrame.Position = UDim2.fromScale(0.3, 0.25)
	NumberDisplayFrame.ZIndex = Frame.ZIndex
	NumberDisplayFrame.Name = "NumberDisplayFrame"
    NumberDisplayFrame.Parent = Frame
	
	local NumberDisplayFrameUICorner = Instance.new("UICorner")
	NumberDisplayFrameUICorner.CornerRadius = UDim.new(0.5, 0)
    NumberDisplayFrameUICorner.Parent = NumberDisplayFrame
	
	local NumberDisplay = Instance.new("TextBox")
	NumberDisplay.BackgroundTransparency = 1
	NumberDisplay.TextColor3 = Color3.fromRGB(255, 255, 255)
	NumberDisplay.Size = UDim2.fromScale(0.9, 0.6)
	NumberDisplay.Position = UDim2.fromScale(0.05, 0.2)
	NumberDisplay.Text = tostring(Properties.Default) or "1"
	NumberDisplay.Name = "NumberDisplay"
	NumberDisplay.ZIndex = Frame.ZIndex
	NumberDisplay.ClearTextOnFocus = false
	NumberDisplay.TextScaled = true
    NumberDisplay.Parent = NumberDisplayFrame
	
	local PrevVal = Properties.Default or tonumber(NumberDisplay.Text) or 1
	local gSubbedText = (`{Properties.ModuleName or ""}_{Properties.Text or ""}`):gsub(" ", "")
    local Refs = {
		MainFrame = Frame,
		Frame = Frame,
        Value = Properties.Default,
	}

    function Refs:UpdateSlider(Num)
		local Min = Properties.Min
        local Max = Properties.Max
        local Number = tonumber(Num) or PrevVal or Min
        local Val = math.clamp(Number, Min, Max)
        local Position = math.clamp((Val - Min) / (Max - Min), 0, 0.998 - SliderButton.Size.X.Scale)
        SliderButton.Position = UDim2.fromScale(Position, 0)
        NumberDisplay.Text = tostring(Number)
		Properties.Function2(Number)
	end
	
	NumberDisplay.FocusLost:Connect(function() 
        local Min = Properties.Min
        local Max = Properties.Max
        local Number = tonumber(NumberDisplay.Text) or PrevVal or Min
        local Val = math.clamp(Number, Min, Max)
        local Position = math.clamp((Val - Min) / (Max - Min), 0, 0.998 - SliderButton.Size.X.Scale)
        SliderButton.Position = UDim2.fromScale(Position, 0)
        Values[gSubbedText].Value = Number
        Refs.Value = Number
        NumberDisplay.Text = tostring(Number)
        Properties.Function2(Number)
    end)

	local UIDragDetector = Instance.new("UIDragDetector")
	UIDragDetector.DragStyle = Enum.UIDragDetectorDragStyle.TranslateLine
	UIDragDetector.ResponseStyle = Enum.UIDragDetectorResponseStyle.Scale
	UIDragDetector.BoundingUI = SliderFrame
    UIDragDetector.Parent = SliderButton
	
	UIDragDetector.DragContinue:Connect(function()
        local Min = Properties.Min
        local Max = Properties.Max
        local Val = SliderButton.Position.X.Scale * (1.002 + SliderButton.Size.X.Scale)
        Val = math.clamp(Min + (Max - Min) * Val, Min, Max)
		NumberDisplay.Text = tostring(SubstituteNumber(Val, 3))
		Values[gSubbedText].Value = Val
        Refs.Value = Val
        Properties.Function(Val)
	end)
    
    Values[gSubbedText] = {
		Value = Properties.Default,
        UpdateSlider = Refs.UpdateSlider,
	}
	
	return Refs
end

function CreateColorPicker(Properties)
	local Background = Instance.new("Frame")
	Background.BorderSizePixel = 0
	Background.BackgroundColor3 = GuiColors.Button
	Background.Size = Properties.Size or UDim2.fromScale(0.85, 0.85)
	Background.Position = Properties.Position or Properties.Pos or UDim2.fromScale(0.4045, 0.248)
	Background.Active = true
	Background.ZIndex = Properties.ZIndex or 1
	Background.LayoutOrder = Properties.LayoutOrder or 3
	Background.Name = "Background"
    Background.Parent = Properties.Parent or SettingsMenu.ScrollingFrame

	local BackgroundUICorner = Instance.new("UICorner")
	BackgroundUICorner.CornerRadius = UDim.new(0.05, 0)
    BackgroundUICorner.Parent = Background

	local ColorPickerBackground = Instance.new("ImageButton")
	ColorPickerBackground.AutoButtonColor = false
	ColorPickerBackground.Active = true
	ColorPickerBackground.BackgroundTransparency = 1
	ColorPickerBackground.Image = "rbxassetid://1072518406"
	ColorPickerBackground.Size = UDim2.fromScale(0.45, 0.62)
	ColorPickerBackground.Position = UDim2.fromScale(0.487, 0.044)
	ColorPickerBackground.BorderSizePixel = 0
	ColorPickerBackground.ClipsDescendants = true
	ColorPickerBackground.ZIndex = Background.ZIndex
	ColorPickerBackground.Name = "ColorPickerBackground"
    ColorPickerBackground.Parent = Background
	
	local ColorPickerArrow = Instance.new("Frame")
	ColorPickerArrow.BackgroundTransparency = 1
	ColorPickerArrow.Size = UDim2.fromScale(0.1, 0.1)
	ColorPickerArrow.Position = UDim2.fromScale(0.95, 0.95)
	ColorPickerArrow.Name = "Arrow"
    ColorPickerArrow.Parent = ColorPickerBackground

	local HorizontalArrow = Instance.new("Frame")
	HorizontalArrow.Size = UDim2.fromScale(1, 0.125)
	HorizontalArrow.Position = UDim2.fromScale(0, 0.438)
	HorizontalArrow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	HorizontalArrow.BorderSizePixel = 0
	HorizontalArrow.ZIndex = Background.ZIndex
	HorizontalArrow.Name = "HorizontalArrow"
    HorizontalArrow.Parent = ColorPickerArrow

	local VerticalArrow = Instance.new("Frame")
	VerticalArrow.Size = UDim2.fromScale(0.125, 1)
	VerticalArrow.Position = UDim2.fromScale(0.438, 0)
	VerticalArrow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	VerticalArrow.BorderSizePixel = 0
	VerticalArrow.ZIndex = Background.ZIndex
	VerticalArrow.Name = "VerticalArrow"
    VerticalArrow.Parent = ColorPickerArrow

    local ColorPickerArrowUIDragDetector = Instance.new("UIDragDetector")
    ColorPickerArrowUIDragDetector.ResponseStyle = Enum.UIDragDetectorResponseStyle.Scale
    ColorPickerArrowUIDragDetector.BoundingUI = ColorPickerBackground
    ColorPickerArrowUIDragDetector.BoundingBehavior = Enum.UIDragDetectorBoundingBehavior.HitPoint
    ColorPickerArrowUIDragDetector.Parent = ColorPickerArrow

	local H, S, V = 0, 0, 1
	local Color = Color3.fromHSV(H, S, V)

	local Function = Properties.Function

	local ColorStrip = Instance.new("ImageButton")
	ColorStrip.AutoButtonColor = false
	ColorStrip.Active = true
	ColorStrip.BackgroundTransparency = 1
	ColorStrip.Image = "rbxassetid://1072518502"
	ColorStrip.Size = UDim2.fromScale(0.015, 0.62)
	ColorStrip.Position = UDim2.fromScale(0.96, 0.05)
	ColorStrip.BorderSizePixel = 0
	ColorStrip.ZIndex = Background.ZIndex
	ColorStrip.Name = "ColorStrip"
    ColorStrip.Parent = Background
	
	local Arrow = Instance.new("Frame")
	Arrow.BackgroundTransparency = 1
	Arrow.Name = "Arrow"
	Arrow.Position = UDim2.fromScale(1, -0.05)
	Arrow.Size = UDim2.new(1, 0, 0, 9)
	Arrow.Selectable = false
	Arrow.ZIndex = Background.ZIndex
    Arrow.Parent = ColorStrip

	local Frame1 = Instance.new("Frame")
	Frame1.BorderColor3 = Color3.new(0.105882, 0.164706, 0.207843)
	Frame1.BorderSizePixel = 0
	Frame1.Name = "Frame1"
	Frame1.Position = UDim2.fromOffset(2, 4)
	Frame1.Size = UDim2.fromOffset(1, 1)
	Frame1.ZIndex = Arrow.ZIndex
	Frame1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Frame1.ZIndex = Arrow.ZIndex
    Frame1.Parent = Arrow

	local Frame2 = Instance.new("Frame")
	Frame2.BorderColor3 = Color3.new(0.105882, 0.164706, 0.207843)
	Frame2.BorderSizePixel = 0
	Frame2.Name = "Frame2"
	Frame2.Position = UDim2.fromOffset(3, 3)
	Frame2.Size = UDim2.fromOffset(1, 3)
	Frame2.ZIndex = Arrow.ZIndex
	Frame2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Frame2.ZIndex = Arrow.ZIndex
    Frame2.Parent = Arrow

	local Frame3 = Instance.new("Frame")
	Frame3.BorderColor3 = Color3.new(0.105882, 0.164706, 0.207843)
	Frame3.BorderSizePixel = 0
	Frame3.Name = "Frame3"
	Frame3.Position = UDim2.fromOffset(4, 2)
	Frame3.Size = UDim2.fromOffset(1, 5)
	Frame3.ZIndex = Arrow.ZIndex
	Frame3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Frame3.ZIndex = Arrow.ZIndex
    Frame3.Parent = Arrow

	local Frame4 = Instance.new("Frame")
	Frame4.BorderColor3 = Color3.new(0.105882, 0.164706, 0.207843)
	Frame4.BorderSizePixel = 0
	Frame4.Name = "Frame4"
	Frame4.Position = UDim2.fromOffset(5, 1)
	Frame4.Size = UDim2.fromOffset(1, 7)
	Frame4.ZIndex = Arrow.ZIndex
	Frame4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Frame4.ZIndex = Arrow.ZIndex
    Frame4.Parent = Arrow

	local Frame5 = Instance.new("Frame")
	Frame5.BorderColor3 = Color3.new(0.105882, 0.164706, 0.207843)
	Frame5.BorderSizePixel = 0
	Frame5.Name = "Frame5"
	Frame5.Position = UDim2.fromOffset(6, 0)
	Frame5.Size = UDim2.fromOffset(1, 9)
	Frame5.ZIndex = Arrow.ZIndex
	Frame5.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Frame5.ZIndex = Arrow.ZIndex
    Frame5.Parent = Arrow

	local Hue = Instance.new("Frame")
	Hue.BackgroundColor3 = Color3.new(Background.BackgroundColor3.R - 5, Background.BackgroundColor3.G - 5, Background.BackgroundColor3.B - 5)
	Hue.BorderColor3 = Color3.new(0.376471, 0.376471, 0.376471)
	Hue.Name = "Hue"
	Hue.Position = UDim2.fromScale(0.675, 0.7)
	Hue.Size = UDim2.fromScale(0.1, 0.05)
	Hue.ZIndex = Background.ZIndex
    Hue.Parent = Background

	local HueInput = Instance.new("TextBox")
	HueInput.BackgroundTransparency = 1
	HueInput.BorderColor3 = Color3.fromRGB(96, 96, 96)
	HueInput.TextColor3 = Color3.fromRGB(255, 255, 255)
	HueInput.ZIndex = Background.ZIndex
	HueInput.TextXAlignment = Enum.TextXAlignment.Left
	HueInput.ClearTextOnFocus = false
	HueInput.Name = "Input"
	HueInput.Size = UDim2.fromScale(0.9, 0.9)
	HueInput.Position = UDim2.fromScale(0.05, 0.05)
	HueInput.TextScaled = true
	HueInput.Text = "0"
	HueInput.Font = TextFont
    HueInput.Parent = Hue

	local HueTitle = Instance.new("TextLabel")
	HueTitle.BackgroundTransparency = 1
	HueTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
	HueTitle.ZIndex = Background.ZIndex
	HueTitle.Name = "Title"
	HueTitle.Text = "Hue: "
	HueTitle.TextScaled = true
	HueTitle.Size = UDim2.fromScale(0.75, 0.865)
	HueTitle.Position = UDim2.fromScale(-0.75, 0.0675)
	HueTitle.Font = TextFont
    HueTitle.Parent = Hue
	
	local Saturation = Instance.new("Frame")
	Saturation.BackgroundColor3 =  Color3.new(Background.BackgroundColor3.R - 5, Background.BackgroundColor3.G - 5, Background.BackgroundColor3.B - 5)
	Saturation.BackgroundTransparency = 0
	Saturation.BorderColor3 = Color3.new(0.376471, 0.376471, 0.376471)
	Saturation.BorderSizePixel = 1
	Saturation.Name = "Saturation"
	Saturation.Position = UDim2.fromScale(0.675, 0.775)
	Saturation.Size = UDim2.fromScale(0.1, 0.05)
	Saturation.ZIndex = Background.ZIndex
    Saturation.Parent = Background

	local SaturationInput = Instance.new("TextBox")
	SaturationInput.BackgroundTransparency = 1
	SaturationInput.BorderColor3 = Color3.fromRGB(96, 96, 96)
	SaturationInput.TextColor3 = Color3.fromRGB(255, 255, 255)
	SaturationInput.ZIndex = Background.ZIndex
	SaturationInput.TextXAlignment = Enum.TextXAlignment.Left
	SaturationInput.ClearTextOnFocus = false
	SaturationInput.Name = "Input"
	SaturationInput.Size = UDim2.fromScale(0.9, 0.9)
	SaturationInput.Position = UDim2.fromScale(0.05, 0.05)
	SaturationInput.TextScaled = true
	SaturationInput.Text = "0"
	SaturationInput.Font = TextFont
    SaturationInput.Parent = Saturation

	local SaturationTitle = Instance.new("TextLabel")
	SaturationTitle.BackgroundTransparency = 1
	SaturationTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
	SaturationTitle.ZIndex = Background.ZIndex
	SaturationTitle.Name = "Title"
	SaturationTitle.Text = "Sat: "
	SaturationTitle.TextScaled = true
	SaturationTitle.Size = UDim2.fromScale(0.75, 0.865)
	SaturationTitle.Position = UDim2.fromScale(-0.75, 0.0675)
	SaturationTitle.Font = TextFont
    SaturationTitle.Parent = Saturation

	local Val = Instance.new("Frame")
	Val.BackgroundColor3 = Color3.new(Background.BackgroundColor3.R - 5, Background.BackgroundColor3.G - 5, Background.BackgroundColor3.B - 5)
	Val.BackgroundTransparency = 0
	Val.BorderColor3 = Color3.new(0.376471, 0.376471, 0.376471)
	Val.BorderSizePixel = 1
	Val.Name = "Val"
	Val.Position = UDim2.fromScale(0.675, 0.85)
	Val.Size = UDim2.fromScale(0.1, 0.05)
	Val.ZIndex = Background.ZIndex
    Val.Parent = Background

	local ValTitle = Instance.new("TextLabel")
	ValTitle.BackgroundTransparency = 1
	ValTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
	ValTitle.ZIndex = Background.ZIndex
	ValTitle.Name = "Title"
	ValTitle.Text = "Val: "
	ValTitle.TextScaled = true
	ValTitle.Size = UDim2.fromScale(0.75, 0.865)
	ValTitle.Position = UDim2.fromScale(-0.75, 0.0675)
	ValTitle.Font = TextFont
    ValTitle.Parent = Val

	local ValInput = Instance.new("TextBox")
	ValInput.BackgroundTransparency = 1
	ValInput.BorderColor3 = Color3.fromRGB(96, 96, 96)
	ValInput.TextColor3 = Color3.fromRGB(255, 255, 255)
	ValInput.ZIndex = Background.ZIndex
	ValInput.TextXAlignment = Enum.TextXAlignment.Left
	ValInput.ClearTextOnFocus = false
	ValInput.Name = "Input"
	ValInput.Size = UDim2.fromScale(0.9, 0.9)
	ValInput.Position = UDim2.fromScale(0.05, 0.05)
	ValInput.TextScaled = true
	ValInput.Text = "255"
	ValInput.Font = TextFont
    ValInput.Parent = Val

	local Hex = Instance.new("Frame")
	Hex.BackgroundColor3 = Color3.new(Background.BackgroundColor3.R - 5, Background.BackgroundColor3.G - 5, Background.BackgroundColor3.B - 5)
	Hex.BackgroundTransparency = 0
	Hex.BorderColor3 = Color3.new(0.376471, 0.376471, 0.376471)
	Hex.BorderSizePixel = 1
	Hex.Name = "Hex"
	Hex.Position = UDim2.fromScale(0.675, 0.92)
	Hex.Size = UDim2.fromScale(0.3, 0.05)
	Hex.ZIndex = Background.ZIndex
    Hex.Parent = Background

	local HexTitle = Instance.new("TextLabel")
	HexTitle.BackgroundTransparency = 1
	HexTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
	HexTitle.ZIndex = Background.ZIndex
	HexTitle.Name = "Title"
	HexTitle.Text = "Hex: "
	HexTitle.TextScaled = true
	HexTitle.Size = UDim2.fromScale(0.229, 0.865)
	HexTitle.Position = UDim2.fromScale(-0.229, 0.0675)
	HexTitle.Font = TextFont
    HexTitle.Parent = Hex

	local HexInput = Instance.new("TextBox")
	HexInput.BackgroundTransparency = 1
	HexInput.BorderColor3 = Color3.fromRGB(96, 96, 96)
	HexInput.TextColor3 = Color3.fromRGB(255, 255, 255)
	HexInput.ZIndex = Background.ZIndex
	HexInput.TextXAlignment = Enum.TextXAlignment.Left
	HexInput.ClearTextOnFocus = false
	HexInput.Name = "Input"
	HexInput.Size = UDim2.fromScale(0.9, 0.9)
	HexInput.Position = UDim2.fromScale(0.05, 0.05)
	HexInput.TextScaled = true
	HexInput.Text = "#ffffff"
	HexInput.Font = TextFont
    HexInput.Parent = Hex

	local Red = Instance.new("Frame")
	Red.BackgroundColor3 = Color3.new(Background.BackgroundColor3.R - 5, Background.BackgroundColor3.G - 5, Background.BackgroundColor3.B - 5)
	Red.BackgroundTransparency = 0
	Red.BorderColor3 = Color3.new(0.376471, 0.376471, 0.376471)
	Red.BorderSizePixel = 1
	Red.Name = "Red"
	Red.Position = UDim2.fromScale(0.875, 0.7)
	Red.Size = UDim2.fromScale(0.1, 0.05)
	Red.ZIndex = Background.ZIndex
    Red.Parent = Background

	local RedTitle = Instance.new("TextLabel")
	RedTitle.BackgroundTransparency = 1
	RedTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
	RedTitle.ZIndex = Background.ZIndex
	RedTitle.Name = "Title"
	RedTitle.Text = "Red: "
	RedTitle.TextScaled = true
	RedTitle.Size = UDim2.fromScale(0.75, 0.865)
	RedTitle.Position = UDim2.fromScale(-0.75, 0.0675)
	RedTitle.Font = TextFont
    RedTitle.Parent = Red

	local RedInput = Instance.new("TextBox")
	RedInput.BackgroundTransparency = 1
	RedInput.BorderColor3 = Color3.fromRGB(96, 96, 96)
	RedInput.TextColor3 = Color3.fromRGB(255, 255, 255)
	RedInput.ZIndex = Background.ZIndex
	RedInput.TextXAlignment = Enum.TextXAlignment.Left
	RedInput.ClearTextOnFocus = false
	RedInput.Name = "Input"
	RedInput.Size = UDim2.fromScale(0.9, 0.9)
	RedInput.Position = UDim2.fromScale(0.05, 0.05)
	RedInput.TextScaled = true
	RedInput.Text = "255"
	RedInput.Font = TextFont
    RedInput.Parent = Red
    
	local Green = Instance.new("Frame")
	Green.BackgroundColor3 = Color3.new(Background.BackgroundColor3.R - 5, Background.BackgroundColor3.G - 5, Background.BackgroundColor3.B - 5)
	Green.BackgroundTransparency = 0
	Green.BorderColor3 = Color3.new(0.376471, 0.376471, 0.376471)
	Green.BorderSizePixel = 1
	Green.Name = "Green"
	Green.Position = UDim2.fromScale(0.875, 0.775)
	Green.Size = UDim2.fromScale(0.1, 0.05)
	Green.ZIndex = Background.ZIndex
    Green.Parent = Background

	local GreenTitle = Instance.new("TextLabel")
	GreenTitle.BackgroundTransparency = 1
	GreenTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
	GreenTitle.ZIndex = Background.ZIndex
	GreenTitle.Name = "Title"
	GreenTitle.Text = "Green: "
	GreenTitle.TextScaled = true
	GreenTitle.Size = UDim2.fromScale(0.75, 0.865)
	GreenTitle.Position = UDim2.fromScale(-0.75, 0.0675)
	GreenTitle.Font = TextFont
    GreenTitle.Parent = Green

	local GreenInput = Instance.new("TextBox")
	GreenInput.BackgroundTransparency = 1
	GreenInput.BorderColor3 = Color3.fromRGB(96, 96, 96)
	GreenInput.TextColor3 = Color3.fromRGB(255, 255, 255)
	GreenInput.ZIndex = Background.ZIndex
	GreenInput.TextXAlignment = Enum.TextXAlignment.Left
	GreenInput.ClearTextOnFocus = false
	GreenInput.Name = "Input"
	GreenInput.Size = UDim2.fromScale(0.9, 0.9)
	GreenInput.Position = UDim2.fromScale(0.05, 0.05)
	GreenInput.TextScaled = true
	GreenInput.Text = "255"
	GreenInput.Font = TextFont
    GreenInput.Parent = Green

	local Blue = Instance.new("Frame")
	Blue.BackgroundColor3 = Color3.new(Background.BackgroundColor3.R - 5, Background.BackgroundColor3.G - 5, Background.BackgroundColor3.B - 5)
	Blue.BackgroundTransparency = 0
	Blue.BorderColor3 = Color3.new(0.376471, 0.376471, 0.376471)
	Blue.BorderSizePixel = 1
	Blue.Name = "Blue"
	Blue.Position = UDim2.fromScale(0.875, 0.85)
	Blue.Size = UDim2.fromScale(0.1, 0.05)
	Blue.ZIndex = Background.ZIndex
    Blue.Parent = Background

	local BlueTitle = Instance.new("TextLabel")
	BlueTitle.BackgroundTransparency = 1
	BlueTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
	BlueTitle.ZIndex = Background.ZIndex
	BlueTitle.Name = "Title"
	BlueTitle.Text = "Blue: "
	BlueTitle.TextScaled = true
	BlueTitle.Size = UDim2.fromScale(0.75, 0.865)
	BlueTitle.Position = UDim2.fromScale(-0.75, 0.0675)
	BlueTitle.Font = TextFont
    BlueTitle.Parent = Blue

	local BlueInput = Instance.new("TextBox")
	BlueInput.BackgroundTransparency = 1
	BlueInput.BorderColor3 = Color3.fromRGB(96, 96, 96)
	BlueInput.TextColor3 = Color3.fromRGB(255, 255, 255)
	BlueInput.ZIndex = Background.ZIndex
	BlueInput.TextXAlignment = Enum.TextXAlignment.Left
	BlueInput.ClearTextOnFocus = false
	BlueInput.Name = "Input"
	BlueInput.Size = UDim2.fromScale(0.9, 0.9)
	BlueInput.Position = UDim2.fromScale(0.05, 0.05)
	BlueInput.TextScaled = true
	BlueInput.Text = "255"
	BlueInput.Font = TextFont
    BlueInput.Parent = Blue

	local Preview = Instance.new("Frame")
	Preview.BorderSizePixel = 0
	Preview.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Preview.Size = UDim2.fromScale(0.1, 0.263)
	Preview.Position = UDim2.fromScale(0.487, 0.7)
	Preview.Name = "Preview"
    Preview.Parent = Background

	local NameLabel = Instance.new("TextLabel")
	NameLabel.Size = UDim2.fromScale(0.4, 0.06)
	NameLabel.Position = UDim2.fromScale(0.05, 0.043)
	NameLabel.BackgroundTransparency = 1
	NameLabel.Name = "NameLabel"
	NameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	NameLabel.Text = Properties.Text or Properties.Name
	NameLabel.TextScaled = true
    NameLabel.Parent = Background

	local function UpdateText()
		HueInput.Text = math.round(H * 255)
		SaturationInput.Text = math.round(S * 255)
		ValInput.Text = math.round(V * 255)
		RedInput.Text = tostring(math.round(Color.R * 255))
		GreenInput.Text = tostring(math.round(Color.G * 255))
		BlueInput.Text = tostring(math.round(Color.B * 255))
		HexInput.Text = "#" .. tostring(Color:ToHex())
	end
	
	local function UpdateDisplay()
		Preview.BackgroundColor3 = Color
	end

	local R, G, B = 255, 255, 255
	local gSubbedText = (`{Properties.ModuleName or ""}_{Properties.Text or ""}`):gsub(" ", "")
	
	local function UpdateRGB()
        local Red, Green, Blue = tonumber(RedInput.Text), tonumber(GreenInput.Text), tonumber(BlueInput.Text)
		if Red then
            R = math.clamp(Red, 0, 255)
        end
        if Green then
            G = math.clamp(Green, 0, 255)
        end
        if Blue then
            B = math.clamp(Blue, 0, 255)
        end
		H, S, V = Color3.fromRGB(R, G, B):ToHSV()
		Color = Color3.fromHSV(H, S, V)
		ColorPickerArrow.Position = UDim2.fromScale(math.clamp(0.95 - H, -0.05, 0.95), math.clamp(0.95 - S, -0.05, 0.95))
		Arrow.Position = UDim2.fromScale(Arrow.Position.X.Scale, math.clamp(0.95 - V, -0.05, 0.95))
		UpdateText()
		UpdateDisplay()
		Values[gSubbedText].Color = Color
	end

	ColorPickerBackground.MouseButton1Down:Connect(function()
		while UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) and not StopScript do
			RunService.RenderStepped:Wait()
            local X = ((Mouse.X - ColorPickerBackground.AbsolutePosition.X) / ColorPickerBackground.AbsoluteSize.X) - ColorPickerArrow.AbsoluteSize.X * 0.5 / ColorPickerBackground.AbsoluteSize.X
            local XMin = 0 - ColorPickerArrow.AbsoluteSize.X * 0.5 / ColorPickerBackground.AbsoluteSize.X
            local XMax = 1 - ColorPickerArrow.AbsoluteSize.X * 0.5 / ColorPickerBackground.AbsoluteSize.X
            X = math.clamp(X, XMin, XMax)
            local Y = ((Mouse.Y - ColorPickerBackground.AbsolutePosition.Y) / ColorPickerBackground.AbsoluteSize.Y) - ColorPickerArrow.AbsoluteSize.Y * 0.5 / ColorPickerBackground.AbsoluteSize.Y
            local YMin = 0 - ColorPickerArrow.AbsoluteSize.Y * 0.5 / ColorPickerBackground.AbsoluteSize.Y
            local YMax = 1 - ColorPickerArrow.AbsoluteSize.Y * 0.5 / ColorPickerBackground.AbsoluteSize.Y
            Y = math.clamp(Y, YMin, YMax)
			ColorPickerArrow.Position = UDim2.fromScale(X, Y)
			H = math.clamp((0.95 - ColorPickerArrow.Position.X.Scale) * 1.033, 0, 1)
			S = math.clamp((0.95 - ColorPickerArrow.Position.Y.Scale) * 1.033, 0, 1)
			Color = Color3.fromHSV(H, S, V)
            Values[gSubbedText].Color = Color
			UpdateText()
			UpdateDisplay()
			Function(Color)
		end
	end)
	
	ColorStrip.MouseButton1Down:Connect(function()
		while UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) and not StopScript do
			RunService.RenderStepped:Wait()
            local Y = ((Mouse.Y - ColorStrip.AbsolutePosition.Y) / ColorStrip.AbsoluteSize.Y) - (Arrow.AbsoluteSize.Y * 0.5) / ColorStrip.AbsoluteSize.Y
            local Min = 0 - (Arrow.AbsoluteSize.Y * 0.5) / ColorStrip.AbsoluteSize.Y
            local Max = 1 - (Arrow.AbsoluteSize.Y * 0.5) / ColorStrip.AbsoluteSize.Y
			Arrow.Position = UDim2.fromScale(1, math.clamp(Y, Min, Max))
			V = math.clamp((0.95 - Arrow.Position.Y.Scale)  * 1.033, 0, 1)
			Color = Color3.fromHSV(H, S, V)
            Values[gSubbedText].Color = Color
			UpdateText()
			UpdateDisplay()
			Function(Color)
		end
	end)
	
	HueInput.FocusLost:Connect(function()
        local HueText = tonumber(HueInput.Text)
		if HueText then
			H = math.clamp(HueText / 255, 0, 1)
		end
		ColorPickerArrow.Position = UDim2.fromScale(math.clamp(0.95 - H, -0.05, 0.95), ColorPickerArrow.Position.Y.Scale)
		Color = Color3.fromHSV(H, S, V)
        Values[gSubbedText].Color = Color
		Function(Color)
	end)

	SaturationInput.FocusLost:Connect(function()
        local Saturation = tonumber(SaturationInput.Text)
		if Saturation then
			S = math.clamp(Saturation, 0, 255)
		end
		ColorPickerArrow.Position = UDim2.fromScale(ColorPickerArrow.Position.X.Scale, math.clamp(0.95 - S, -0.05, 0.95))
		Color = Color3.fromHSV(H, S, V)
        Values[gSubbedText].Color = Color
		Function(Color)
	end)

	ValInput.FocusLost:Connect(function()
        local Val = tonumber(ValInput.Text)
		if Val then
			V = math.clamp(Val, 0, 255)
		end
		Arrow.Position = UDim2.fromScale(Arrow.Position.X.Scale, math.clamp(0.95 - V, -0.05, 0.95))
		Color = Color3.fromHSV(H, S, V)
        Values[gSubbedText].Color = Color
		Function(Color)
	end)

	RedInput.FocusLost:Connect(function()
		UpdateRGB()
		Function(Color)
	end)

	GreenInput.FocusLost:Connect(function()
		UpdateRGB()
		Function(Color)
	end)

	BlueInput.FocusLost:Connect(function()
		UpdateRGB()
		Function(Color)
	end)

    local Functions = {
        MainFrame = Background,
        Background = Background,
    }

    function Functions:SetColor(Color)
        RedInput.Text = tostring(Color.R * 255)
        GreenInput.Text = tostring(Color.G * 255)
        BlueInput.Text = tostring(Color.B * 255)
        UpdateRGB()
        Function(Color)
    end

	Values[gSubbedText] = {
		Color = Properties.Default or Properties.DefaultColor or Color3.fromRGB(255, 255, 255),
        SetColor = Functions.SetColor,
	}
	
	Functions:SetColor(Values[gSubbedText].Color)

	return Functions
end

function ClearSettings()
	for i, v in ipairs(SettingsMenu.ScrollingFrame:GetChildren()) do
		if v:IsA("TextButton") or v:IsA("TextBox") or v:IsA("Frame") or v:IsA("ImageButton") then
			v.Visible = false
		end
	end
end

do
	local TeleportCheck = false
	Connections.TidalWave.QueueOnTeleportConnection = Plr.OnTeleport:Connect(function()
		if StopScript then return end
		if KeepTidalWave and QueueOnTeleport and not TeleportCheck then
			TeleportCheck = true
            Connections.TidalWave.QueueOnTeleportConnection:Disconnect()
            Connections.TidalWave.QueueOnTeleportConnection = nil
			QueueOnTeleport("loadfile('TidalWave.lua')()")
		end
	end)
end

function SetClipboard(String, Message)
	if ClipboardFunc then
        String = tostring(String)
		if String then 
			ClipboardFunc(String)
			if Message then
				Notify({
					Text = Message,
				})
			else
				Notify({
					Text = "Copied " .. String .. " To SetClipboard",
				})
			end
		end
	else
		Notify({
			Text = 'Your Exploit Doesnt Support Support "SetClipboard"',
		})
	end
end

function GetFullName(Object)
	if Object == game then return game end
	if typeof(Object) ~= "Instance" then return nil end
	if game:FindFirstChildOfClass(Object.ClassName) and Object.ClassName ~= "" then
		return `game:GetService("{Object.ClassName}")`
    elseif Object.ClassName == "" then
        return `game:GetChildren()[{table.find(game:GetChildren(), Object)}]`
	end
    
	local FullName = ""
	local Period = false
	local SpecialCharacter = false
	local UsedGetChildren = false
	local SpecialCharacters = {
		";",
		":",
		"'",
		"\"",
        "`",
		"%[",
		"%]",
		"%{",
		"%}",
		"/",
		"\\",
		"-",
		"+",
		"%.",
		"!",
		"@",
		"#",
		"%$",
		"%%",
		"%^",
		"&",
		"*",
		"%(",
		"%)",
		"=",
		"<",
		">",
		"?",
        "|",
        ",",
        "nil",
        "for",
        "do",
        "while",
        "true",
        "false",
        "repeat",
        "until",
        "and",
        "or",
        "not",
        "local",
        "function",
        "if",
        "then",
        "return",
        "end",
        "break",
        "continue",
        "else",
        "elseif",
        "in",
        "self",
	}
    
	local Parent = Object
    
    while Parent.Parent ~= game do
        local FoundChild = Parent.Parent:FindFirstChild(Parent.Name)
        local PossiblePropertyChild = FoundChild and Parent.Parent[Parent.Name] or nil
        if Parent.Parent.Name ~= "" and FoundChild == Parent and PossiblePropertyChild == Parent then
            local Name = Parent.Name:gsub("\\", "\\\\"):gsub("\"", "\\\""):gsub("\n", "\\n")
            local FirstChar = Name:sub(1, 1)
            for i, v in ipairs(SpecialCharacters) do
                local Start, End = Name:find(v)
                if i >= 30 and Start and End then
                    if Start == 1 then
                        SpecialCharacter = true
                    end
                elseif Start and End then
                    SpecialCharacter = true
                end
            end
            for i = 1, 31 do
                local Char = string.char(i)
                if Name:find(Char) then
                    Name = Name:gsub(Char, `\\{i}`)
                    SpecialCharacter = true
                end
            end
            if Name:find(" ") or tonumber(FirstChar) or SpecialCharacter then
                if Period and not UsedGetChildren then
                    FullName = `["{Name}"].{FullName}`
                else
                    FullName = `["{Name}"]{FullName}`
                end
                Period = false
            else
                if Period and not UsedGetChildren then
                    FullName = `{Name}.{FullName}`
                else
                    FullName = `{Name}{FullName}`
                end
                Period = true
            end
            UsedGetChildren = false
        elseif FoundChild and typeof(PossiblePropertyChild) ~= "Instance" then
            if Period and not UsedGetChildren then
                FullName = `:FindFirstChild("{Parent}").{FullName}`
            else
                FullName = `:FindFirstChild("{Parent}"){FullName}`
            end
            Period = false
            UsedGetChildren = true
        else
            if Period and not UsedGetChildren then
                FullName = `:GetChildren()[{table.find(Parent.Parent:GetChildren(), Parent)}].{FullName}`
            else
                FullName = `:GetChildren()[{table.find(Parent.Parent:GetChildren(), Parent)}]{FullName}`
            end
            Period = false
            UsedGetChildren = true
        end
        Parent = Parent.Parent
        SpecialCharacter = false
    end

    if Period then
        FullName = `game:GetService("{Parent}").{FullName}`
    else
        FullName = `game:GetService("{Parent}"){FullName}`
    end

    return FullName
end

function GetChar(Player)
	if typeof(Player) ~= "Instance" then return end
	if not Player:IsA("Player") then return end
	local Char = Player.Character or workspace:FindFirstChild(Player.Name)
	return Char
end

function GetHumanoid(Char)
	if typeof(Char) ~= "Instance" then return end
	local Humanoid = Char:FindFirstChildWhichIsA("Humanoid")
	return Humanoid
end

function GetRoot(Char)
    if typeof(Char) ~= "Instance" then return end
    local Humanoid = GetHumanoid(Char)
	local BasePart = (Char:IsA("BasePart") and Char) or Char:FindFirstChildWhichIsA("BasePart")
	local Root = Char:FindFirstChild("HumanoidRootPart") or Char:FindFirstChild("RootPart") or Char:FindFirstChild("Root") or Char:FindFirstChild("PrimaryPart") or (Humanoid and Humanoid.RootPart) or Char:FindFirstChild("UpperTorso") or Char:FindFirstChild("LowerTorso") or (Char:IsA("Model") and Char.PrimaryPart) or (BasePart and BasePart.AssemblyRootPart)
	return Root
end

function R15(Player)
	local Char = GetChar(Player)
	local Humanoid = GetHumanoid(Char)

	if not (Humanoid and Char) then return nil end

	if Humanoid.RigType == Enum.HumanoidRigType.R15 then
		return true
	end
    return false
end

function ChatMessage(Str)
	Str = tostring(Str)
    if not Str then return end
    local Success, RBXGeneral = pcall(function()
        return TextChatService.TextChannels.RBXGeneral
    end)
    if Success then
        RBXGeneral:SendAsync(Str)
    end
end

function GetClosestModel(Folder)
    if not Folder then return nil end

	local ClosestModel
	local ClosestModelDistance = math.huge
	local Char = GetChar(Plr)
	local Root = GetRoot(Char)

	if not (Char and Root) then return nil end

	for i, v in pairs(Folder:GetChildren()) do
        local ModelRoot = GetRoot(v)
		if ModelRoot and (Root.Position - ModelRoot.Position).Magnitude < ClosestModelDistance then
			ClosestModel = v
			ClosestModelDistance = (Root.Position - ModelRoot.Position).Magnitude
		end
	end

	return ClosestModel
end

function WaitForChildOfClass(self, Class, TimeOut)
	if typeof(self) ~= "Instance" or typeof(Class) ~= "string" then
		return nil
	end

	local FoundChild = self:FindFirstChildOfClass(Class)
	if FoundChild then
		return FoundChild
	end

	local Thread = coroutine.running()
	local Finished = false
	local Result
	
	local Connection; Connection = self.ChildAdded:Connect(function(Obj)
		if Obj.ClassName == Class and not Finished then
			Finished = true
			Result = Obj
			Connection:Disconnect()
			if coroutine.status(Thread) == "suspended" then
				coroutine.resume(Thread, Result)
			end
		end
	end)
	
	if TimeOut then
		task.delay(TimeOut, function()
			if not Finished then
				Finished = true
				if Connection.Connected then
					Connection:Disconnect()
				end
				if coroutine.status(Thread) == "suspended" then
					coroutine.resume(Thread, nil)
				end
			end
		end)
	end
	
	return coroutine.yield()
end

function WaitForChildWhichIsA(self, Class, TimeOut)
	if typeof(self) ~= "Instance" or typeof(Class) ~= "string" then
		return nil
	end

	local FoundChild = self:FindFirstChildWhichIsA(Class)
	if FoundChild then
		return FoundChild
	end

	local Thread = coroutine.running()
	local Finished = false
	local Result
	
	local Connection; Connection = self.ChildAdded:Connect(function(Obj)
		if Obj:IsA(Class) and not Finished then
			Finished = true
			Result = Obj
			Connection:Disconnect()
			if coroutine.status(Thread) == "suspended" then
				coroutine.resume(Thread, Result)
			end
		end
	end)
	
	if TimeOut then
		task.delay(TimeOut, function()
			if not Finished then
				Finished = true
				if Connection.Connected then
					Connection:Disconnect()
				end
				if coroutine.status(Thread) == "suspended" then
					coroutine.resume(Thread, nil)
				end
			end
		end)
	end
	
	return coroutine.yield()
end

FreecamRunning = false
Connections.TidalWave.CurrentCameraChangedConnection = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	local NewCamera = workspace.CurrentCamera
	if NewCamera then
		Camera = NewCamera
	end
end)

do
    local PrevFov = if Camera then Camera.FieldOfView else 70

    function StopFreecam()
        FreecamRunning = false
        if Connections.TidalWave.FreecamInputBeganConnection then
            Connections.TidalWave.FreecamInputBeganConnection:Disconnect()
            Connections.TidalWave.FreecamInputBeganConnection = nil
        end
        if Connections.TidalWave.FreecamInputEndedConnection then
            Connections.TidalWave.FreecamInputEndedConnection:Disconnect()
            Connections.TidalWave.FreecamInputEndedConnection = nil
        end
        if Connections.TidalWave.FreecamInputChangedConnection then
            Connections.TidalWave.FreecamInputChangedConnection:Disconnect()
            Connections.TidalWave.FreecamInputChangedConnection = nil
        end
        if Connections.TidalWave.FreecamRenderSteppedConnection then
            Connections.TidalWave.FreecamRenderSteppedConnection:Disconnect()
            Connections.TidalWave.FreecamRenderSteppedConnection = nil
        end
        local Success, ControlModule = pcall(function()
            return require(Plr.PlayerScripts.PlayerModule.ControlModule)
        end)
        if Success then
            ControlModule:Enable()
        end
        if Camera then
            Camera.FieldOfView = PrevFov
        end
    end

    function StartFreecam(CF)
        if FreecamRunning then StopFreecam() end
        FreecamRunning = true
        CF = if CF then CF elseif Camera then Camera.CFrame else CFrame.new(0, 0, 0)
        local FreecamFov = if Camera then Camera.FieldOfView else 70
        PrevFov = FreecamFov
        local Vel = Vector3.new(0, 0, 0)
        local Rotation = Vector2.new(0, 0)
        local MouseDelta = Vector2.new(0, 0)

        Connections.TidalWave.FreecamInputBeganConnection = UIS.InputBegan:Connect(function(Input, Proc)
            if ChatboxFocused() or TidalWaveFocused then return end
            if Input.KeyCode == Enum.KeyCode.W then
                Vel += Vector3.new(0, 0, -1)
            elseif Input.KeyCode == Enum.KeyCode.A then
                Vel += Vector3.new(-1, 0, 0)
            elseif Input.KeyCode == Enum.KeyCode.S then
                Vel += Vector3.new(0, 0, 1)
            elseif Input.KeyCode == Enum.KeyCode.D then
                Vel += Vector3.new(1, 0, 0)
            elseif Input.KeyCode == Enum.KeyCode.E then
                Vel += Vector3.new(0, 1, 0)
            elseif Input.KeyCode == Enum.KeyCode.Q then
                Vel += Vector3.new(0, -1, 0)
            end
        end)

        Connections.TidalWave.FreecamInputEndedConnection = UIS.InputEnded:Connect(function(Input, Proc)
            if ChatboxFocused() or TidalWaveFocused then return end
            if Input.KeyCode == Enum.KeyCode.W then
                Vel += Vector3.new(0, 0, 1)
            elseif Input.KeyCode == Enum.KeyCode.A then
                Vel += Vector3.new(1, 0, 0)
            elseif Input.KeyCode == Enum.KeyCode.S then
                Vel += Vector3.new(0, 0, -1)
            elseif Input.KeyCode == Enum.KeyCode.D then
                Vel += Vector3.new(-1, 0, 0)
            elseif Input.KeyCode == Enum.KeyCode.E then
                Vel += Vector3.new(0, -1, 0)
            elseif Input.KeyCode == Enum.KeyCode.Q then
                Vel += Vector3.new(0, 1, 0)
            end
        end)
        
        local Success, ControlModule = pcall(function()
            return require(Plr.PlayerScripts.PlayerModule.ControlModule)
        end)
        if Success then
            ControlModule:Disable()
        end
        
        Connections.TidalWave.FreecamInputChangedConnection = UIS.InputChanged:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseWheel then
                FreecamFov = math.clamp(FreecamFov - (Input.Position.Z * 3), 0, 120)
                local Info = TweenInfo.new(0.2)
                local Goal = {FieldOfView = FreecamFov}
                local Tween = TweenService:Create(Camera, Info, Goal)
                Tween:Play()
            else
                MouseDelta = Vector2.new(-Input.Delta.Y, -Input.Delta.X)
            end
        end)

        Connections.TidalWave.FreecamRenderSteppedConnection = RunService.RenderStepped:Connect(function(Delta)
            Rotation += Vector2.new((MouseDelta.X * Delta), (MouseDelta.Y * Delta))
            CF = CFrame.new(CF.Position) * CFrame.fromOrientation(Rotation.X, Rotation.Y, 0) * CFrame.new(Vel * 64 * Delta)
            MouseDelta = Vector2.new(0, 0)
            if Camera then
                local Raycast = workspace:Raycast(Camera.CFrame.Position, Camera.CFrame.LookVector * 1000)
                Camera.CameraType = Enum.CameraType.Custom
                Camera.Focus = if Raycast then CFrame.new(0, 0, -Raycast.Position) else Camera.CFrame
                Camera.CFrame = CF
            end
        end)
    end
end

function FindPlayer(Name: string)
    if typeof(Name) ~= "string" or Name == "" then return nil end
    Name = Name:lower()
    for i, Player in ipairs(Players:GetPlayers()) do
        local PlayerName = Player.Name:lower()
        local PlayerDisplayName = Player.DisplayName:lower()
        if PlayerName:find(Name) or PlayerDisplayName:find(Name) then
            return Player
        end
    end
	return nil
end

function SubstituteNumber(Number, Decimals)
    if Number % 1 == 0 or Number == 1 then
        return tostring(Number)
    end
    local FormattedString = `%.{Decimals}f`
    return FormattedString:format(Number)
end

function ChatboxFocused()
	local Success, Focused = pcall(function()
		return CoreGui.ExperienceChat.appLayout.chatInputBar.Background.Container.TextContainer.TextBoxContainer.TextBox:IsFocused()
	end)
	return Success and Focused or false
end

function GetChildrenOfClass(Obj, Class)
	local Children = {}
	if typeof(Obj) ~= "Instance" then return Children end
	for i, v in pairs(Obj:GetChildren()) do
		if v.ClassName == Class then
			table.insert(Children, v)
		end
	end
	return Children
end

function NotifyModuleToggled(Name, Boolean)
	if Boolean ~= nil and tostring(Name) then
		if Boolean then
			Notify({
				Title = "Module Toggled",
				Text = tostring(Name) .. " Has been <b><font color='rgb(0, 255, 0)'>Enabled</font></b>",
				Duration = 2,
			})
		else
			Notify({
				Title = "Module Toggled",
				Text = tostring(Name) .. " Has been <b><font color='rgb(255, 0, 0)'>Disabled</font></b>",
				Duration = 2,
			})
		end
	end
end

function ToggleHackFromList(Name, Boolean)
	if Boolean ~= nil then
		if Boolean then
			AddHackToList(Name)
		else
			RemoveHackFromList(Name)
		end
	end
end

function ModuleToggled(Object, Name, Boolean, NoNotify)
	if Boolean ~= nil then
		if typeof(Object) == "table" then
			if Object.MainFrame then
				ToggleButtonColor(Object.MainFrame, Boolean)
			elseif Object.Btn then
				ToggleButtonColor(Object.Btn, Boolean)
			end
			ToggleHackFromList(Name, Boolean)
			if NoNotify == true then return end
			NotifyModuleToggled(Name, Boolean)
		elseif typeof(Object) == "Instance" then
			local ButtonEnabledIndicator = Object:FindFirstChild("ButtonEnabledIndicator")
			if ButtonEnabledIndicator then
				ToggleButtonColor(ButtonEnabledIndicator, Boolean)
				ToggleHackFromList(Name, Boolean)
				if NoNotify == true then return end
				NotifyModuleToggled(Name, Boolean)
			else
				ToggleButtonColor(Object, Boolean)
				ToggleHackFromList(Name, Boolean)
				if NoNotify == true then return end
				NotifyModuleToggled(Name, Boolean)
			end
		end
	end
end

function FindCMD(CMD)
    if typeof(CMD) ~= "string" then return end
    for i, v in ipairs(CMDS) do
        if string.lower(v.Name) == string.lower(CMD) then
            return i, v
        end
        for i2, v2 in ipairs(v.Aliases) do
            if string.lower(v2) == string.lower(CMD) then
                return i, v
            end
        end
    end
    return nil
end

function AddAlias(CMD, Alias)
    local FoundCMD = FindCMD(CMD)
    if FoundCMD then
        FoundCMD.Aliases[#FoundCMD.Aliases + 1] = Alias
    end
end

function RemoveAlias(Alias)
	local FoundCMD = FindCMD(Alias)
    if FoundCMD then
        for i, v in ipairs(FoundCMD.Aliases) do
            if string.lower(v) == string.lower(Alias) then
                table.remove(FoundCMD.Aliases, i)
                break
            end
        end
    end
end

ResetPlayer = nil

function PromptNewRig(Rig)
	local Char = GetChar(Plr)
	local Humanoid = GetHumanoid(Char)
	if Char and Humanoid then
		AvatarEditorService:PromptSaveAvatar(Humanoid.HumanoidDescription, Enum.HumanoidRigType[Rig])
		local Result = AvatarEditorService.PromptSaveAvatarCompleted:Wait()
		if Result == Enum.AvatarPromptResult.Success then
			ResetPlayer:Toggle()
		end
	end
end

function GetClosestPlayerFromCursor()
	local ClosestPlayer = nil
	local ClosestPlayerDistance = math.huge
	local OnScreen = nil
	for i, Player in pairs(Players:GetPlayers()) do
		if Player == Plr or Player.UserId == Plr.UserId then continue end
		local PlayerChar = GetChar(Player)
		local PlayerRoot = GetRoot(PlayerChar)
		if not (PlayerChar and PlayerRoot) then continue end
		local Vector, PlayerRootOnScreen = Camera:WorldToViewportPoint(PlayerRoot.Position)
		local Distance = (Vector2.new(Vector.X, Vector.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
		if Distance < ClosestPlayerDistance then
			ClosestPlayerDistance = Distance
			ClosestPlayer = Player
			OnScreen = PlayerRootOnScreen
		end
	end
	return ClosestPlayer, OnScreen
end

function NotifyExploitDoesntSupportFunction(Func)
    local Text = "Your Executor Doesn't Support \"" .. tostring(Func) .. "\""
    if IdentifyExecutor then
        Text = IdentifyExecutor() .. " Doesn't Support \"" .. tostring(Func) .. "\""
    end
	Notify({
		Text = Text,
	})
end

function CreateRebindButton(Properties)
	Properties.Keybind = string.gsub(Properties.Keybind, " ", "")
    local MainFrame = Instance.new("Frame")
    MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    MainFrame.BorderSizePixel = 0
    MainFrame.Name = Properties.Keybind .. "_RebindButton"
	MainFrame.ZIndex = (Properties.Parent or SettingsMenu.ScrollingFrame).ZIndex
	if Properties.Parent then
		MainFrame.Size = UDim2.new(0.975, 0, 0, Camera.ViewportSize.Y / 40)
	else
		MainFrame.Size = UDim2.fromScale(0.85, 0.1)
	end
    MainFrame.Parent = Properties.Parent or SettingsMenu.ScrollingFrame

    local MainFrameUICorner = Instance.new("UICorner")
    MainFrameUICorner.CornerRadius = UDim.new(0.25, 0)
    MainFrameUICorner.Parent = MainFrame

    local KeybindNameLabel = Instance.new("TextLabel")
    KeybindNameLabel.BackgroundTransparency = 1
    KeybindNameLabel.Size = UDim2.fromScale(0.5, 0.6)
    KeybindNameLabel.Position = UDim2.fromScale(0, 0.2)
    KeybindNameLabel.Name = "KeybindNameLabel"
    KeybindNameLabel.Text = Properties.Keybind .. " Keybind"
    KeybindNameLabel.Font = TextFont
    KeybindNameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    KeybindNameLabel.TextScaled = true
	KeybindNameLabel.ZIndex = MainFrame.ZIndex
    KeybindNameLabel.Parent = MainFrame

	local KeybindNameLabelUIPadding = Instance.new("UIPadding")
    KeybindNameLabelUIPadding.PaddingTop = UDim.new(0.05, 0)
    KeybindNameLabelUIPadding.PaddingBottom = UDim.new(0.05, 0)
    KeybindNameLabelUIPadding.PaddingLeft = UDim.new(0.025, 0)
    KeybindNameLabelUIPadding.PaddingRight = UDim.new(0.025, 0)
    KeybindNameLabelUIPadding.Parent = KeybindNameLabel

    local RebindButton = Instance.new("TextButton")
    RebindButton.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    RebindButton.BorderSizePixel = 0
    RebindButton.Size = UDim2.fromScale(0.4, 0.75)
    RebindButton.Position = UDim2.fromScale(0.5, 0.125)
    RebindButton.Name = "RebindButton"
	RebindButton.AutoButtonColor = false
	RebindButton.ZIndex = MainFrame.ZIndex
	RebindButton.TextColor3 = GuiColors.Text
	RebindButton.Font = TextFont
	RebindButton.Text = "None"
	RebindButton.TextScaled = true
    RebindButton.Parent = MainFrame

	local RebindButtonUIPadding = Instance.new("UIPadding")
    RebindButtonUIPadding.PaddingTop = UDim.new(0.1, 0)
    RebindButtonUIPadding.PaddingBottom = UDim.new(0.1, 0)
    RebindButtonUIPadding.PaddingLeft = UDim.new(0.025, 0)
    RebindButtonUIPadding.PaddingRight = UDim.new(0.025, 0)
    RebindButtonUIPadding.Parent = RebindButton

    local RebindButtonFrameUICorner = Instance.new("UICorner")
    RebindButtonFrameUICorner.CornerRadius = UDim.new(0.25, 0)
    RebindButtonFrameUICorner.Parent = RebindButton

    local DeleteButton = Instance.new("TextButton")
    DeleteButton.BackgroundTransparency = 1
    DeleteButton.Size = UDim2.fromScale(0.08, 1)
    DeleteButton.Position = UDim2.fromScale(0.91, 0)
    DeleteButton.Name = "DeleteButton"
    DeleteButton.Font = Enum.Font.FredokaOne
    DeleteButton.Text = "X"
    DeleteButton.TextScaled = true
    DeleteButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	DeleteButton.ZIndex = MainFrame.ZIndex
    DeleteButton.Parent = MainFrame

    local DeleteButtonUICorner = Instance.new("UICorner")
    DeleteButtonUICorner.CornerRadius = UDim.new(0.25, 0)
    DeleteButtonUICorner.Parent = DeleteButton

	RebindButton.MouseButton1Click:Connect(function()
		if Rebinding == nil then
			Rebinding = Properties.Keybind
			RebindButton.Text = "Press Key"
		else
			RebindButton.Text = "Keybind"
			Rebinding = nil
		end
	end)

	DeleteButton.MouseButton1Click:Connect(function()
		if Properties.Custom then
			if Properties.OnDelete then
				Properties.OnDelete()
			end
		else
			if TidalWaveKeybinds[Properties.Keybind] then
				TidalWaveKeybinds[Properties.Keybind] = nil
			end
		end
		RebindButton.Text = "None"
	end)

	return MainFrame
end

function LookTowards(Vec1, Vec2)
	if not Vec1 or not Vec2 then return end
	if typeof(Vec1) ~= "Vector3" or typeof(Vec2) ~= "Vector3" then return end

	return CFrame.lookAt(Vec1, Vector3.new(Vec2.X, Vec1.Y, Vec2.Z))
end

function CreateGlobalFiles()
	if not IsFolder then return end
	if not MakeFolder then return end
	
	if not IsFolder("TidalWave") then MakeFolder("TidalWave") end
	if not IsFolder("TidalWave/Profiles") then MakeFolder("TidalWave/Profiles") end
	if not IsFolder("TidalWave/StartUpSounds") then MakeFolder("TidalWave/StartUpSounds") end
	
	if not WriteFile then return end
    if not IsFile then return end
	
	if not IsFile("TidalWave/GlobalSettings.json") then
		WriteFile("TidalWave/GlobalSettings.json", HttpService:JSONEncode({
			MenuOpenSpeed = MenuOpenSpeed,
			Font = TextFont,
			MenuKeybind = MenuKeybind,
			CMDBarKeybind = CMDBarKeybind,
			SearchBarKeybind = SearchBarKeybind,
			KeepTidalWave = KeepTidalWave,
			ProfileToAutoLoad = ProfileToAutoLoad,
			Aliases = Aliases,
		}))
	end
end

function GetAllCharacters()
	local Characters = {}
	for i, Player in ipairs(Players:GetPlayers()) do
		local PlayerChar = GetChar(Player)
		if PlayerChar then
			table.insert(Characters, PlayerChar)
		end
	end
	return Characters
end

CMDCategory = nil

function GetSelectedCMD()
	local LowestPos = math.huge
	local SelectedCMD = nil
	for i, v in ipairs(CMDCategory.ScrollingFrame:GetChildren()) do
		if v:IsA("UIListLayout") or v:GetAttribute("Textbox") then continue end
        if not v.Visible then continue end
		if v.AbsolutePosition.Y < LowestPos then
			SelectedCMD = string.split(v.Text, " / ")[1]
			LowestPos = v.AbsolutePosition.Y
		end
	end
	return SelectedCMD
end

function UpdateGlobalFiles()
	CreateGlobalFiles()
	if not WriteFile then return end

	WriteFile("TidalWave/GlobalSettings.json", HttpService:JSONEncode({
		MenuOpenSpeed = MenuOpenSpeed,
		Font = TextFont,
		MenuKeybind = MenuKeybind,
		CMDBarKeybind = CMDBarKeybind,
		SearchBarKeybind = SearchBarKeybind,
		KeepTidalWave = KeepTidalWave,
		ProfileToAutoLoad = ProfileToAutoLoad,
		Aliases = Aliases,
	}))
end

ToggleKeepTidalWave = nil

function UpdateGlobalSettings()
    if not ReadFile then return end
    local File = ReadFile("TidalWave/GlobalSettings.json")
    local Json = HttpService:JSONDecode(File)
    if Json.MenuOpenSpeed ~= nil then
        MenuOpenSpeed = Json.MenuOpenSpeed
    end
    if Json.Font ~= nil then
        TextFont = Json.Font
    end
    if Json.MenuKeybind ~= nil then
        MenuKeybind = Json.MenuKeybind
    end
    if Json.CMDBarKeybind ~= nil then
        CMDBarKeybind = Json.CMDBarKeybind
    end
    if Json.SearchBarKeybind ~= nil then
        SearchBarKeybind = Json.SearchBarKeybind
    end
    if Json.KeepTidalWave == true then
        ToggleKeepTidalWave:Enable({NoNotify = true})
    elseif Json.KeepTidalWave == false then
        ToggleKeepTidalWave:Disable({NoNotify = true})
    end
    if Json.ProfileToAutoLoad ~= nil then
        ProfileToAutoLoad = Json.ProfileToAutoLoad
    end
    if Json.TidalWaveKeybinds ~= nil then
        TidalWaveKeybinds = Json.TidalWaveKeybinds
    end
    if Json.Aliases ~= nil then
        Aliases = Json.Aliases
    end
end

function Shutdown()
    local Args = {NoNotify = true}
    for i, v in pairs(Toggles) do
        if typeof(v) == "table" and v.Disable then
            v:Disable(Args)
        end
    end

	StopScript = true

	local function ClearTable(Table)
		for i, v in pairs(Table) do
			if typeof(v) == "RBXScriptConnection" then
				v:Disconnect()
            elseif typeof(v) == "thread" then
                task.cancel(v)
			elseif typeof(v) == "table" then
				ClearTable(v)
			end
		end
        table.clear(Table)
	end

    --- Clearing Tables ---
    
	ClearTable(Connections)
    ClearTable(TidalWaveKeybinds)
    ClearTable(GuiColors)
    ClearTable(CMDS)
    ClearTable(Aliases)
    ClearTable(Toggles)
    ClearTable(KeycodeMap)
    
    Connections = nil
    TidalWaveKeybinds = nil
    GuiColors = nil
    CMDS = nil
    Aliases = nil
    Toggles = nil
    KeycodeMap = nil
    
    --- Destroying Main Gui ---
	
	if TidalWaveScreenGui then
		TidalWaveScreenGui:Destroy()
        TidalWaveScreenGui = nil
	end
end

function AddCmd(CMD, AliasTable, Func, Description, Args)
	CMDS[#CMDS + 1] = {
        Name = CMD,
        Aliases = AliasTable or {},
        Function = Func
    }
    local Text = CMD
    if #AliasTable > 0 then
        Text = `{Text} / {table.concat(AliasTable, " / ")} {Args or ""}`
    end
    CMDCategory:CreateButton({
        Text = Text,
        LayoutOrder = #CMDS,
        Info = Description,
        NoKeybind = true,
        NoSettings = true,
        Function = function()
            CMDBar.Textbox.Text = CMD
            CMDBar.Textbox:CaptureFocus()
        end,
    })
end

function EnumFromName(EnumVal, ValToFind)
	if EnumVal and ValToFind then
		for i, v in pairs(EnumVal:GetEnumItems()) do
			if string.lower(v) == ValToFind then
				return v
			end
		end
	end
	return nil
end

function IsTeammate(Player)
	if IsFleeTheFacility then
		local Char = GetChar(Plr)
		local PlayerChar = GetChar(Player)
		if Char and PlayerChar then
			if Char:FindFirstChild("Hammer") then
				return PlayerChar:FindFirstChild("Hammer") ~= nil
			else
				return PlayerChar:FindFirstChild("Hammer") == nil
			end
		end
		return false
	elseif IsSkywars then
		if Player:GetAttribute("TeamId") == Plr:GetAttribute("TeamId") then
			return true
		end
		return false
	else
		if Player.Team == Plr.Team then
			return true
		end
		return false
	end
end

function GetTeamColor(Player)
	if IsFleeTheFacility then
		local Char = GetChar(Plr)
		local PlayerChar = GetChar(Player)
		if Char and PlayerChar then
			if (Char:FindFirstChild("Hammer") and not PlayerChar:FindFirstChild("Hammer")) or (PlayerChar:FindFirstChild("Hammer") and not Char:FindFirstChild("Hammer")) then
				return Color3.fromRGB(255, 0, 0)
			else
				return Color3.fromRGB(0, 255, 0)
			end
		end
		return Color3.fromRGB(255, 255, 255)
	elseif IsSkywars then
		local TeamId = Player:GetAttribute("TeamId")
		return if TeamId == "Red" then
				Color3.fromRGB(255, 0, 0)
			elseif TeamId == "Green" then
				Color3.fromRGB(0, 255, 0)
			elseif TeamId == "Blue" then
				Color3.fromRGB(0, 0, 255)
			elseif TeamId == "Yellow" then
				Color3.fromRGB(255, 255, 0)
			else
				Color3.fromRGB(255, 255, 255)
	end
    return Player.TeamColor.Color
end

do
	local eps = 1e-9
	local function isZero(d)
		return (d > -eps and d < eps)
	end

	local function cuberoot(x)
		return (x > 0) and math.pow(x, (1 / 3)) or -math.pow(math.abs(x), (1 / 3))
	end

	local function solveQuadric(c0, c1, c2)
		local s0, s1

		local p, q, D

		p = c1 / (2 * c0)
		q = c2 / c0
		D = p * p - q

		if isZero(D) then
			s0 = -p
			return s0
		elseif (D < 0) then
			return
		else -- if (D > 0)
			local sqrt_D = math.sqrt(D)

			s0 = sqrt_D - p
			s1 = -sqrt_D - p
			return s0, s1
		end
	end
	local function solveCubic(c0, c1, c2, c3)
		local s0, s1, s2

		local num, sub
		local A, B, C
		local sq_A, p, q
		local cb_p, D

		A = c1 / c0
		B = c2 / c0
		C = c3 / c0

		sq_A = A * A
		p = (1 / 3) * (-(1 / 3) * sq_A + B)
		q = 0.5 * ((2 / 27) * A * sq_A - (1 / 3) * A * B + C)

		cb_p = p * p * p
		D = q * q + cb_p

		if isZero(D) then
			if isZero(q) then -- one triple solution
				s0 = 0
				num = 1
			else -- one single and one double solution
				local u = cuberoot(-q)
				s0 = 2 * u
				s1 = -u
				num = 2
			end
		elseif (D < 0) then -- Casus irreducibilis: three real solutions
			local phi = (1 / 3) * math.acos(-q / math.sqrt(-cb_p))
			local t = 2 * math.sqrt(-p)

			s0 = t * math.cos(phi)
			s1 = -t * math.cos(phi + math.pi / 3)
			s2 = -t * math.cos(phi - math.pi / 3)
			num = 3
		else -- one real solution
			local sqrt_D = math.sqrt(D)
			local u = cuberoot(sqrt_D - q)
			local v = -cuberoot(sqrt_D + q)

			s0 = u + v
			num = 1
		end

		sub = (1 / 3) * A

		if (num > 0) then s0 = s0 - sub end
		if (num > 1) then s1 = s1 - sub end
		if (num > 2) then s2 = s2 - sub end

		return s0, s1, s2
	end

	local function solveQuartic(c0, c1, c2, c3, c4)
		local s0, s1, s2, s3

		local coeffs = {}
		local z, u, v, sub
		local A, B, C, D
		local sq_A, p, q, r
		local num

		A = c1 / c0
		B = c2 / c0
		C = c3 / c0
		D = c4 / c0

		sq_A = A * A
		p = -0.375 * sq_A + B
		q = 0.125 * sq_A * A - 0.5 * A * B + C
		r = -(3 / 256) * sq_A * sq_A + 0.0625 * sq_A * B - 0.25 * A * C + D

		if isZero(r) then
			coeffs[3] = q
			coeffs[2] = p
			coeffs[1] = 0
			coeffs[0] = 1

			local results = {solveCubic(coeffs[0], coeffs[1], coeffs[2], coeffs[3])}
			num = #results
			s0, s1, s2 = results[1], results[2], results[3]
		else
			coeffs[3] = 0.5 * r * p - 0.125 * q * q
			coeffs[2] = -r
			coeffs[1] = -0.5 * p
			coeffs[0] = 1

			s0, s1, s2 = solveCubic(coeffs[0], coeffs[1], coeffs[2], coeffs[3])
			z = s0

			u = z * z - r
			v = 2 * z - p

			if isZero(u) then
				u = 0
			elseif (u > 0) then
				u = math.sqrt(u)
			else
				return
			end
			if isZero(v) then
				v = 0
			elseif (v > 0) then
				v = math.sqrt(v)
			else
				return
			end

			coeffs[2] = z - u
			coeffs[1] = q < 0 and -v or v
			coeffs[0] = 1

			do
				local results = {solveQuadric(coeffs[0], coeffs[1], coeffs[2])}
				num = #results
				s0, s1 = results[1], results[2]
			end

			coeffs[2] = z + u
			coeffs[1] = q < 0 and v or -v
			coeffs[0] = 1

			if (num == 0) then
				local results = {solveQuadric(coeffs[0], coeffs[1], coeffs[2])}
				num = num + #results
				s0, s1 = results[1], results[2]
			end
			if (num == 1) then
				local results = {solveQuadric(coeffs[0], coeffs[1], coeffs[2])}
				num = num + #results
				s1, s2 = results[1], results[2]
			end
			if (num == 2) then
				local results = {solveQuadric(coeffs[0], coeffs[1], coeffs[2])}
				num = num + #results
				s2, s3 = results[1], results[2]
			end
		end

		sub = 0.25 * A

		if (num > 0) then s0 = s0 - sub end
		if (num > 1) then s1 = s1 - sub end
		if (num > 2) then s2 = s2 - sub end
		if (num > 3) then s3 = s3 - sub end

		return {s3, s2, s1, s0}
	end
	
	function SolveTrajectory(origin: Vector3, projectileSpeed: number, targetPos: Vector3, targetVelocity: Vector3, pickLongest: boolean?, gravity: number?): Vector3?
		local g: number = gravity or workspace.Gravity
		local disp: Vector3 = targetPos - origin
		local p, q, r: number = targetVelocity.X, targetVelocity.Y, targetVelocity.Z
		local h, j, k: number = disp.X, disp.Y, disp.Z
		local l: number = -.5 * g 

		local solutions = solveQuartic(l*l,-2*q*l, q*q - 2*j*l - projectileSpeed*projectileSpeed + p*p + r*r, 2*j*q + 2*h*p + 2*k*r, j*j + h*h + k*k)
		if solutions then
			local posRoots: {number} = table.create(2)
			for _, v in solutions do --filter out the negative roots
				if v > 0 then
					table.insert(posRoots, v)
				end
			end
			if posRoots[1] then
				local t: number = posRoots[if pickLongest then 2 else 1]
				local d: number = (h + p*t)/t
				local e: number = (j + q*t - l*t*t)/t
				local f: number = (k + r*t)/t
				return origin + Vector3.new(d, e, f)
			end
		end
		return
	end
end

function GetFileType(Path)
    local Periods = Path:split(".")
    if #Periods > 0 then
        return Periods[#Periods]
    else
        if IsFolder and IsFolder(Path) then
            return "Folder"
        end
    end
    return nil
end

function GetFileName(Path)
    local Periods = Path:split(".")
    if #Periods > 0 then
        local FileType = Periods[#Periods]
        Path = Path:gsub("\\", "/"):gsub(`.{FileType}`, ""):split("/")
        Path = Path[#Path]
        return Path
    else
        Path = Path:gsub("\\", "/"):split("/")
        Path = Path[#Path]
        return Path
    end
end

function ExecuteCMD(CMD, Args)
    local _, FoundCMD = FindCMD(CMD)
    if FoundCMD then
        FoundCMD.Function({CMD, unpack(Args)})
    end
end

----------------------------------------------------------------------------------------------------- Categories

Combat = CreateCategory({
	Name = "Combat",
	Size = UDim2.fromScale(1, 1),
	Pos = UDim2.fromScale(0.01, 0),
	ClosedPos = UDim2.fromScale(0.45, -1),
})
PlayerCategory = CreateCategory({
	Name = "Player",
	Size = UDim2.fromScale(1, 1),
	Pos = UDim2.fromScale(0.105, 0),
	ClosedPos = UDim2.fromScale(1, 1),
})
Movement = CreateCategory({
	Name = "Movement",
	Size = UDim2.fromScale(1, 1),
	Pos = UDim2.fromScale(0.2, 0),
	ClosedPos = UDim2.fromScale(-0.25, -1),
})
Visuals = CreateCategory({
	Name = "Visuals",
	Size = UDim2.fromScale(1, 1),
	Pos = UDim2.fromScale(0.295, 0),
	ClosedPos = UDim2.fromScale(-0.25, 1),
})
WorldCategory = CreateCategory({
	Name = "World",
	Size = UDim2.fromScale(1, 1),
	Pos = UDim2.fromScale(0.39, 0),
	ClosedPos = UDim2.fromScale(1, -1)
})
Other = CreateCategory({
	Name = "Other",
	Size = UDim2.fromScale(1, 1),
	Pos = UDim2.fromScale(0.485, 0),
	ClosedPos = UDim2.fromScale(1, 1),
})
MenuSettings = CreateCategory({
	Name = "Settings",
	Size = UDim2.fromScale(1, 0.4),
	Pos = UDim2.fromScale(0.58, 0),
	ClosedPos = UDim2.fromScale(1, -0.5),
})
KeybindsCategory = CreateCategory({
	Name = "Keybinds",
	Size = UDim2.fromScale(1, 0.53),
	Pos = UDim2.fromScale(0.58, 0.35),
	ClosedPos = UDim2.fromScale(-0.45, 1),
})
SearchCategory = CreateCategory({
	Name = "Search",
	Size = UDim2.fromScale(1, 0.1),
	Pos = UDim2.fromScale(0.675, 0),
	ClosedPos = UDim2.fromScale(0.45, -1),
})
CMDCategory = CreateCategory({
	Name = "CMDs",
	Size = UDim2.fromScale(1, 0.4),
	Pos = UDim2.fromScale(0.675, 0.125),
	ClosedPos = UDim2.fromScale(0.45, 1),
})

SearchTextbox = nil
CMDBar = nil

Camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
    for i, v in ipairs(CategoryHolderFrame:GetChildren()) do
        if v:IsA("UIListLayout") or v:IsA("UIGridLayout") or v:IsA("UIScale") then continue end
        for i2, v2 in ipairs(v.ContentFrame.ContentScrollingFrame:GetChildren()) do
            if v2.Name == "SearchBar" or v2.Name == "CMD Bar" then continue end
            if v2:IsA("TextButton") or v2:IsA("Frame") then
                v2.Size = UDim2.new(0.975, 0, 0, Camera.ViewportSize.Y / 40)
            end
        end
    end
    SearchTextbox.MainFrame.Size = UDim2.new(0.975, 0, 0, Camera.ViewportSize.Y / 15)
    CMDBar.MainFrame.Size = UDim2.new(0.975, 0, 0, Camera.ViewportSize.Y / 15)
    HoverInfoTextSizeConstraint.MaxTextSize = HoverInfo.AbsoluteSize.Y / 2
end)

----------------------------------------------------------------------------------------------------- Server Info

GameIdTextLabel = CreateButton({
	Text = `Game ID: {game.GameId}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Game Id",
	Function = function()
		SetClipboard(game.GameId, "Copied Game ID To SetClipboard")
	end,
})

PlaceIdTextLabel = CreateButton({
	Text = `Place ID: {game.PlaceId}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Place Id",
	Function = function()
		SetClipboard(game.PlaceId, "Copied Place ID To SetClipboard")
	end,
})

JobIdTextLabel = CreateButton({
	Text = `Job Id: {game.JobId}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Job Id",
	Function = function()
		SetClipboard(game.JobId, "Copied Job ID To SetClipboard")
	end,
})

PlaceVersionTextLabel = CreateButton({
	Text = `Place Version: {game.PlaceVersion}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Place Version",
	Function = function()
		SetClipboard(game.PlaceVersion, "Copied Place Version To SetClipboard")
	end,
})

CreatorTypeTextLabel = CreateButton({
	Text = `Creator Type: {game.CreatorType}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Creator Type",
	Function = function()
		SetClipboard(game.CreatorType, "Copied Creator Type To SetClipboard")
	end,
})

GameGenreTextLabel = CreateButton({
	Text = `Game Genre: {game.Genre}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Game Genre",
	Function = function()
		SetClipboard(game.Genre, "Copied Game Genre To SetClipboard")
	end,
})

CreatorIdTextLabel = CreateButton({
	Text = `Creator Id: {game.CreatorId}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Creator Id",
	Function = function()
		SetClipboard(game.CreatorId, "Copied Creator ID To SetClipboard")
	end,
})

MaxPlayersTextLabel = CreateButton({
	Text = `Max Players: {Players.MaxPlayers}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Max Players",
	Function = function()
		SetClipboard(Players.MaxPlayers, "Copied Max Players To SetClipboard")
	end,
})

PreferredPlayersTextLabel = CreateButton({
	Text = `Preferred Players: {Players.PreferredPlayers}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Preferred Players",
	Function = function()
		SetClipboard(Players.PreferredPlayers, "Copied Perferred Players To SetClipboard")
	end,
})

DistributedGameTimeTextLabel = CreateButton({
	Text = `Distributed Game Time: {time()}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Distributed Game Time",
	Function = function()
		SetClipboard(time(), "Copied Distributed Game Time To SetClipboard")
	end,
})

AmountOfPlayersTextLabel = CreateButton({
	Text = `Total Players: {#Players:GetPlayers()}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Total Players",
	Function = function()
		SetClipboard(#Players:GetPlayers(), "Copied Total Player To SetClipboard")
	end,
})

RespawnTimeTextLabel = CreateButton({
	Text = `Respawn Time: {Players.RespawnTime}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Respawn Time",
	Function = function()
		SetClipboard(Players.RespawnTime, "Copied Respawn Time To SetClipboard")
	end,
})

PlayerNameTextLabel = CreateButton({
	Text = `Player Name: {Plr}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Local Player Name",
	Function = function()
		SetClipboard(Plr.Name, "Copied Local Player Name")
	end,
})

DisplayNameTextLabel = CreateButton({
	Text = `Display Name: {Plr.DisplayName}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Local Player Display Name",
	Function = function()
		SetClipboard(Plr.DisplayName, "Copied Local Player Display Name")
	end,
})

AccountAgeTextLabel = CreateButton({
	Text = `Account Age: {Plr.AccountAge}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Local Player Account Age",
	Function = function()
		SetClipboard(Plr.AccountAge, "Copied Local Player Account Age To SetClipboard")
	end,
})

UserIdTextLabel = CreateButton({
	Text = `User ID: {Plr.UserId}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Local Player User ID",
	Function = function()
		SetClipboard(Plr.UserId, "Copied Local Player User ID")
	end,
})

CameraMinZoomTextLabel = CreateButton({
	Text = `Camera Min Zoom: {Plr.CameraMinZoomDistance}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Local Player Camera Min Zoom",
	Function = function()
		SetClipboard(Plr.CameraMinZoomDistance, "Copied Camera Min Zoom To SetClipboard")
	end,
})

CameraMaxZoomTextLabel = CreateButton({
	Text = `Camera Max Zoom: {Plr.CameraMaxZoomDistance}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Local Player Camera Max Zoom",
	Function = function()
		SetClipboard(Plr.CameraMaxZoomDistance, "Copied Camera Max Zoom To SetClipboard")
	end,
})

CameraModeTextLabel = CreateButton({
	Text = `Camera Mode: {Plr.CameraMode}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Local Player Camera Mode",
	Function = function()
		SetClipboard(Plr.CameraMode, "Copied Camera Mode To SetClipboard")
	end,
})

DevCameraOcclusionModeTextLabel = CreateButton({
	Text = `Dev Camera Occlusion Mode: {Plr.DevCameraOcclusionMode}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Dev Camera Occlusion Mode",
	Function = function()
		SetClipboard(Plr.DevCameraOcclusionMode, "Copied Dev Camera Occlusion Mode To SetClipboard")
	end,
})

DevComputerCameraModeTextLabel = CreateButton({
	Text = `Dev Computer Camera Movement Mode: {Plr.DevComputerCameraMode}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Dev Computer Camera Mode",
	Function = function()
		SetClipboard(Plr.DevComputerCameraMode, "Copied Dev Computer Camera Mode To SetClipboard")
	end,
})

DevEnableMouseLockTextLabel = CreateButton({
	Text = `Dev Enable Mouse Lock: {Plr.DevEnableMouseLock}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Dev Enable Mouse Lock",
	Function = function()
		SetClipboard(Plr.DevEnableMouseLock, "Copied Dev Enable Mouse Lock To SetClipboard")
	end,
})

DevTouchCameraModeTextLabel = CreateButton({
	Text = `Dev Touch Camera Mode: {Plr.DevTouchCameraMode}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Dev Touch Camera Mode",
	Function = function()
		SetClipboard(Plr.DevTouchCameraMode, "Copied Dev Touch Camera Mode To SetClipboard")
	end,
})

HealthDisplayDistanceTextLabel = CreateButton({
	Text = `Health Display Distance: {Plr.HealthDisplayDistance}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Health Display Distance",
	Function = function()
		SetClipboard(Plr.HealthDisplayDistance, "Copied Local Player Health Display Distance To SetClipboard")
	end,
})

NameDisplayDistanceTextLabel = CreateButton({
	Text = `Name Display Distance: {Plr.NameDisplayDistance}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Name Display Distance",
	Function = function()
		SetClipboard(Plr.NameDisplayDistance, "Copied Local Player Name Display Distance To SetClipboard")
	end,
})

DevComputerMovementModeTextLabel = CreateButton({
	Text = `Dev Computer Movement Mode: {Plr.DevComputerMovementMode}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Dev Computer Movement Mode",
	Function = function()
		SetClipboard(Plr.DevComputerMovementMode, "Copied Dev Computer Movement Mode To SetClipboard")
	end,
})

DevTouchMovementModeTextLabel = CreateButton({
	Text = `Dev Touch Movement Mode: {Plr.DevTouchMovementMode}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Dev Touch Movement Move",
	Function = function()
		SetClipboard(Plr.DevTouchMovementMode, "Copied Dev Touch Movement Mode To SetClipboard")
	end,
})

TeamNeutralTextLabel = CreateButton({
	Text = `Team Neutral: {Plr.Neutral}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Team Neutral",
	Function = function()
		SetClipboard(Plr.Neutral, "Copied Team Neutral To SetClipboard")
	end,
})

TeamTextLabel = CreateButton({
	Text = `Team: {Plr.Team}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Team Name",
	Function = function()
		SetClipboard(Plr.Team, "Copied Team Name To SetClipboard")
	end,
})

TeamColorTextLabel = CreateButton({
	Text = `Team Color: {Plr.TeamColor.Color.R * 255}, {Plr.TeamColor.Color.G * 255}, {Plr.TeamColor.Color.B * 255}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Team Color",
	Function = function()
        local TeamColor = Plr.TeamColor.Color
		SetClipboard(`{TeamColor.R * 255}, {TeamColor.G * 255}, {TeamColor.B * 255}`, "Copied Team Color To SetClipboard")
	end,
})

TotalInstances = #game:GetDescendants()

TotalInstancesTextLabel = CreateButton({
	Text = `Total Instances: {TotalInstances}`,
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Total Instances",
	Function = function()
		SetClipboard(TotalInstances, "Copied Total Instances To SetClipboard")
	end,
})

HumanoidAppearenceIDTextLabel = CreateButton({
	Text = "Appearence ID: " .. tostring(Plr.CharacterAppearanceId),
	Parent = ServerInfoMenu.ScrollingFrame,
	Info = "Click To Copy Appearence ID",
	Function = function()
		SetClipboard(tostring(Plr.CharacterAppearanceId), "Copied Total Instances To SetClipboard")
	end,
})

Connections.ServerInfo.PlayerAddedConnection = Players.PlayerAdded:Connect(function()
    AmountOfPlayersTextLabel.Btn.Text = `Players: {#Players:GetPlayers()}`
end)
Connections.ServerInfo.PlayerRemovedConnection = Players.PlayerRemoving:Connect(function()
    AmountOfPlayersTextLabel.Btn.Text = `Players: {#Players:GetPlayers()}`
end)
Connections.ServerInfo.RespawnTimeConnection = Players:GetPropertyChangedSignal("RespawnTime"):Connect(function()
    RespawnTimeTextLabel.Btn.Text = `Respawn Time: {Players.RespawnTime}`
end)
Connections.ServerInfo.CameraMinZoomConnection = Plr:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(function()
    CameraMinZoomTextLabel.Btn.Text = `Camera Min Zoom: {Plr.CameraMinZoomDistance}`
end)
Connections.ServerInfo.CameraMaxZoomConnection = Plr:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
    CameraMaxZoomTextLabel.Btn.Text = `Camera Max Zoom: {Plr.CameraMaxZoomDistance}`
end)
Connections.ServerInfo.CameraModeConnection = Plr:GetPropertyChangedSignal("CameraMode"):Connect(function()
    CameraModeTextLabel.Btn.Text = `Camera Mode: {Plr.CameraMode}`
end)
Connections.ServerInfo.DevCameraOcclusionModeConnection = Plr:GetPropertyChangedSignal("DevCameraOcclusionMode"):Connect(function()
    DevCameraOcclusionModeTextLabel.Btn.Text = `Dev Camera Occlusion Mode: {Plr.DevCameraOcclusionMode}`
end)
Connections.ServerInfo.DevComputerCameraModeConnection = Plr:GetPropertyChangedSignal("DevComputerCameraMode"):Connect(function()
    DevComputerCameraModeTextLabel.Btn.Text = `Dev Computer Camera Mode: {Plr.DevComputerCameraMode}`
end)
Connections.ServerInfo.DevEnableMouseLockConnection = Plr:GetPropertyChangedSignal("DevEnableMouseLock"):Connect(function()
    DevEnableMouseLockTextLabel.Btn.Text = `Dev Enable Mouse Lock: {Plr.DevEnableMouseLock}`
end)
Connections.ServerInfo.DevTouchCameraModeConnection = Plr:GetPropertyChangedSignal("DevTouchCameraMode"):Connect(function()
    DevTouchCameraModeTextLabel.Btn.Text = `Dev Touch Camera Mode: {Plr.DevTouchCameraMode}`
end)
Connections.ServerInfo.HealthDisplayDistanceConnection = Plr:GetPropertyChangedSignal("HealthDisplayDistance"):Connect(function()
    HealthDisplayDistanceTextLabel.Btn.Text = `Health Display Distance: {Plr.HealthDisplayDistance}`
end)
Connections.ServerInfo.NameDisplayDistanceConnection = Plr:GetPropertyChangedSignal("NameDisplayDistance"):Connect(function()
    NameDisplayDistanceTextLabel.Btn.Text = `Name Display Distance: {Plr.NameDisplayDistance}`
end)
Connections.ServerInfo.DevComputerMovementModeConnection = Plr:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
    DevComputerMovementModeTextLabel.Btn.Text = `Dev Computer Movement Mode: {Plr.DevComputerMovementMode}`
end)
Connections.ServerInfo.DevTouchMovementModeConnection = Plr:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
    DevTouchMovementModeTextLabel.Btn.Text = `Dev Touch Movement Mode: {Plr.DevTouchMovementMode}`
end)
Connections.ServerInfo.TeamConnection = Plr:GetPropertyChangedSignal("Team"):Connect(function()
    TeamTextLabel.Btn.Text = `Team: {Plr.Team}`
end)
Connections.ServerInfo.TeamNeutralConnection = Plr:GetPropertyChangedSignal("Neutral"):Connect(function()
    TeamNeutralTextLabel.Btn.Text = `Team Neutral: {Plr.Neutral}`
end)
Connections.ServerInfo.TeamColorConnection = Plr:GetPropertyChangedSignal("TeamColor"):Connect(function()
    local TeamColor = Plr.TeamColor.Color
    TeamColorTextLabel.Btn.Text = `Team Color: {TeamColor.R * 255}, {TeamColor.G * 255}, {TeamColor.B * 255}`
end)
Connections.ServerInfo.DescendantAddedConnection = game.DescendantAdded:Connect(function()
    TotalInstances += 1
    TotalInstancesTextLabel.Btn.Text = `Total Instances: {TotalInstances}`
end)
Connections.ServerInfo.DescendantRemovedConnection = game.DescendantRemoving:Connect(function()
    TotalInstances -= 1
    TotalInstancesTextLabel.Btn.Text = `Total Instances: {TotalInstances}`
end)

----------------------------------------------------------------------------------------------------- Keybinds

do
	RebindMenuKeybind = CreateRebindButton({
		Parent = KeybindsCategory.ScrollingFrame,
		Custom = true,
		Keybind = "Menu",
		OnDelete = function()
			MenuKeybind = "RightShift"
		end,
	})
	
	RebindCMDBarKeybind = CreateRebindButton({
		Parent = KeybindsCategory.ScrollingFrame,
		Keybind = "CMD",
		Custom = true,
		OnDelete = function()
			CMDBarKeybind = ""
		end,
	})
	
	RebindSearchBarKeybind = CreateRebindButton({
		Parent = KeybindsCategory.ScrollingFrame,
		Keybind = "Search",
		Custom = true,
		OnDelete = function()
			SearchBarKeybind = ""
		end,
	})
	
	ClickPartToSelectOutline = Instance.new("SelectionBox")
	ClickPartToSelectOutline.Color3 = Color3.fromRGB(0, 175, 255)
	ClickPartToSelectOutline.LineThickness = 0.075
    ClickPartToSelectOutline.Parent = EspFolder

	local PressedKeys = {}

	Connections.TidalWave.MainInputBeganConnection = UIS.InputBegan:Connect(function(Input)
		if not ChatboxFocused() and not TidalWaveFocused then
            local MultiBinded = MenuKeybind:find("+") ~= nil
            local Keys = MultiBinded and MenuKeybind:split("+")
            local AllDown = true
            if MultiBinded then
                for i, v in ipairs(Keys) do
                    if not UIS:IsKeyDown(v) then
                        AllDown = false
                    end
                end
            end
            if ((MultiBinded and AllDown) or (not MultiBinded and Input.KeyCode.Name == MenuKeybind)) then
                if SettingsMenu.TopBar.Visible then
                    SettingsMenu.TopBar.Visible = false
                elseif ProfileMenu.TopBar.Visible then
                    ProfileMenu.TopBar.Visible = false
                end
            elseif Input.KeyCode ~= Enum.KeyCode.Unknown and Input.KeyCode ~= Enum.KeyCode.Escape then
				if Rebinding == "Menu" then
					if #PressedKeys > 0 then
						if not table.find(PressedKeys, Input.KeyCode.Name) then
							table.insert(PressedKeys, Input.KeyCode.Name)
						end
						MenuKeybind = table.concat(PressedKeys, "+")
						RebindMenuKeybind.RebindButton.Text = MenuKeybind
						return
					else
						MenuKeybind = Input.KeyCode.Name
						RebindMenuKeybind.RebindButton.Text = MenuKeybind
						table.insert(PressedKeys, Input.KeyCode.Name)
						while true do
							local Key = UIS.InputEnded:Wait()
							if Key.KeyCode.Name == PressedKeys[1] then
								table.clear(PressedKeys)
								break
							end
						end
						Rebinding = nil
						return
					end
				elseif Rebinding == "CMD" then
					if #PressedKeys > 0 then
						if not table.find(PressedKeys, Input.KeyCode.Name) then
							table.insert(PressedKeys, Input.KeyCode.Name)
						end
						CMDBarKeybind = table.concat(PressedKeys, "+")
						RebindCMDBarKeybind.RebindButton.Text = CMDBarKeybind
						return
					else
						CMDBarKeybind = Input.KeyCode.Name
						RebindCMDBarKeybind.RebindButton.Text = CMDBarKeybind
						table.insert(PressedKeys, Input.KeyCode.Name)
						while true do
							local Key = UIS.InputEnded:Wait()
							if Key.KeyCode.Name == PressedKeys[1] then
								table.clear(PressedKeys)
								break
							end
						end
						Rebinding = nil
						return
					end
				elseif Rebinding == "Search" then
					if #PressedKeys > 0 then
						if not table.find(PressedKeys, Input.KeyCode.Name) then
							table.insert(PressedKeys, Input.KeyCode.Name)
						end
						SearchBarKeybind = table.concat(PressedKeys, "+")
						RebindSearchBarKeybind.RebindButton.Text = SearchBarKeybind
						return
					else
						SearchBarKeybind = Input.KeyCode.Name
						RebindSearchBarKeybind.RebindButton.Text = SearchBarKeybind
						table.insert(PressedKeys, Input.KeyCode.Name)
						while true do
							local Key = UIS.InputEnded:Wait()
							if Key.KeyCode.Name == PressedKeys[1] then
								table.clear(PressedKeys)
								break
							end
						end
						Rebinding = nil
						return
					end
				elseif Rebinding then
					if #PressedKeys > 0 then
						if not table.find(PressedKeys, Input.KeyCode.Name) then
							table.insert(PressedKeys, Input.KeyCode.Name)
						end
						TidalWaveKeybinds[Rebinding] = table.concat(PressedKeys, "+")
						for i, v in pairs(SettingsMenu.ScrollingFrame:GetChildren()) do
							if v.Name == Rebinding .. "_RebindButton" then
								v.RebindButton.Text = TidalWaveKeybinds[Rebinding] or "None"
							end
						end
						return
					else
						TidalWaveKeybinds[Rebinding] = Input.KeyCode.Name
						for i, v in pairs(SettingsMenu.ScrollingFrame:GetChildren()) do
							if v.Name == Rebinding .. "_RebindButton" then
								v.RebindButton.Text = TidalWaveKeybinds[Rebinding] or "None"
							end
						end
						table.insert(PressedKeys, Input.KeyCode.Name)
						while true do
							local Key = UIS.InputEnded:Wait()
							if Key.KeyCode.Name == PressedKeys[1] then
								table.clear(PressedKeys)
								break
							end
						end
						Rebinding = nil
						return
					end
				end
            elseif Input.KeyCode == Enum.KeyCode.Escape or Input.KeyCode == Enum.KeyCode.Unknown then
                if Rebinding == "Menu" then
					RebindMenuKeybind.RebindButton.Text = MenuKeybind
					UIS.InputEnded:Wait()
					Rebinding = nil
					return
				elseif Rebinding == "CMD" then
					RebindCMDBarKeybind.RebindButton.Text = CMDBarKeybind
					UIS.InputEnded:Wait()
					Rebinding = nil
					return
				elseif Rebinding == "Search" then
					RebindSearchBarKeybind.RebindButton.Text = SearchBarKeybind
					UIS.InputEnded:Wait()
					Rebinding = nil
					return
				elseif Rebinding then
					for i, v in pairs(SettingsMenu.ScrollingFrame:GetChildren()) do
						if v.Name == Rebinding .. "_RebindButton" then
							v.RebindButton.Text = TidalWaveKeybinds[Rebinding] or "None"
						end
					end
					UIS.InputEnded:Wait()
					Rebinding = nil
					return
                end
			end
		end
		
		------------------------------------------------------------------------------------------------- BINDED KEYS PRESSED
		
		local Char = GetChar(Plr)
		local Humanoid = GetHumanoid(Char)
		local Root = GetRoot(Char)

		local CMDBarKeybindMultiBinded = CMDBarKeybind:find("+")
		local CMDBarKeybindKeys = CMDBarKeybindMultiBinded and CMDBarKeybind:split("+")
		local CMDBarKeybindsDown = true
		if CMDBarKeybindMultiBinded then
			for i, v in ipairs(CMDBarKeybindKeys) do
				if not UIS:IsKeyDown(v) then
					CMDBarKeybindsDown = false
				end
			end
		end

		local SearchBarKeybindMultiBinded = SearchBarKeybind:find("+")
		local SearchBarKeybindKeys = SearchBarKeybindMultiBinded and SearchBarKeybind:split("+")
		local SearchBarKeybindsDown = true
		if SearchBarKeybindMultiBinded then
			for i, v in ipairs(SearchBarKeybindKeys) do
				if not UIS:IsKeyDown(v) then
					SearchBarKeybindsDown = false
				end
			end
		end
        
		if ((CMDBarKeybindMultiBinded and CMDBarKeybindsDown) or Input.KeyCode.Name == CMDBarKeybind) and CMDCategory:IsVisible() then
			CMDBar.Textbox.Text = ""
			task.wait()
			CMDBar.Textbox:CaptureFocus()
		elseif ((SearchBarKeybindMultiBinded and SearchBarKeybindsDown) or Input.KeyCode.Name == SearchBarKeybind) and SearchCategory:IsVisible() then
			SearchTextbox.Textbox.Text = ""
			task.wait()
			SearchTextbox.Textbox:CaptureFocus()
		elseif Input.KeyCode == Enum.KeyCode.Tab and CMDBar.Textbox:IsFocused() then
			local SelectedCMD = GetSelectedCMD()
			if FindCMD(SelectedCMD) then
				CMDBar.Textbox.Text = SelectedCMD
				CMDBar.Textbox.CursorPosition = string.len(CMDBar.Textbox.Text)
			end
			CMDCategory.ScrollingFrame.CanvasPosition = Vector2.new(0, 0)
		end

		if TidalWaveFocused or ChatboxFocused() then return end
		
		if Input.UserInputType == Enum.UserInputType.MouseButton1 then
			if TidalWaveKeybinds.ClickTeleport and UIS:IsKeyDown(TidalWaveKeybinds.ClickTeleport) and ClickTeleportEnabled and Char and Root then
				Root.CFrame = CFrame.new(Mouse.Hit.Position + Vector3.new(0, 3.1, 0)) * CFrame.Angles(0, math.rad(Root.Orientation.Y), 0)
				if ClickTeleportSoundEnabled then
					local Sound = Instance.new("Sound")
					Sound.SoundId = ClickTeleportSound
                    Sound.Parent = SoundsFolder
					Sound:Play()
					Sound.Ended:Once(function()
						Sound:Destroy()
					end)
				end
			end
			if Mouse.Target then
				if ClickPartToSelect then
                    local MouseRaycast = Camera:ViewportPointToRay(Mouse.X, Mouse.Y)
                    local Params = RaycastParams.new()
                    Params.IgnoreWater = true
                    local Raycast = workspace:Raycast(MouseRaycast.Origin, MouseRaycast.Direction * 1000, Params)
                    if Raycast and Raycast.Instance then
                        ClickPartToSelectOutline.Adornee = Raycast.Instance
                        local FullName = GetFullName(Raycast.Instance)
                        SetClipboard(FullName, "Copied Path To Clipboard")
                        warn("[Tidal Wave]: " .. FullName)
                    end
				end
				if ClickDelete and TidalWaveKeybinds.ClickDelete and UIS:IsKeyDown(TidalWaveKeybinds.ClickDelete) then
                    local MouseRaycast = Camera:ViewportPointToRay(Mouse.X, Mouse.Y)
                    local Params = RaycastParams.new()
                    Params.IgnoreWater = true
                    local Raycast = workspace:Raycast(MouseRaycast.Origin, MouseRaycast.Direction * 1000, Params)
					if Char and ClickDeleteIgnorePlayer and Raycast and Raycast.Instance:IsDescendantOf(Char) then return end
                    if Raycast.Instance then
                        Raycast.Instance:Destroy()
                    end
				end
			end
		elseif Input.KeyCode == Enum.KeyCode.Space and InfiniteJump and Char and Humanoid then
			Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        else
            for KeybindName, Keybind in pairs(TidalWaveKeybinds) do
                if KeybindName == "ClickTeleport" or KeybindName == "ClickDelete" then continue end
				if Keybind:find("+") then
					local Keys = Keybind:split("+")
					local AllDown = true
					for i, v in ipairs(Keys) do
						if not UIS:IsKeyDown(v) then
							AllDown = false
						end
					end
					if AllDown then
						for ToggleName, Toggle in pairs(Toggles) do
							if ToggleName == KeybindName then
								Toggle:Toggle()
								break
							end
						end
						break
					end
				else
					if Input.KeyCode.Name == Keybind then
						for ToggleName, Toggle in pairs(Toggles) do
							if ToggleName == KeybindName then
								Toggle:Toggle()
								break
							end
						end
						break
					end
				end
            end
		end
	end)
end

----------------------------------------------------------------------------------------------------- Combat Category

do
	local function UpdateHitboxes()
		for i, Player in ipairs(Players:GetPlayers()) do
			if Player == Plr or Player.UserId == Plr.UserId then continue end
			local Char = GetChar(Player)
			if not Char then continue end
			for i, Part in ipairs(Char:GetChildren()) do
				if not Part:IsA("BasePart") then continue end
				Part.Size = HitboxExpanderSize
				Part.Transparency = HitboxExpanderTransparency
			end
		end
	end
	
	ToggleHitboxExpander = Combat:CreateToggle({
		Text = "Hitbox Expander",
		Info = "Expands players hitbox (might be laggy).",
		Function = function(HitboxExpander)
			if HitboxExpander then
				Connections.Combat.HitboxExpanderLoop = RunService.Stepped:Connect(UpdateHitboxes)
			else
				if Connections.Combat.HitboxExpanderLoop then
					Connections.Combat.HitboxExpanderLoop:Disconnect()
					Connections.Combat.HitboxExpanderLoop = nil
				end
			end
		end,
	})
	ToggleHitboxExpander:CreateSlider({
        Text = "X Size",
        Min = 0,
        Default = 2,
        Max = 20,
        Function = function(Val)
            HitboxExpanderSize = Vector3.new(Val, HitboxExpanderSize.Y, HitboxExpanderSize.Z)
        end,
        Function2 = function(Val)
            HitboxExpanderSize = Vector3.new(Val, HitboxExpanderSize.Y, HitboxExpanderSize.Z)
        end,
    })

    ToggleHitboxExpander:CreateSlider({
        Text = "Y Size",
        Min = 0,
        Default = 2,
        Max = 20,
        Function = function(Val)
            HitboxExpanderSize = Vector3.new(HitboxExpanderSize.X, Val, HitboxExpanderSize.Z)
            if HitboxExpander then
                UpdateHitboxes()
            end
        end,
        Function2 = function(Val)
            HitboxExpanderSize = Vector3.new(HitboxExpanderSize.X, Val, HitboxExpanderSize.Z)
            if HitboxExpander then
                UpdateHitboxes()
            end
        end,
    })

    ToggleHitboxExpander:CreateSlider({
        Text = "Z Size",
        Min = 0,
        Default = 2,
        Max = 20,
        Function = function(Val)
            HitboxExpanderSize = Vector3.new(HitboxExpanderSize.X, HitboxExpanderSize.Y, Val)
            if HitboxExpander then
                UpdateHitboxes()
            end
        end,
        Function2 = function(Val)
            HitboxExpanderSize = Vector3.new(HitboxExpanderSize.X, HitboxExpanderSize.Y, Val)
            if HitboxExpander then
                UpdateHitboxes()
            end
        end,
    })

    ToggleHitboxExpander:CreateSlider({
        Text = "Transparency",
        Min = 0,
        Default = 1,
        Max = 1,
        Function = function(Val)
            HitboxExpanderTransparency = Val
            if HitboxExpander then
                UpdateHitboxes()
            end
        end,
        Function2 = function(Val)
            HitboxExpanderTransparency = Val
            if HitboxExpander then
                UpdateHitboxes()
            end
        end,
    })
	
	local function UpdateToolHitboxes()
		local Char = GetChar(Plr)
		if not Char then return end
		for i, Tool in ipairs(Char:GetChildren()) do
			if not (Tool:IsA("Tool") or Tool:IsA("Model")) then continue end
			for i2, Part in pairs(Tool:GetDescendants()) do
				if not Part:IsA("BasePart") then continue end
				Part.Massless = ToolHitboxExpanderMassless
				Part.Size = ToolHitboxExpanderSize
				Part.Transparency = ToolHitboxExpanderTransparency
			end
		end
	end
	
	ToggleToolHitboxExpander = Combat:CreateToggle({
		Text = "Tool Hitbox Expander",
		Info = "Expands the hitbox of tools (might be laggy).",
		Function = function(ToolHitboxExpander)
			if ToolHitboxExpander then
				Connections.Combat.ToolHitboxExpanderLoop = RunService.Stepped:Connect(UpdateToolHitboxes)
			else
				if Connections.Combat.ToolHitboxExpanderLoop then
					Connections.Combat.ToolHitboxExpanderLoop:Disconnect()
					Connections.Combat.ToolHitboxExpanderLoop = nil
				end
			end
		end,
	})

   	ToggleToolHitboxExpander:CreateSlider({
        Text = "X Size",
        Min = 0,
        Default = 2,
        Max = 20,
        Function = function(Val)
            ToolHitboxExpanderSize = Vector3.new(Val, ToolHitboxExpanderSize.Y, ToolHitboxExpanderSize.Z)
            if ToolHitboxExpander then
                UpdateToolHitboxes()
            end
        end,
        Function2 = function(Val)
            ToolHitboxExpanderSize = Vector3.new(Val, ToolHitboxExpanderSize.Y, ToolHitboxExpanderSize.Z)
            if ToolHitboxExpander then
                UpdateToolHitboxes()
            end
        end,
    })
    
    ToggleToolHitboxExpander:CreateSlider({
        Text = "Y Size",
        Min = 0,
        Default = 2,
        Max = 20,
        Function = function(Val)
            ToolHitboxExpanderSize = Vector3.new(ToolHitboxExpanderSize.X, Val, ToolHitboxExpanderSize.Z)
            if ToolHitboxExpander then
                UpdateToolHitboxes()
            end
        end,
        Function2 = function(Val)
            ToolHitboxExpanderSize = Vector3.new(ToolHitboxExpanderSize.X, Val, ToolHitboxExpanderSize.Z)
            if ToolHitboxExpander then
                UpdateToolHitboxes()
            end
        end,
    })

   	ToggleToolHitboxExpander:CreateSlider({
        Text = "Z Size",
        Min = 0,
        Default = 2,
        Max = 20,
        Function = function(Val)
            ToolHitboxExpanderSize = Vector3.new(ToolHitboxExpanderSize.X, ToolHitboxExpanderSize.Y, Val)
            if ToolHitboxExpander then
                UpdateToolHitboxes()
            end
        end,
        Function2 = function(Val)
            ToolHitboxExpanderSize = Vector3.new(ToolHitboxExpanderSize.X, ToolHitboxExpanderSize.Y, Val)
            if ToolHitboxExpander then
                UpdateToolHitboxes()
            end
        end,
    })
    
    ToggleToolHitboxExpander:CreateSlider({
        Text = "Transparency",
        Min = 0,
        Default = 1,
        Max = 1,
        Function = function(Val)
            ToolHitboxExpanderTransparency = Val
        end,
        Function2 = function(Val)
            ToolHitboxExpanderTransparency = Val
        end,
    })

    ToggleToolHitboxExpander:CreateToggle({
        Text = "Massless",
        EnabledIndicatorDefault = true,
        Function = function(Bool)
            ToolHitboxExpanderMassless = Bool
        end,
    })
end

do
    ToggleGlobalAimbot = Combat:CreateToggle({
		Text = "Aimbot",
		Info = "Should work in most games hopefully.",
		Function = function(GlobalAimbot)
			if GlobalAimbot then
				Connections.Combat.GlobalAimbotLoop = RunService.RenderStepped:Connect(function()
					local Player, ScreenPos = GetClosestPlayerToMiddleOfScreen(GlobalAimbotSize.X, GlobalAimbotSize.Y, ToggleAimbotWallCheck.Enabled)
					local PlayerChar = GetChar(Player)
					local PlayerRootPart = GetRoot(PlayerChar)
					local PlayerHumanoid = GetHumanoid(PlayerChar)
					local Char = GetChar(Plr)
					local RootPart = GetRoot(Char)

					if not (Player and PlayerChar and PlayerRootPart and PlayerHumanoid and Char and RootPart) then return end
					
					local WithinMinDistance = (RootPart.Position - PlayerRootPart.Position).Magnitude < GlobalAimbotMinDistance
					local WithinMaxDistance = (RootPart.Position - PlayerRootPart.Position).Magnitude < GlobalAimbotMaxDistance
					local PlayerIsDead = PlayerHumanoid.Health <= 0
					local PlayerIsTeammate = ToggleAimbotTeamCheck.Enabled and IsTeammate(Player)
					
					if (PlayerIsDead or PlayerIsTeammate or WithinMinDistance) or not WithinMaxDistance then return end

					if GlobalAimbotMethod == "CFrame" then
						local Head = PlayerChar:FindFirstChild("Head")
						if Head and GlobalAimbotTarget == "Head" then
							Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, Head.Position)
						else
							Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, PlayerRootPart.Position)
						end
					elseif GlobalAimbotMethod == "MouseMoveRel" and MouseMoveRel then
						local Head = PlayerChar:FindFirstChild("Head")
						local Middle = Vector2.new(Camera.ViewportSize.X * 0.5, Camera.ViewportSize.Y * 0.5)
						local Delta

						if Head and GlobalAimbotTarget == "Head" then
							local HeadPos = Camera:WorldToViewportPoint(Head.Position)
							Delta = Vector2.new(HeadPos.X - Middle.X, HeadPos.Y - Middle.Y)
						else
							Delta = Vector2.new(ScreenPos.X - Middle.X, ScreenPos.Y - Middle.Y)
						end
						MouseMoveRel(Delta.X, Delta.Y)
					end
				end)
			else
				if Connections.Combat.GlobalAimbotLoop then
					Connections.Combat.GlobalAimbotLoop:Disconnect()
					Connections.Combat.GlobalAimbotLoop = nil
				end
			end
		end,
	})
	ToggleAimbotWallCheck = ToggleGlobalAimbot:CreateToggle({
        Text = "Wall Check",
        EnabledIndicatorDefault = true,
        Function = function(Bool)
            
        end,
    })
    ToggleAimbotTeamCheck = ToggleGlobalAimbot:CreateToggle({
        Text = "Team Check",
        EnabledIndicatorDefault = true,
        Function = function(Bool)
            
        end,
    })
   	ToggleGlobalAimbot:CreateSlider({
        Text = "Max Distance",
        Min = 0,
        Default = 1000,
        Max = 1000,
        Function = function(Val)
            GlobalAimbotMaxDistance = Val
        end,
        Function2 = function(Val)
            GlobalAimbotMaxDistance = Val
        end,
    })
    ToggleGlobalAimbot:CreateSlider({
        Text = "Min Distance",
        Min = 0,
        Default = 0,
        Max = 100,
        Function = function(Val)
            GlobalAimbotMinDistance = Val
        end,
        Function2 = function(Val)
            GlobalAimbotMinDistance = Val
        end,
    })
    ToggleGlobalAimbot:CreateSlider({
        Text = "Aimbot Size X (In Pixels)",
        Min = 0,
        Default = 480,
        Max = 1920,
        Function = function(Val)
            GlobalAimbotSize = Vector2.new(Val, GlobalAimbotSize.Y)
        end,
        Function2 = function(Val)
            GlobalAimbotSize = Vector2.new(Val, GlobalAimbotSize.Y)
        end,
    })
    ToggleGlobalAimbot:CreateSlider({
        Text = "Aimbot Size Y (In Pixels)",
        Min = 0,
        Default = 360,
        Max = 1080,
        Function = function(Val)
            GlobalAimbotSize = Vector2.new(GlobalAimbotSize.X, Val)
        end,
        Function2 = function(Val)
            GlobalAimbotSize = Vector2.new(GlobalAimbotSize.X, Val)
        end,
    })
    local GlobalAimbotTargetDropdown = ToggleGlobalAimbot:CreateDropdown({
        Text = "Target",
        Default = "Head",
        AutoUpdateText = true,
    })
    GlobalAimbotTargetDropdown:CreateButton({
        Text = "Head",
        Function = function()
            GlobalAimbotTarget = "Head"
        end,
    })
    GlobalAimbotTargetDropdown:CreateButton({
        Text = "HumanoidRootPart",
        Function = function()
            GlobalAimbotTarget = "HumanoidRootPart"
        end,
    })
    local GlobalAimbotMethodDropdown = ToggleGlobalAimbot:CreateDropdown({
        Text = "Aimbot Method",
        Default = "CFrame",
        AutoUpdateText = true,
    })
    GlobalAimbotMethodDropdown:CreateButton({
        Text = "CFrame",
        Function = function()
            GlobalAimbotMethod = "CFrame"
        end,
    })
    GlobalAimbotMethodDropdown:CreateButton({
        Text = "Mouse Move Rel",
        Function = function()
            GlobalAimbotMethod = "MouseMoveRel"
        end,
    })
end

do
    local PartAimbotExcludeWithProperty = "true"
	TogglePartAimbot = Combat:CreateToggle({
		Text = "Part Aimbot",
		Info = "Aimbots parts and npcs.",
		Function = function(PartAimbot)
			if PartAimbot then
				Connections.Combat.PartAimbotLoop = RunService.RenderStepped:Connect(function()
					if PartAimbotFolder then
						if PartAimbotMode == "Part" then
							local Part = GetClosestPartToMiddleOfScreen(PartAimbotFolder, PartAimbotSize.X, PartAimbotSize.Y, TogglePartAimbotWallCheck.Enabled, PartAimbotExcludeWithProperty)
							local Char = GetChar(Plr)
							local RootPart = GetRoot(Char)
							local Delta = nil

							if not (Part and Char and RootPart) then return end

							if Part:FindFirstChild("Head") then
								local Pos = Camera:WorldToViewportPoint(Part.Head.Position)
								Delta = Vector2.new(Pos.X - (Camera.ViewportSize.X * 0.5), Pos.Y - (Camera.ViewportSize.Y * 0.5))
							else
								local Pos = Camera:WorldToViewportPoint(Part.Position)
								Delta = Vector2.new(Pos.X - (Camera.ViewportSize.X * 0.5), Pos.Y - (Camera.ViewportSize.Y * 0.5))
							end

							if PartAimbotMethod == "CFrame" then
                                if Part:FindFirstChild("Head") and PartAimbotTarget == "Head" then
                                    Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, Part.Head.Position)
                                else
                                    Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, Part.Position)
                                end
                            elseif PartAimbotMethod == "MouseMoveRel" and MouseMoveRel and Delta then
                                MouseMoveRel(Delta.X, Delta.Y)
                            end
						else
							local Model = GetClosestModelToMiddleOfScreen(PartAimbotFolder, PartAimbotSize.X, PartAimbotSize.Y, TogglePartAimbotWallCheck.Enabled, PartAimbotExcludeWithProperty)
							local ModelRootPart = GetRoot(Model)
							local Char = GetChar(Plr)
							local RootPart = GetRoot(Char)
							local Delta = nil

							if not (Model and ModelRootPart and Char and RootPart) then return end
							
							if Model:FindFirstChild("Head") then
								local Pos = Camera:WorldToViewportPoint(Model.Head.Position)
								Delta = Vector2.new(Pos.X - (Camera.ViewportSize.X * 0.5), Pos.Y - (Camera.ViewportSize.Y * 0.5))
							else
								local Pos = Camera:WorldToViewportPoint(ModelRootPart.Position)
								Delta = Vector2.new(Pos.X - (Camera.ViewportSize.X * 0.5), Pos.Y - (Camera.ViewportSize.Y * 0.5))
							end

							if PartAimbotMethod == "CFrame" then
                                if Model:FindFirstChild("Head") and PartAimbotTarget == "Head" then
                                    Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, Model.Head.Position)
                                else
                                    Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, ModelRootPart.Position)
                                end
                            elseif PartAimbotMethod == "MouseMoveRel" and MouseMoveRel and Delta then
                                MouseMoveRel(Delta.X, Delta.Y)
                            end
						end
					end
				end)
			else
				if Connections.Combat.PartAimbotLoop then
					Connections.Combat.PartAimbotLoop:Disconnect()
					Connections.Combat.PartAimbotLoop = nil
				end
			end
		end,
	})
	local PartAimbotPathTextbox; PartAimbotPathTextbox = TogglePartAimbot:CreateTextbox({
		ButtonText = "Part Aimbot Path",
		PlaceholderText = "[Folder]",
		MouseButton1Click = function()
			local LoadedString = Loadstring(`return {PartAimbotPathTextbox.Textbox.Text}`)
			if typeof(LoadedString) == "function" then
				PartAimbotFolder = LoadedString()
			else
				Notify({
					Text = LoadedString
				})
			end
		end,
	})
	TogglePartAimbotWallCheck = TogglePartAimbot:CreateToggle({
		Text = "Wall Check",
		EnabledIndicatorDefault = true,
		MouseButton1Click = function(Bool)
			
		end,
	})
	local PartAimbotModeDropdown = TogglePartAimbot:CreateDropdown({
		Text = "Aimbot Mode",
		Default = "Part",
		AutoUpdateText = true,
	})
	PartAimbotModeDropdown:CreateButton({
		Text = "Part",
		Function = function()
			PartAimbotMode = "Part"
		end,
	})
	PartAimbotModeDropdown:CreateButton({
		Text = "Model",
		Function = function()
			PartAimbotMode = "Model"
		end,
	})
	local PartAimbotTargetDropdown = TogglePartAimbot:CreateDropdown({
		Text = "Target",
		Default = "Head",
		AutoUpdateText = true,
	})
	PartAimbotTargetDropdown:CreateButton({
		Text = "Head",
		Function = function()
			PartAimbotTarget = "Head"
		end,
	})
	PartAimbotTargetDropdown:CreateButton({
		Text = "HumanoidRootPart",
		Function = function()
			PartAimbotTarget = "HumanoidRootPart"
		end,
	})
	local PartAimbotMethodDropdown = TogglePartAimbot:CreateDropdown({
		Text = "Part Aimbot Method",
		Default = "CFrame",
		AutoUpdateText = true,
	})
	PartAimbotMethodDropdown:CreateButton({
		Text = "CFrame",
		Function = function()
			PartAimbotMethod = "CFrame"
		end,
	})
	PartAimbotMethodDropdown:CreateButton({
		Text = "Mouse Move Rel",
		Function = function()
			PartAimbotMethod = "MouseMoveRel"
		end,
	})
	TogglePartAimbot:CreateSlider({
		Text = "X Size (In Pixels)",
		Min = 0,
		Default = 480,
		Max = 1920,
		Function = function(Val)
			PartAimbotSize = Vector2.new(Val, PartAimbotSize.Y)
		end,
		Function2 = function(Val)
			PartAimbotSize = Vector2.new(Val, PartAimbotSize.Y)
		end,
	})
	TogglePartAimbot:CreateSlider({
		Text = "Y Size (In Pixels)",
		Min = 0,
		Default = 360,
		Max = 1080,
		Function = function(Val)
			PartAimbotSize = Vector2.new(PartAimbotSize.X, Val)
		end,
		Function2 = function(Val)
			PartAimbotSize = Vector2.new(PartAimbotSize.X, Val)
		end,
	})
    PartAimbotExcludeWithPropertyTextbox = nil; PartAimbotExcludeWithPropertyTextbox = TogglePartAimbot:CreateTextbox({
        ButtonText = "Exclude",
        PlaceholderText = `[npc.Property == Property]`,
        Info = 'You can use this for checking if the npc has a certain property or attribute. Use "{...}[1]" to access the npc instance',
        FocusLost = function()
            PartAimbotExcludeWithProperty = PartAimbotExcludeWithPropertyTextbox.Textbox.Text
        end,
    })
end

----------------------------------------------------------------------------------------------------- Player Category

do
	local function NoclipFunction()
		local Char = GetChar(Plr)
		if not Char then return end
		for i, v in ipairs(Char:GetDescendants()) do
			if v:IsA("BasePart") then
				v.CanCollide = false
			end
		end
	end

	ToggleNoclip = PlayerCategory:CreateToggle({
		Text = "Noclip",
		Info = "Disables the collision of your character allowing you to walk through walls.",
		MouseButton1Click = function(Noclip)
			if Noclip then
				Connections.Player.NoclipLoop = RunService.Stepped:Connect(NoclipFunction)
			else
				if Connections.Player.NoclipLoop then 
					Connections.Player.NoclipLoop:Disconnect()
					Connections.Player.NoclipLoop = nil
				end
			end
		end,
	})
end

do
	local SpasmAnim = nil
	local LoadedSpasmAnim = nil

	ToggleSpasm = PlayerCategory:CreateToggle({
		Text = "Spasm",
		Info = "Makes your character spasm (only works in R6).",
		MouseButton1Click = function(Spasm)
            if R15(Plr) then
                return
            end
			if Spasm then
				local Char = GetChar(Plr)
                local Humanoid = GetHumanoid(Char)
                if Char and Humanoid then
                    SpasmAnim = Instance.new("Animation")
                    SpasmAnim.AnimationId = "rbxassetid://33796059"
                    LoadedSpasmAnim = Humanoid:LoadAnimation(SpasmAnim)
                    LoadedSpasmAnim.Priority = Enum.AnimationPriority.Action4
                    LoadedSpasmAnim.Looped = true
                    LoadedSpasmAnim:Play()
                    LoadedSpasmAnim:AdjustSpeed(99)
                end
			else
				if LoadedSpasmAnim then
					LoadedSpasmAnim:Stop()
					LoadedSpasmAnim = nil
				end
				if SpasmAnim then 
					SpasmAnim:Destroy()
					SpasmAnim = nil
				end
			end
		end,
	})
end

do
	local Anim = nil
	local LoadedAnim = nil

	ToggleHeadThrow = PlayerCategory:CreateToggle({
		Text = "Head Throw",
		Info = "It literally just throws your head (only works in R6).",
		MouseButton1Click = function(HeadThrow)
            if R15(Plr) then
                return
            end
			if HeadThrow then
				local Char = GetChar(Plr)
                local Humanoid = GetHumanoid(Char)
                if Char and Humanoid then
                    Anim = Instance.new("Animation")
                    Anim.AnimationId = "rbxassetid://35154961"
                    LoadedAnim = Humanoid:LoadAnimation(Anim)
                    LoadedAnim.Priority = Enum.AnimationPriority.Action4
                    LoadedAnim.Looped = true
                    LoadedAnim:Play()
                    LoadedAnim:AdjustSpeed(1)
                end
			else
				if LoadedAnim then
					LoadedAnim:Stop()
					LoadedAnim = nil
				end
				if Anim then 
					Anim:Destroy()
					Anim = nil
				end
			end
		end,
	})
end

ToggleAntiFling = PlayerCategory:CreateToggle({
	Text = "Anti Fling",
	Info = "Prevents you from getting flung by disabling collision with all other players.",
	Function = function(AntiFling)
		if AntiFling then
			Connections.Other.AntiFlingLoop = RunService.Stepped:Connect(function()
				for i, Player in ipairs(Players:GetPlayers()) do
                    if Player == Plr or Player.UserId == Plr.UserId then continue end
					local PlayerChar = GetChar(Player)
					if not PlayerChar then continue end
					for i, Part in ipairs(PlayerChar:GetDescendants()) do
						if Part:IsA("BasePart") then
							Part.CanCollide = false
						end
					end
				end
			end)
		else
			if Connections.Other.AntiFlingLoop then
				Connections.Other.AntiFlingLoop:Disconnect()
				Connections.Other.AntiFlingLoop = nil
			end
		end
	end,
})

ToggleFreezeAnimations = PlayerCategory:CreateToggle({
    Text = "Freeze Animations",
    Info = "Freezes all your character's animations.",
    MouseButton1Click = function(FreezeAnimations)
        if FreezeAnimations then
            Connections.FreezeAnimationsConnection = RunService.PreAnimation:Connect(function()
                local Char = GetChar(Plr)
                local Humanoid = GetHumanoid(Char)
                if not (Char and Humanoid) then return end
                for i, v in ipairs(Humanoid:GetPlayingAnimationTracks()) do
                    v:AdjustSpeed(0)
                end
                local Animator = Humanoid:FindFirstChildWhichIsA("Animator")
                if not Animator then return end
                for i, v in ipairs(Animator:GetPlayingAnimationTracks()) do
                    v:AdjustSpeed(0)
                end
            end)
        else
            if Connections.FreezeAnimationsConnection then
                Connections.FreezeAnimationsConnection:Disconnect()
                Connections.FreezeAnimationsConnection = nil
            end
            local Char = GetChar(Plr)
            local Humanoid = GetHumanoid(Char)
            if not (Char and Humanoid) then return end
            for i, v in ipairs(Humanoid:GetPlayingAnimationTracks()) do
                v:AdjustSpeed(1)
            end
            local Animator = Humanoid:FindFirstChildWhichIsA("Animator")
            if not Animator then return end
            for i, v in ipairs(Animator:GetPlayingAnimationTracks()) do
                v:AdjustSpeed(1)
            end
        end
    end,
})

ToggleStrengthen = PlayerCategory:CreateToggle({
	Text = "Strengthen",
	Info = "Makes your character stronger allowing you to push heavy parts easily.",
	MouseButton1Click = function(Strengthen)
		if Strengthen then
			Connections.Player.StrengthenLoop = RunService.Stepped:Connect(function()
				local Char = GetChar(Plr)
				if not Char then return end
				for i, Part in pairs(Char:GetDescendants()) do
					if Part:IsA("BasePart") then
						Part.CustomPhysicalProperties = PhysicalProperties.new(StrengthenDensity, Part.CustomPhysicalProperties.Friction, Part.CustomPhysicalProperties.Elasticity)
					end
				end
			end)
		else
			if Connections.Player.StrengthenLoop then
				Connections.Player.StrengthenLoop:Disconnect()
				Connections.Player.StrengthenLoop = nil
			end
			local Char = GetChar(Plr)
			if not Char then return end
			for i, Part in pairs(Char:GetDescendants()) do
				if Part:IsA("BasePart") then
                    Part.CustomPhysicalProperties = PhysicalProperties.new(0.7, Part.CustomPhysicalProperties.Friction, Part.CustomPhysicalProperties.Elasticity)
                end
			end
		end
	end,
})

ToggleStrengthen:CreateSlider({
    Text = "Density",
    Min = 0,
    Default = 0.7,
    Max = 100,
    Function = function(Val)
        StrengthenDensity = Val
    end,
    Function2 = function(Val)
        StrengthenDensity = Val
    end,
})

BreakVelocity = PlayerCategory:CreateButton({
	Text = "Break Velocity",
	Info = "Breaks the velocity of your character.",
	MouseButton1Click = function()
        local Thread = task.spawn(function()
            while true do
                local Char = GetChar(Plr)
                local Root = GetRoot(Char)
                RunService.Stepped:Wait()
                if not (Char and Root) then continue end
                Root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                Root.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                RunService.Heartbeat:Wait()
                if not (Char and Root) then continue end
                Root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                Root.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
            end
        end)
        task.delay(1, task.cancel, Thread)
	end,
})

do
	local function UpdateHipHeight()
        if not ToggleHipHeight.Boolean then return end
		local Char = GetChar(Plr)
		local Humanoid = GetHumanoid(Char)
		if not (Char and Humanoid) then return end
		Humanoid.HipHeight = HipHeight
	end

	ToggleHipHeight = PlayerCategory:CreateToggle({
		Text = "Hip Height",
		Info = "Sets your character's hip height to the specified value.",
		MouseButton1Click = function(HipHeightEnabled)
			if HipHeightEnabled then
				local Char = GetChar(Plr)
				local Humanoid = GetHumanoid(Char)
                UpdateHipHeight()
				Connections.Other.LoopHipHeightConnection = Humanoid and Humanoid:GetPropertyChangedSignal("HipHeight"):Connect(UpdateHipHeight)
			else
				if Connections.Movement.LoopHipHeightConnection then
					Connections.Movement.LoopHipHeightConnection:Disconnect()
					Connections.Other.LoopHipHeightConnection = nil
				end
			end
		end,
	})

	ToggleHipHeight:CreateSlider({
		Text = "Hip Height",
		Min = 0,
		Max = 100,
		Default = 3.1,
		Function = function(Val)
			HipHeight = Val
            UpdateHipHeight()
		end,
		Function2 = function(Val)
			HipHeight = Val
            UpdateHipHeight()
		end,
	})
end

ToggleLoopNoSit = nil

ToggleLoopSit = PlayerCategory:CreateToggle({
	Text = "Sit",
	Info = "Forces your character to sit.",
	MouseButton1Click = function(LoopSit)
		if LoopSit then
           	ToggleLoopNoSit:Disable({NoNotify = true})
			local Char = GetChar(Plr)
			local Humanoid = GetHumanoid(Char)
            if not (Char and Humanoid) then return end
			Humanoid.Sit = true
            Connections.Other.LoopSit = Humanoid:GetPropertyChangedSignal("Sit"):Connect(function()
                Humanoid.Sit = true
            end)
		else
			if Connections.Other.LoopSit then
				Connections.Other.LoopSit:Disconnect()
				Connections.Other.LoopSit = nil
			end
		end
	end,
})

ToggleLoopNoSit = PlayerCategory:CreateToggle({
	Text = "No Sit",
	Info = "Forces your character to not sit.",
	MouseButton1Click = function(LoopNoSit)
		ToggleLoopSit:Disable({NoNotify = true})
		if LoopNoSit then
			local Char = GetChar(Plr)
			local Humanoid = GetHumanoid(Char)
            if not (Char and Humanoid) then return end
			Humanoid.Sit = false
            Connections.Other.LoopNoSit = Humanoid:GetPropertyChangedSignal("Sit"):Connect(function()
                Humanoid.Sit = false
            end)
		else
			if Connections.Other.LoopNoSit then
				Connections.Other.LoopNoSit:Disconnect()
				Connections.Other.LoopNoSit = nil
			end
		end
	end,
})

ForceLaydown = PlayerCategory:CreateButton({
	Text = "Laydown",
	Info = "Makes your character laydown.",
	MouseButton1Click = function()
		local Char = GetChar(Plr)
		local Humanoid = GetHumanoid(Char)
        if not (Char and Humanoid) then return end
		Humanoid.Sit = true
        task.wait(0.1)
        local Root = GetRoot(Char)
        if Root then
            Root.CFrame = Root.CFrame * CFrame.Angles(math.pi * 0.5, 0, 0)
        end
        if not Humanoid then return end
        for i, v in pairs(Humanoid:GetPlayingAnimationTracks()) do
            v:Stop()
        end
        local Animator = Humanoid:FindFirstAncestorWhichIsA("Animator")
        if Animator then
            for i, v in pairs(Animator:GetPlayingAnimationTracks()) do
                v:Stop()
            end
        end
	end,
})

RefreshAnimations = PlayerCategory:CreateButton({
	Text = "Refresh Animations",
	Info = "Refreshes all of your character's animations.",
	MouseButton1Click = function()
		local Char = GetChar(Plr)
		local Humanoid = GetHumanoid(Char)
		local Animate = Char:FindFirstChild("Animate")
        if Animate then
            Animate.Disabled = true
            task.wait()
            Animate.Enabled = true
        end
        if not (Char and Humanoid) then return end
        for i, v in pairs(Humanoid:GetPlayingAnimationTracks()) do
            v:Stop()
        end
        local Animator = Humanoid:FindFirstChildWhichIsA("Animator")
        if not Animator then return end
        for i, v in pairs(Humanoid:GetPlayingAnimationTracks()) do
            v:Stop()
        end
	end,
})

DestroyCharacterVelocityInstances = PlayerCategory:CreateButton({
	Text = "Delete Body Movers",
	Info = "Deletes all body movers from your character.",
	MouseButton1Click = function()
		local Char = GetChar(Plr)
        if not Char then return end
		for i, v in pairs(Char:GetDescendants()) do
            if v:IsA("Mover") or v:IsA("AngularVelocity") or v:IsA("LinearVelocity") or v:IsA("AlignPosition") or v:IsA("AlignOrientation") or v:IsA("VectorForce") or v:IsA("Torque") or v:IsA("LineForce") then
                v:Destroy()
            end
        end
	end,
})

FixCamera = PlayerCategory:CreateButton({
	Text = "Fix Camera",
	Info = "Attempts to fix your camera.",
	MouseButton1Click = function()
		ToggleViewPlayer:Disable({NoNotify = true})
		ToggleFreecam:Disable({NoNotify = true})
		local Char = GetChar(Plr)
		local Root = GetRoot(Char)
		local Humanoid = GetHumanoid(Char)
		if Char and Humanoid then
			workspace.CurrentCamera.CameraSubject = Humanoid
		elseif Char and Char:FindFirstChild("Head") then
			workspace.CurrentCamera.CameraSubject = Char:FindFirstChild("Head")
		elseif Char and Root then
			workspace.CurrentCamera.CameraSubject = Root
		end
		workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	end,
})

ToggleNoclipCamera = PlayerCategory:CreateToggle({
	Text = "Noclip Camera",
	Info = "Allows your camera to go through walls.",
	MouseButton1Click = function(NoclipCamera)
        if not SetConstant then return NotifyExploitDoesntSupportFunction("SetConstant") end
        if not GetConstants then return NotifyExploitDoesntSupportFunction("GetConstants") end
        if not Getgc then return NotifyExploitDoesntSupportFunction("Getgc") end
        local Pop = Plr:FindFirstChildWhichIsA("PlayerScripts").PlayerModule.CameraModule.ZoomController.Popper
		for i, v in pairs(Getgc()) do
            if type(v) == "function" and getfenv(v).script == Pop then
                for i2, v2 in pairs(GetConstants(v)) do
                    if tonumber(v2) == 0.25 and NoclipCamera then
                        SetConstant(v, i2, 0)
                    elseif tonumber(v2) == 0 and not NoclipCamera then
                        SetConstant(v, i2, 0.25)
                    end
                end
            end
        end
	end,
})

ClientAntiKick = nil; ClientAntiKick = PlayerCategory:CreateButton({
	Text = "Client Anti Kick",
	Info = "Prevents local scripts from kicking you.",
	MouseButton1Click = function()
        if not Hookmetamethod then NotifyExploitDoesntSupportFunction("Hookmetamethod"); return end
        if not GetNameCallMethod then NotifyExploitDoesntSupportFunction("GetNameCallMethod"); return end
		local OldIndex; OldIndex = Hookmetamethod(game, "__index", NewCClosure(function(self, Key)
            if self == Plr and Key:lower() == "kick" then
                return error("Expected ':' not '.' calling member function Kick", 2)
            end
            return OldIndex(self, Key)
        end))
        local OldNameCall; OldNameCall = Hookmetamethod(game, "__namecall", NewCClosure(function(self, ...)
            if self == Plr and GetNameCallMethod():lower() == "kick" then
                return
            end
            return OldNameCall(self, ...)
        end))
        ModuleToggled(ClientAntiKick, "ClientAntiKick", true)
	end,
})

ClientAntiTeleport = nil; ClientAntiTeleport = PlayerCategory:CreateButton({
	Text = "Client Anti Teleport",
	Info = "Prevents local scripts from teleporting you.",
	MouseButton1Click = function()
        if not Hookmetamethod then NotifyExploitDoesntSupportFunction("Hookmetamethod") return end
        if not GetNameCallMethod then NotifyExploitDoesntSupportFunction("GetNameCallMethod") return end
		local OldIndex; OldIndex = Hookmetamethod(game, "__index", NewCClosure(function(self, Key)
            if self == TeleportService then
                if Key:lower() == "teleport" then
                    return error("Expected ':' not '.' calling member function Kick", 2)
                elseif Key == "TeleportToPlaceInstance" then
                    return error("Expected ':' not '.' calling member function TeleportToPlaceInstance", 2)
                end
            end
            return OldIndex(self, Key)
        end))
        local OldNameCall; OldNameCall = Hookmetamethod(game, "__namecall", NewCClosure(function(self, ...)
            if self == TeleportService and GetNameCallMethod():lower() == "teleport" or GetNameCallMethod() == "TeleportToPlaceInstance" then
                return
            end
            return OldNameCall(self, ...)
        end))
        ModuleToggled(ClientAntiTeleport, "ClientAntiTeleport", true)
	end,
})

ToggleAntiRagdoll = PlayerCategory:CreateToggle({
	Text = "Anti Ragdoll",
	Info = "Prevents you from getting ragdolled.",
	MouseButton1Click = function(AntiRagdoll)
		local Char = GetChar(Plr)
		local Humanoid = GetHumanoid(Char)
		if AntiRagdoll then
            if not (Char and Humanoid) then return end
			Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
            Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
            Connections.Player.AntiRagdollLoop = Humanoid.StateEnabledChanged:Connect(function(State, Enabled)
                if State == Enum.HumanoidStateType.FallingDown and Enabled then
                    Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
                elseif State == Enum.HumanoidStateType.Ragdoll and Enabled then
                    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
                end
            end)
		else
			if Char and Humanoid then
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
                Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
			end
			if Connections.Player.AntiRagdollLoop then
				Connections.Player.AntiRagdollLoop:Disconnect()
				Connections.Player.AntiRagdollLoop = nil
			end
		end
	end,
})

do
    Connections.StateConnections = {}

	local function UpdateStates()
		local Char = GetChar(Plr)
		local Humanoid = GetHumanoid(Char)
		if Char and Humanoid then
			local HumanoidStates = Enum.HumanoidStateType:GetEnumItems()
			table.remove(HumanoidStates, 17)
			for i, v in ipairs(HumanoidStates) do
				if table.find(StatesDisabled, v.Name) then
					if DisableState then
						Humanoid:SetStateEnabled(v, false)
					end
				else
					Humanoid:SetStateEnabled(v, true)
				end
			end
		end
	end
	
	ToggleDisableState = PlayerCategory:CreateToggle({
		Text = "Disable State",
		Info = "Disables the specified humanoid states.",
		MouseButton1Click = function(DisableState)
			if DisableState then
				local Char = GetChar(Plr)
				local Humanoid = GetHumanoid(Char)
				for i, v in pairs(StatesDisabled) do
					Connections.StateConnections[v] = Humanoid and Humanoid.StateEnabledChanged:Connect(function(State, Enabled)
						if Enabled and table.find(StatesDisabled, State.Name) then
							Humanoid:SetStateEnabled(State, false)
						end
					end)
				end
			else
				for i, v in pairs(Connections.StateConnections) do
					v:Disconnect()
				end
                table.clear(Connections.StateConnections)
			end
		end,
	})
end

HumanoidStatesDropdown = ToggleDisableState:CreateDropdown({
    Text = "State",
    Default = "",
})

for i, HumanoidState in ipairs(Enum.HumanoidStateType:GetEnumItems()) do
	HumanoidStatesDropdown:CreateButton({
		Text = HumanoidState.Name,
		On = function()
			if not table.find(StatesDisabled, HumanoidState.Name) then
				table.insert(StatesDisabled, HumanoidState.Name)
			end
		end,
		Off = function()
			local Index = table.find(StatesDisabled, HumanoidState.Name)
			if Index then
				table.remove(StatesDisabled, Index)
			end
		end,
	})
end

DropTools = PlayerCategory:CreateButton({
	Text = "Drop Tools",
	Info = "Drops all the tools in your backpack. If you have alot of tools it will lag.",
	MouseButton1Click = function()
		local Backpack = Plr:FindFirstChildWhichIsA("Backpack")
		local Char = GetChar(Plr)
		if not (Char or Backpack) then return end
		for i, v in ipairs(Backpack:GetChildren()) do
			if v:IsA("Tool") then
				v.Parent = Char
			end
		end
		task.wait(0.1)
		RunService.Heartbeat:Wait()
		for i, v in ipairs(Char:GetChildren()) do
			if v:IsA("Tool") then
				v.Parent = workspace
			end
		end
	end,
})

do
	local BangAnim = nil
	local LoadedBangAnim = nil

	BangPlayer = PlayerCategory:CreateTextbox({
		ButtonText = "Bang",
		PlaceholderText = "[Player Name]",
        Info = "It makes you bang a player probably. Leave blank to only do the animation.",
		EnabledIndicator = true,
		MouseButton1Click = function(BangEnabled)
			if BangEnabled then
				local Char = GetChar(Plr)
				local Root = GetRoot(Char)
				local Humanoid = GetHumanoid(Char)

				if not (Char and Root and Humanoid) then return end

				BangAnim = Instance.new("Animation")
				BangAnim.AnimationId = R15(Plr) and "rbxassetid://99494504509493" or "rbxassetid://148840371"
				
				LoadedBangAnim = Humanoid:LoadAnimation(BangAnim)
                LoadedBangAnim.Priority = Enum.AnimationPriority.Action4
				LoadedBangAnim.Looped = true
				LoadedBangAnim:Play(0.1, 1, BangSpeed)
				
				local BangOffset = CFrame.new(0, 0, 1.1)

				if BangPlayer.Textbox.Text == "" then return end

				local Player = FindPlayer(BangPlayer.Textbox.Text)
				local PlayerChar = GetChar(Player)
				local PlayerRoot = GetRoot(PlayerChar)

				Connections.Player.BangLoop = RunService.Heartbeat:Connect(function()
					Char = GetChar(Plr)
					Root = GetRoot(Char)
					Humanoid = GetHumanoid(Char)
					Player = FindPlayer(BangPlayer.Textbox.Text)
					PlayerChar = GetChar(Player)
					PlayerRoot = GetRoot(PlayerChar)
					if not (Char and Root and Humanoid and Player and PlayerChar and PlayerRoot) then return end 
					Root.CFrame = PlayerRoot.CFrame * BangOffset
				end)
			else
				if Connections.Player.BangLoop then
					Connections.Player.BangLoop:Disconnect()
					Connections.Player.BangLoop = nil
				end
				if BangAnim then
					BangAnim:Destroy()
					BangAnim = nil
				end
				if LoadedBangAnim then
					LoadedBangAnim:Stop()
					LoadedBangAnim = nil
				end
			end
		end,
	})

    BangPlayer:CreateSlider({
        Text = "Bang Speed",
        Min = 1,
        Max = 10,
        Default = BangSpeed,
        Function = function(Val)
            BangSpeed = Val
            if LoadedBangAnim then
                LoadedBangAnim:AdjustSpeed(BangSpeed)
            end
        end,
        Function2 = function(Val)
            BangSpeed = Val
            if LoadedBangAnim then
                LoadedBangAnim:AdjustSpeed(BangSpeed)
            end
        end,
    })

	local JerkAnim = nil
	local LoadedJerkAnim = nil

	ToggleJerk = PlayerCategory:CreateToggle({
		Text = "Jerk",
        Info = "It makes you jork it.",
		MouseButton1Click = function(Jerking)
			if Jerking then
				local Char = GetChar(Plr)
				local Humanoid = GetHumanoid(Char)
				if not (Char and Humanoid) then return end
                local IsR15 = R15(Plr)
				JerkAnim = Instance.new("Animation")
            	JerkAnim.AnimationId = IsR15 and "rbxassetid://698251653" or "rbxassetid://72042024"
				LoadedJerkAnim = Humanoid:LoadAnimation(JerkAnim)
                LoadedJerkAnim.Priority = Enum.AnimationPriority.Action4
				LoadedJerkAnim.Looped = true
				LoadedJerkAnim:Play()
				LoadedJerkAnim:AdjustSpeed(IsR15 and 0.7 or 0.65)
                LoadedJerkAnim.TimePosition = 0.6
				Connections.Player.JerkThread = task.spawn(function()
                    while true do
						Char = GetChar(Plr)
						Humanoid = GetHumanoid(Char)
						if not (Char and Humanoid) then task.wait(); continue end
                        task.wait(IsR15 and 0.2 or 0.15)
						LoadedJerkAnim.TimePosition = 0.6
                    end
				end)
			else
                if Connections.Player.JerkThread then
                    task.cancel(Connections.Player.JerkThread)
                    Connections.Player.JerkThread = nil
                end
				if JerkAnim then
					JerkAnim:Destroy()
					JerkAnim = nil
				end
				if LoadedJerkAnim then
					LoadedJerkAnim:Stop()
					LoadedJerkAnim = nil
				end
			end
		end,
	})
end

do
	local Anim = nil
	local LoadedAnim = nil
	
	PlayAnimation = nil; PlayAnimation = PlayerCategory:CreateTextbox({
		ButtonText = "Play Anim",
		PlaceholderText = "[Animation Id]",
        Info = "Plays an animation with the specified animation id.",
		EnabledIndicator = true,
		MouseButton1Click = function(AnimationPlaying)
			if AnimationPlaying then
				local Char = GetChar(Plr)
				local Humanoid = GetHumanoid(Char)
				if not (Char and Humanoid) then return end
				local Anim = Instance.new("Animation")
				if PlayAnimation.Textbox:find("rbxassetid://") then
					Anim.AnimationId = PlayAnimation.Textbox.Text
				else
					Anim.AnimationId = "rbxassetid://" .. PlayAnimation.Textbox.Text
				end
				LoadedAnim = Humanoid:LoadAnimation(Anim)
                LoadedAnim.Priority = Enum.AnimationPriority.Action4
				LoadedAnim.Looped = true
				LoadedAnim:Play()
			else
				if Anim then
					Anim:Destroy()
					Anim = nil
				end
				if LoadedAnim then
					LoadedAnim:Stop()
					LoadedAnim = nil
				end
			end
		end,
	})
end

do
	local Anim = nil
	local LoadedAnim = nil
	local R6Dance = "27789359"
	local R15Dance = "3333432454"

	ToggleDance = PlayerCategory:CreateToggle({
		Text = "Dance",
		Info = "It makes you dance.",
		MouseButton1Click = function(Dancing)
			if Dancing then
				local Char = GetChar(Plr)
				local Humanoid = GetHumanoid(Char)
				if not (Char and Humanoid) then return end
				Anim = Instance.new("Animation")
				Anim.AnimationId = R15(Plr) and "rbxassetid://" .. R15Dance or "rbxassetid://" .. R6Dance
				LoadedAnim = Humanoid:LoadAnimation(Anim)
                LoadedAnim.Priority = Enum.AnimationPriority.Action4
				LoadedAnim.Looped = true
				LoadedAnim:Play()
			else
				if Anim then
					Anim:Destroy()
					Anim = nil
				end
				if LoadedAnim then
					LoadedAnim:Stop()
					LoadedAnim = nil
				end
			end
		end,
	})

	local R6DancesDropdown = ToggleDance:CreateDropdown({
		Text = "R6 Dances",
		Default = "27789359",
		AutoUpdateText = true,
	})
	R6DancesDropdown:CreateButton({
		Text = "27789359",
		Function = function()
			R6Dance = "27789359"
		end,
	})
	R6DancesDropdown:CreateButton({
		Text = "30196114",
		Function = function()
			R6Dance = "30196114"
		end,
	})
	R6DancesDropdown:CreateButton({
		Text = "248263260",
		Function = function()
			R6Dance = "248263260"
		end,
	})
	R6DancesDropdown:CreateButton({
		Text = "45834924",
		Function = function()
			R6Dance = "45834924"
		end,
	})
	R6DancesDropdown:CreateButton({
		Text = "33796059",
		Function = function()
			R6Dance = "33796059"
		end,
	})
	R6DancesDropdown:CreateButton({
		Text = "28488254",
		Function = function()
			R6Dance = "28488254"
		end,
	})
	R6DancesDropdown:CreateButton({
		Text = "52155728",
		Function = function()
			R6Dance = "52155728"
		end,
	})

	local R15DancesDropdown = ToggleDance:CreateDropdown({
		Text = "R15 Dances",
		Default = "3333432454",
		AutoUpdateText = true,
	})
	R15DancesDropdown:CreateButton({
		Text = "3333432454",
		Function = function()
			R15Dance = "3333432454"
		end,
	})
	R15DancesDropdown:CreateButton({
		Text = "4555808220",
		Function = function()
			R15Dance = "4555808220"
		end,
	})
	R15DancesDropdown:CreateButton({
		Text = "4049037604",
		Function = function()
			R15Dance = "4049037604"
		end,
	})
	R15DancesDropdown:CreateButton({
		Text = "4555782893",
		Function = function()
			R15Dance = "4555782893"
		end,
	})
	R15DancesDropdown:CreateButton({
		Text = "Break Dance",
		Function = function()
			R15Dance = "10214311282"
		end,
	})
	R15DancesDropdown:CreateButton({
		Text = "10714010337",
		Function = function()
			R15Dance = "10714010337"
		end,
	})
	R15DancesDropdown:CreateButton({
		Text = "10713981723",
		Function = function()
			R15Dance = "10713981723"
		end,
	})
	R15DancesDropdown:CreateButton({
		Text = "10714372526",
		Function = function()
			R15Dance = "10714372526"
		end,
	})
	R15DancesDropdown:CreateButton({
		Text = "10714076981",
		Function = function()
			R15Dance = "10714076981"
		end,
	})
	R15DancesDropdown:CreateButton({
		Text = "10714392151",
		Function = function()
			R15Dance = "10714392151"
		end,
	})
	R15DancesDropdown:CreateButton({
		Text = "11444443576",
		Function = function()
			R15Dance = "11444443576"
		end,
	})
end

----------------------------------------------------------------------------------------------------- Movement Category

do
	local LinearVel
	local VectorForce
	local BodyForce
	local BodyVel
	local PrevSpeed
	local AlignPos
	local BodyThrust
	local LineForce
	local LineForcePart
	local Attachment0
	local Attachment1
    
	local function ChangeWalkSpeed()
		if ToggleSpeedHack.Boolean and SpeedHackMethod == "WalkSpeed" then
			local Char = GetChar(Plr)
			local Humanoid = GetHumanoid(Char)
			if Char and Humanoid then
				if PrevSpeed and OnlyWhenSpeedLowered and Humanoid.WalkSpeed >= PrevSpeed then return end
                if IsDeadByRoblox then
                    local PlayerValues = Plr:FindFirstChild("PlayerValues")
                    if PlayerValues then
                        PlayerValues:SetAttribute("Speed", WalkSpeed)
                    end
                else
                    Humanoid.WalkSpeed = WalkSpeed
				    PrevSpeed = Humanoid.WalkSpeed
                end
			end
		end
	end

    local function DisconnectWalkSpeedConnections()
        if Connections.Movement.SpeedHackWalkSpeedLoop then
            Connections.Movement.SpeedHackWalkSpeedLoop:Disconnect()
            Connections.Movement.SpeedHackWalkSpeedLoop = nil
        end
        if Connections.Movement.SpeedHackHumanoidDestroyed then
            Connections.Movement.SpeedHackHumanoidDestroyed:Disconnect()
            Connections.Movement.SpeedHackHumanoidDestroyed = nil
        end
    end

	local function DestroyAllMovers()
		if LinearVel then
			LinearVel:Destroy()
			LinearVel = nil
		end
		if BodyForce then
			BodyForce:Destroy()
			BodyForce = nil
		end
		if BodyVel then
			BodyVel:Destroy()
			BodyVel = nil
		end
        if Attachment0 then
			Attachment0:Destroy()
			Attachment0 = nil
		end
		if Attachment1 then
			Attachment1:Destroy()
			Attachment1 = nil
		end
        DisconnectWalkSpeedConnections()
	end
    
    ToggleSpeedHack = nil; ToggleSpeedHack = Movement:CreateToggle({
		Text = "Speed Hack",
		Info = "Increases your speed using various methods.",
		MouseButton1Click = function(SpeedHack)
			if SpeedHack then
				local Char = GetChar(Plr)
				local Humanoid = GetHumanoid(Char)
                local Root = GetRoot(Char)
                
				Connections.Movement.SpeedHackLoop = RunService.Heartbeat:Connect(function(Delta)
					if not (Char and Root and Humanoid and Char.Parent and Root.Parent and Humanoid.Parent) then
						Char = GetChar(Plr)
						Root = GetRoot(Char)
						Humanoid = GetHumanoid(Char)
						return
					end

                    local MoveDirection = Humanoid.MoveDirection
					if SpeedHackMethod == "WalkSpeed" then
                        if IsDeadByRoblox then
                            local PlayerValues = Plr:FindFirstChild("PlayerValues")
                            if PlayerValues and not Connections.Movement.SpeedHackWalkSpeedLoop then
                                ChangeWalkSpeed()
                                Connections.Movement.SpeedHackWalkSpeedLoop = PlayerValues:GetAttributeChangedSignal("Speed"):Connect(ChangeWalkSpeed)
                            end
                        else
                            if not Connections.Movement.SpeedHackWalkSpeedLoop then
                                ChangeWalkSpeed()
                                Connections.Movement.SpeedHackWalkSpeedLoop = Humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(ChangeWalkSpeed)
                            end
                            if not Connections.Movement.SpeedHackHumanoidDestroyed then
                                Connections.Movement.SpeedHackHumanoidDestroyed = Humanoid.AncestryChanged:Connect(function(self, Parent)
                                    if Parent == nil then
                                        Connections.Movement.SpeedHackHumanoidDestroyed:Disconnect()
                                        Connections.Movement.SpeedHackHumanoidDestroyed = nil
                                        if Connections.Movement.SpeedHackWalkSpeedLoop then
                                            Connections.Movement.SpeedHackWalkSpeedLoop:Disconnect()
                                            Connections.Movement.SpeedHackWalkSpeedLoop = nil
                                        end
                                    end
                                end)
                            end
                        end
					elseif SpeedHackMethod == "LinearVelocity" then
						if LinearVel then
                            if SpeedHackUsePercentage then
                                LinearVel.VectorVelocity = MoveDirection * (Humanoid.WalkSpeed * (SpeedPercentage / 100))
                            else
                                LinearVel.VectorVelocity = MoveDirection * WalkSpeed
                            end
						else
							DestroyAllMovers()
							LinearVel = Instance.new("LinearVelocity")
							LinearVel.VectorVelocity = Vector3.new(0, 0, 0)
                            LinearVel.Parent = Root
							Attachment0 = Instance.new("Attachment")
                            Attachment0.Parent = Root
							LinearVel.Attachment0 = Attachment0
							LinearVel.ForceLimitMode = Enum.ForceLimitMode.PerAxis
							LinearVel.MaxAxesForce = Vector3.new(math.huge, 0, math.huge)
							LinearVel.RelativeTo = Enum.ActuatorRelativeTo.World
							LinearVel.AncestryChanged:Once(DestroyAllMovers)
							Attachment0.AncestryChanged:Once(DestroyAllMovers)
						end
					elseif SpeedHackMethod == "BodyForce" then
						if BodyForce then
                            if SpeedHackUsePercentage then
                                BodyForce.Force = (MoveDirection * 250) * (Humanoid.WalkSpeed * (SpeedPercentage / 100))
                            else
                                BodyForce.Force = (MoveDirection * 250) * WalkSpeed
                            end
						else
							DestroyAllMovers()
							BodyForce = Instance.new("BodyForce")
							BodyForce.Force = Vector3.new(0, 0, 0)
                            BodyForce.Parent = Root
							BodyForce.AncestryChanged:Once(DestroyAllMovers)
						end
					elseif SpeedHackMethod == "BodyVelocity" then
						if BodyVel then
                            if SpeedHackUsePercentage then
                                BodyVel.Velocity = MoveDirection * (Humanoid.WalkSpeed * (SpeedPercentage / 100))
                            else
                                BodyVel.Velocity = MoveDirection * WalkSpeed
                            end
						else
							DestroyAllMovers()
							BodyVel = Instance.new("BodyVelocity")
							BodyVel.Velocity = Vector3.new(0, 0, 0)
							BodyVel.MaxForce = Vector3.new(math.huge, 0, math.huge)
                            BodyVel.Parent = Root
							BodyVel.AncestryChanged:Once(DestroyAllMovers)
						end
					elseif SpeedHackMethod == "TpWalk" then
                        if SpeedHackUsePercentage then
                            Char:TranslateBy((MoveDirection * (Humanoid.WalkSpeed * (SpeedPercentage / 100))) * Delta)
                        else
                            Char:TranslateBy((MoveDirection * WalkSpeed) * Delta)
                        end
					elseif SpeedHackMethod == "AssemblyLinearVelocity" then
                        if SpeedHackUsePercentage then
                            Root.AssemblyLinearVelocity = Vector3.new(MoveDirection.X * (Humanoid.WalkSpeed * (SpeedPercentage / 100)), Root.AssemblyLinearVelocity.Y, MoveDirection.Z * (Humanoid.WalkSpeed * (SpeedPercentage / 100)))
                        else
                            Root.AssemblyLinearVelocity = Vector3.new(MoveDirection.X * WalkSpeed, Root.AssemblyLinearVelocity.Y, MoveDirection.Z * WalkSpeed)
                        end
                    end
				end)
			else
                if Connections.Movement.SpeedHackLoop then
                    Connections.Movement.SpeedHackLoop:Disconnect()
                    Connections.Movement.SpeedHackLoop = nil
                end
				DestroyAllMovers()
			end
		end,
	})

    WalkSpeedSlider = ToggleSpeedHack:CreateSlider({
        Text = "Speed",
        Min = 0,
        Default = 16,
        Max = 160,
        Function = function(Val)
            WalkSpeed = Val
            ChangeWalkSpeed()
        end,
        Function2 = function(Val)
            WalkSpeed = Val
            ChangeWalkSpeed()
        end,
    })

    local SpeedHackMethodDropdown = ToggleSpeedHack:CreateDropdown({
        Text = "Speed Hack Method",
        Default = "Walk Speed",
        AutoUpdateText = true,
    })
    SpeedHackMethodDropdown:CreateButton({
        Text = "Walk Speed",
        Info = "The most simple method which just changes your walkspeed to the specified value.",
        Function = function()
            SpeedHackMethod = "WalkSpeed"
        end,
    })
    SpeedHackMethodDropdown:CreateButton({
        Text = "Linear Velocity",
        Info = "Accelerates instantly.",
        Function = function()
            SpeedHackMethod = "LinearVelocity"
            DisconnectWalkSpeedConnections()
        end,
    })
    SpeedHackMethodDropdown:CreateButton({
        Text = "Body Force",
        Info = "Accelerates slow but has high top speed.",
        Function = function()
            SpeedHackMethod = "BodyForce"
            DisconnectWalkSpeedConnections()
        end,
    })
    SpeedHackMethodDropdown:CreateButton({
        Text = "Body Velocity",
        Info = "Accelerates almost instantly and is smoother than linear velocity.",
        Function = function()
            SpeedHackMethod = "BodyVelocity"
            DisconnectWalkSpeedConnections()
        end,
    })
    SpeedHackMethodDropdown:CreateButton({
        Text = "Assembly Linear Velocity",
        Info = "Accelerates almost instantly and is pretty smooth.",
        Function = function()
            SpeedHackMethod = "AssemblyLinearVelocity"
            DisconnectWalkSpeedConnections()
        end,
    })
    SpeedHackMethodDropdown:CreateButton({
        Text = "Tp Walk",
        Info = "Does lots of small and quick teleports.",
        Function = function()
            SpeedHackMethod = "TpWalk"
            DisconnectWalkSpeedConnections()
        end,
    })

    ToggleSpeedHack:CreateToggle({
        Text = "Only When Speed Gets Lowered",
        Info = "Only changes your walkspeed when it gets lowered.",
        Function = function(Bool)
            OnlyWhenSpeedLowered = Bool
        end,
    })
    
    ToggleSpeedHack:CreateToggle({
        Text = "Use Percentage",
        Info = "Uses a percentage of your humanoids walk speed.",
        MouseButton1Click = function(Bool)
            SpeedHackUsePercentage = Bool
        end,
    })

    ToggleSpeedHack:CreateSlider({
        Text = "Speed Percentage",
        Min = 0,
        Default = SpeedPercentage,
        Max = 300,
        Function = function(Val)
            SpeedPercentage = Val
        end,
        Function2 = function(Val)
            SpeedPercentage = Val
        end,
    })
end

do
    local function UpdateJumpPower()
        local Char = GetChar(Plr)
        local Humanoid = GetHumanoid(Char)
        if not (Char and Humanoid and ToggleJumpPower.Enabled) then return end
        Humanoid.JumpPower = JumpPower
        Humanoid.UseJumpPower = true
    end
	
    ToggleJumpPower = Movement:CreateToggle({
        Text = "Jump Power",
        Info = "Sets your jump power the the specified value.",
        Function = function(JumpPowerEnabled)
            if JumpPowerEnabled then
                local Char = GetChar(Plr)
                local Humanoid = GetHumanoid(Char)
                UpdateJumpPower()
                Connections.Movement.JumpPowerCharacterAdded = Plr.CharacterAdded:Connect(function(Char)
                    Humanoid = GetHumanoid(Char) or WaitForChildWhichIsA(Char, "Humanoid", 3)
                    if Humanoid then
                        if Connections.Movement.JumpPowerLoop then
                            Connections.Movement.JumpPowerLoop:Disconnect()
                            Connections.Movement.JumpPowerLoop = nil
                        end
                        if Connections.Movement.UseJumpPowerChanged then
                            Connections.Movement.UseJumpPowerChanged:Disconnect()
                            Connections.Movement.UseJumpPowerChanged = nil
                        end
                        Connections.Movement.JumpPowerLoop = Humanoid:GetPropertyChangedSignal("JumpPower"):Connect(UpdateJumpPower)
                        Connections.Movement.UseJumpPowerChanged = Humanoid:GetPropertyChangedSignal("UseJumpPower"):Connect(UpdateJumpPower)
                    end
                end)
                if Humanoid then
                    Connections.Movement.JumpPowerLoop = Humanoid:GetPropertyChangedSignal("JumpPower"):Connect(UpdateJumpPower)
                    Connections.Movement.UseJumpPowerChanged = Humanoid:GetPropertyChangedSignal("UseJumpPower"):Connect(UpdateJumpPower)
                end
            else
                if Connections.Movement.JumpPowerLoop then
                    Connections.Movement.JumpPowerLoop:Disconnect()
                    Connections.Movement.JumpPowerLoop = nil
                end
                if Connections.Movement.UseJumpPowerChanged then
                    Connections.Movement.UseJumpPowerChanged:Disconnect()
                    Connections.Movement.UseJumpPowerChanged = nil
                end
                if Connections.Movement.JumpPowerCharacterAdded then
                    Connections.Movement.JumpPowerCharacterAdded:Disconnect()
                    Connections.Movement.JumpPowerCharacterAdded = nil
                end
            end
        end,
    })
    JumpPowerSlider = ToggleJumpPower:CreateSlider({
        Text = "Jump Power",
        Min = 0,
        Default = 50,
        Max = 500,
        Function = function(Val)
            JumpPower = Val
            UpdateJumpPower()
        end,
        Function2 = function(Val)
            JumpPower = Val
            UpdateJumpPower()
        end,
    })
end

do
    local function UpdateGravity()
        if ToggleGravity.Enabled then
            workspace.Gravity = Gravity
        end
    end
    ToggleGravity = Movement:CreateToggle({
        Text = "Gravity",
        Info = "Sets your gravity to the specified value.",
        Function = function(GravityEnabled)
            if GravityEnabled then
                UpdateGravity()
                Connections.Movement.GravityLoop = workspace:GetPropertyChangedSignal("Gravity"):Connect(UpdateGravity)
            else
                if Connections.Movement.GravityLoop then 
                    Connections.Movement.GravityLoop:Disconnect()
                    Connections.Movement.GravityLoop = nil
                end
            end
        end,
    })
    GravitySlider = ToggleGravity:CreateSlider({
        Text = "Gravity",
        Min = 0,
        Default = 196.2,
        Max = 1000,
        Function = function(Val)
            Gravity = Val
            UpdateGravity()
        end,
        Function2 = function(Val)
            Gravity = Val
            UpdateGravity()
        end,
    })
end

ToggleInfiniteJump = Movement:CreateToggle({
	Text = "Infinite Jump",
	Info = "Allows you to jump midair.",
	Function = function(InfJump)
		InfiniteJump = InfJump
	end,
})

do
	local PrevSpeedHack
	local BodyVel
	local LinearVel
	local BodyForce
	local AlignOrientation
	local Attachment0
	local Attachment1

	local function DestroyMovers()
		if BodyVel then
			BodyVel:Destroy()
			BodyVel = nil
		end
		if LinearVel then
			LinearVel:Destroy()
			LinearVel = nil
		end
		if AlignOrientation then
			AlignOrientation:Destroy()
			AlignOrientation = nil
		end
        if Attachment0 then
			Attachment0:Destroy()
			Attachment0 = nil
		end
		if Attachment1 then
			Attachment1:Destroy()
			Attachment1 = nil
		end
	end
	
	ToggleFly = Movement:CreateToggle({
		Text = "Fly",
		Info = "It probably allows you to fly through the air.",
		Function = function(Fly)
			if Fly then
				PrevSpeedHack = ToggleSpeedHack.Boolean
				ToggleSpeedHack:Disable({NoNotify = true})

				local Char = GetChar(Plr)
				local Root = GetRoot(Char)
				local Humanoid = GetHumanoid(Char)
				local Vel = Vector3.new(0, 0, 0)
				
				Connections.Movement.FlyLoop = RunService.Heartbeat:Connect(function(Delta)
					Char = GetChar(Plr)
					Root = GetRoot(Char)
					Humanoid = GetHumanoid(Char)
					if not (Char and Root) then return end
                    if ToggleSpeedHackUseAlignOrientation.Enabled then
                        if AlignOrientation and AlignOrientation.Parent ~= nil then
                            AlignOrientation.CFrame = Camera.CFrame
                        else
                            AlignOrientation = Instance.new("AlignOrientation")
                            AlignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment
                            Attachment0 = Instance.new("Attachment")
                            Attachment0.Parent = Root
                            AlignOrientation.Attachment0 = Attachment0
                            AlignOrientation.RigidityEnabled = true
                            AlignOrientation.CFrame = Root.CFrame
                            AlignOrientation.Name = "TidalWaveFlyAlignOrientation"
                            AlignOrientation.Parent = Root
                            AlignOrientation.AncestryChanged:Once(DestroyMovers)
                        end
                    else
                        if AlignOrientation then
                            AlignOrientation:Destroy()
                            AlignOrientation = nil
                        end
                    end
					
                    Vel = Vector3.new(0, 0, 0)

					if not ChatboxFocused() and not TidalWaveFocused then
						if UIS:IsKeyDown(Enum.KeyCode.E) then
							Vel += Camera.CFrame.UpVector
						end
						if UIS:IsKeyDown(Enum.KeyCode.Q) then
							Vel -= Camera.CFrame.UpVector
						end
						if UIS:IsKeyDown(Enum.KeyCode.W) then
							Vel += Camera.CFrame.LookVector
						end
						if UIS:IsKeyDown(Enum.KeyCode.A) then
							Vel -= Camera.CFrame.RightVector
						end
						if UIS:IsKeyDown(Enum.KeyCode.S) then
							Vel -= Camera.CFrame.LookVector
						end
						if UIS:IsKeyDown(Enum.KeyCode.D) then
							Vel += Camera.CFrame.RightVector
						end
					end
					if FlyMethod == "BodyVelocity" then
						if BodyVel then
							BodyVel.Velocity = Vel * FlySpeed
						else
							BodyVel = Instance.new("BodyVelocity")
							BodyVel.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
							BodyVel.Velocity = Vector3.new(0, 0, 0)
							BodyVel.Name = "TidalWaveFlyBodyVelocity"
                            BodyVel.Parent = Root
							BodyVel.AncestryChanged:Once(DestroyMovers)
						end
					elseif FlyMethod == "LinearVelocity" then
						if LinearVel then
							LinearVel.VectorVelocity = Vel * FlySpeed
						else
							LinearVel = Instance.new("LinearVelocity")
							LinearVel.VectorVelocity = Vector3.new(0, 0, 0)
                            Attachment0 = Instance.new("Attachment")
                            Attachment0.Parent = Root
							LinearVel.Attachment0 = Attachment0
							LinearVel.ForceLimitMode = Enum.ForceLimitMode.PerAxis
							LinearVel.MaxAxesForce = Vector3.new(math.huge, math.huge, math.huge)
							LinearVel.RelativeTo = Enum.ActuatorRelativeTo.World
							LinearVel.Name = "SpeedHackLinearVel"
                            LinearVel.Parent = Root
							LinearVel.AncestryChanged:Once(DestroyMovers)
						end
					elseif FlyMethod == "BodyForce" then
						if BodyForce then
							BodyForce.Force = Vector3.new(Vel.X * (50 * FlySpeed), Vel.Y * (75 * FlySpeed), Vel.Z * (50 * FlySpeed))
						else
							BodyForce = Instance.new("BodyForce")
							BodyForce.Force = Vector3.new(0, 0, 0)
							BodyForce.Name = "SpeedHackBodyForce"
                            BodyForce.Parent = Root
							BodyForce.AncestryChanged:Once(DestroyMovers)
						end
					elseif FlyMethod == "TpFly" then
						Root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        if ToggleSpeedHackUsePercentage.Enabled and Humanoid then
                            Char:TranslateBy((Vel * Humanoid.WalkSpeed) * Delta * 2)
                        else
                            Char:TranslateBy((Vel * FlySpeed) * Delta * 2)
                        end
                        RunService.Stepped:Wait()
                        Root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
					elseif FlyMethod == "AssemblyLinearVelocity" then
						Root.AssemblyLinearVelocity = Vel * FlySpeed
					end
				end)
			else
				if Connections.Movement.FlyLoop then
					Connections.Movement.FlyLoop:Disconnect()
					Connections.Movement.FlyLoop = nil
				end
                DestroyMovers()
				if PrevSpeedHack then
					ToggleSpeedHack:Enable({NoNotify = true})
				end
			end
		end,
	})

    FlySpeedSlider = ToggleFly:CreateSlider({
        Text = "Fly Speed",
        Min = 0,
        Default = 50,
        Max = 500,
        Function = function(Val)
            FlySpeed = Val
        end,
        Function2 = function(Val)
            FlySpeed = Val
        end,
    })
    ToggleSpeedHackUseAlignOrientation = ToggleFly:CreateToggle({
        Text = "Align Character",
        Info = "Aligns your character with your camera",
        EnabledIndicatorDefault = true,
        Function = function()
            
        end,
    })
    ToggleSpeedHackUsePercentage = ToggleFly:CreateToggle({
        Text = "Use Percentage",
        Info = "Uses a percentage of your humanoids walk speed.",
        MouseButton1Click = function()
            
        end,
    })
    local FlyMethodDropdown = ToggleFly:CreateDropdown({
        Text = "Fly Method",
        Default = "Body Velocity",
        AutoUpdateText = true,
    })
    FlyMethodDropdown:CreateButton({
        Text = "Linear Velocity",
        Info = "Accelerates instantly.",
        Function = function()
            FlyMethod = "LinearVelocity"
        end,
    })
    FlyMethodDropdown:CreateButton({
        Text = "Body Velocity",
        Info = "Accelerates almost instantly and is smoother than linear velocity.",
        Function = function()
            FlyMethod = "BodyVelocity"
        end,
    })
    FlyMethodDropdown:CreateButton({
        Text = "Body Force",
        Info = "Accelerates slow but has high top speed",
        Function = function()
            FlyMethod = "BodyForce"
        end,
    })
    FlyMethodDropdown:CreateButton({
        Text = "Tp Fly",
        Info = "Does lots of small and quick teleports.",
        Function = function()
            FlyMethod = "TpFly"
        end,
    })
    FlyMethodDropdown:CreateButton({
        Text = "Assembly Linear Velocity",
        Info = "Accelerates almost instantly and is pretty smooth.",
        Function = function()
            FlyMethod = "AssemblyLinearVelocity"
        end,
    })
end

do
	local FloatPart

	local function UpdateFloatPartTransparency(Val)
		if FloatPart and Float.Part.Parent ~= nil then
			FloatPart.Transparency = Val
		end
	end
	
	ToggleFloat = Movement:CreateToggle({
		Text = "Float",
		Info = "Creates an invisible part below you allowing you to float. Press q to go down and press e to go up.",
		Function = function(Float)
			if Float then
				Connections.Movement.FloatFunction = RunService.Heartbeat:Connect(function()
					local Char = GetChar(Plr)
					local Root = GetRoot(Char)
					local Humanoid = GetHumanoid(Char)
					if FloatPart and Char and Root and Humanoid then
						local FloatVal = -(Humanoid.HipHeight + FloatPart.Size.Y)
						if UIS:IsKeyDown("E") then
							FloatVal += 1
						end
						if UIS:IsKeyDown("Q") then
							FloatVal -= 1
						end
						FloatPart.CFrame = Root.CFrame * CFrame.new(0, FloatVal, 0)
					else
						Char = GetChar(Plr)
						Root = GetRoot(Char)
						Humanoid = GetHumanoid(Char)
						if not (Char and Root) then return end
						if (FloatPart and FloatPart.Parent == nil) or FloatPart == nil then
							FloatPart = Instance.new("Part")
							FloatPart.Transparency = FloatPartTransparency
							FloatPart.Size = Vector3.new(2, 0.2, 2)
							FloatPart.Anchored = true
							FloatPart.Parent = workspace
						end
					end
				end)
			else
				if Connections.Movement.FloatFunction then
					Connections.Movement.FloatFunction:Disconnect()
					Connections.Movement.FloatFunction = nil
				end
				if FloatPart then
					FloatPart:Destroy()
					FloatPart = nil
				end
			end
		end,
	})

    ToggleFloat:CreateSlider({
        Text = "Float Part Transparency",
        Min = 0,
        Default = 1,
        Max = 1,
        Function = function(Val)
			UpdateFloatPartTransparency(Val)
        end,
        Function2 = function(Val)
            UpdateFloatPartTransparency(Val)
        end,
    })
end

do
	TeleportToPlayer = nil; TeleportToPlayer = Movement:CreateTextbox({
		ButtonText = "Teleport To Player",
		PlaceholderText = "[Player Name]",
		Info = "Teleports you to the specified player.",
		MouseButton1Click = function()
			local Char = GetChar(Plr)
			local RootPart = GetRoot(Char)
			local Player = FindPlayer(TeleportToPlayer.Textbox.Text)
			local PlayerChar = GetChar(Player)
			local PlayerRootPart = GetRoot(PlayerChar)

			if not (Char and RootPart and Player and PlayerChar and PlayerRootPart) then return end

			local PrevPos = RootPart.CFrame
			RootPart.CFrame = PlayerRootPart.CFrame

			if not PulseTeleport then return end

			task.delay(PulseTeleportTime, function()
				RootPart.CFrame = PrevPos
			end)
		end,
	})
	TeleportToPlayer:CreateToggle({
		Text = "Pulse Teleport",
        Info = "After teleporting to someone you will get teleported back to your original position after a specified amount of time.",
		Function = function(Bool)
			PulseTeleport = Bool
		end,
	})
	TeleportToPlayer:CreateSlider({
		Text = "Pulse Teleport Time",
		Min = 0,
		Default = 0,
		Max = 10,
		Function = function(Val)
			PulseTeleportTime = Val
		end,
		Function2 = function(Val)
			PulseTeleportTime = Val
		end,
	})
end

do
	ToggleLoopTeleportToPlayer = Movement:CreateTextbox({
		ButtonText = "Loop Teleport",
        Info = "Loop teleports to the specified player.",
		PlaceholderText = "[Player Name]",
		EnabledIndicator = true,
		MouseButton1Click = function(LoopTeleportEnabled)
			if LoopTeleportEnabled then
				Connections.Movement.LoopTeleportToPlayer = RunService.Stepped:Connect(function()
					local Char = GetChar(Plr)
					local Root = GetRoot(Char)
					local Player = FindPlayer(ToggleLoopTeleportToPlayer.Textbox.Text)
					local PlayerChar = GetChar(Player)
					local PlayerRoot = GetRoot(PlayerChar)
					if Char and Root and Player and PlayerChar and PlayerRoot then
						Root.CFrame = PlayerRoot.CFrame
					end
				end)
			else
				if Connections.Movement.LoopTeleportToPlayer then
					Connections.Movement.LoopTeleportToPlayer:Disconnect()
					Connections.Movement.LoopTeleportToPlayer = nil
				end
			end
		end,
	})
end

ToggleClickTeleport = Movement:CreateToggle({
	Text = "Click Teleport",
	Info = "Teleports you to your mouse's location when you hold your keybind and click.",
	Function = function(Bool)
		ClickTeleportEnabled = Bool
	end,
})

ToggleClickTeleportSound = ToggleClickTeleport:CreateToggle({
    Text = "Teleport Sound",
    Info = "Plays a sound when teleporting.",
    Function = function(Bool)
        ClickTeleportSoundEnabled = Bool
    end,
})

ToggleCFrameFly = Movement:CreateToggle({
	Text = "CFrame Fly",
	Info = "Works like normal fly except it doesn't update your position to other players.",
	Function = function(CFrameFly)
		if CFrameFly then
			Connections.Movement.CFrameFlyLoop = RunService.Heartbeat:Connect(function(DeltaTime)
				local Char = GetChar(Plr)
				local Root = GetRoot(Char)
				local Humanoid = GetHumanoid(Char)
				if not (Char and Root) then return end
				Root.Anchored = true
				if not Humanoid then return end
				local CameraOffset = Root.CFrame:ToObjectSpace(Camera.CFrame).Position
				Camera.CFrame = Camera.CFrame * CFrame.new(-CameraOffset.X, -CameraOffset.Y, -CameraOffset.Z + 1)
				local ModdedCameraPos = Vector3.new(Root.CFrame.Position.X,  Camera.CFrame.Position.Y, Root.CFrame.Position.Z)
				local ObjectSpaceVelocity = CFrame.new(Camera.CFrame.Position, ModdedCameraPos)
				ObjectSpaceVelocity = ObjectSpaceVelocity:VectorToObjectSpace(Humanoid.MoveDirection * (CFrameFlySpeed * DeltaTime))
				Root.CFrame = CFrame.new(Root.CFrame.Position) * (Camera.CFrame - Camera.CFrame.Position) * CFrame.new(ObjectSpaceVelocity)
			end)
		else
			if Connections.Movement.CFrameFlyLoop then
				Connections.Movement.CFrameFlyLoop:Disconnect()
				Connections.Movement.CFrameFlyLoop = nil
			end
			local Char = GetChar(Plr)
			local Root = GetRoot(Char)
			if Char and Root then
				Root.Anchored = false
			end
		end
	end,
})
CFrameFlySpeedSlider = ToggleCFrameFly:CreateSlider({
	Text = "CFrame Fly Speed",
	Default = 50,
	Min = 0,
	Max = 500,
	Function = function(Val)
		CFrameFlySpeed = Val
	end,
	Function2 = function(Val)
		CFrameFlySpeed = Val
	end,
})

do
    local OldGravity = workspace.Gravity

    ToggleSwim = Movement:CreateToggle({
        Text = "Swim",
        Info = "It makes you swim.",
        Function = function(Swimming)
            if Swimming then
                OldGravity = workspace.Gravity
                local Char = GetChar(Plr)
                local Humanoid = GetHumanoid(Char)
				local Root = GetRoot(Char)
                workspace.Gravity = 0
                Connections.Movement.SwimHumanoidDied = Humanoid and Humanoid.Died:Once(function()
                    workspace.Gravity = OldGravity
                    Swimming = false
                end)
                local States = Enum.HumanoidStateType:GetEnumItems()
                table.remove(States, table.find(States, Enum.HumanoidStateType.None))
                for i, v in pairs(States) do
                    Humanoid:SetStateEnabled(v, false)
                end
                Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
                Connections.Movement.SwimLoop = RunService.Heartbeat:Connect(function()
                    Char = GetChar(Plr)
                    Root = GetRoot(Char)
					Humanoid = GetHumanoid(Char)
					if not (Char and Root and Humanoid) then return end
                    Root.AssemblyLinearVelocity = ((Humanoid.MoveDirection ~= Vector3.new(0, 0, 0) or UIS:IsKeyDown(Enum.KeyCode.Space)) and Root.AssemblyLinearVelocity or Vector3.new())
                end)
            else
                if Connections.Movement.SwimHumanoidDied then
                    Connections.Movement.SwimHumanoidDied:Disconnect()
                    Connections.Movement.SwimHumanoidDied = nil
                end
                if Connections.Movement.SwimLoop then
                    Connections.Movement.SwimLoop:Disconnect()
                    Connections.Movement.SwimLoop = nil
                end
                Swimming = false
                local States = Enum.HumanoidStateType:GetEnumItems()
                table.remove(States, table.find(States, Enum.HumanoidStateType.None))
                workspace.Gravity = OldGravity or 196.2
                local Times = 0
                local Char = GetChar(Plr)
                local Humanoid = GetHumanoid(Char)
                if not (Char or Humanoid) then return end
                for i, v in pairs(States) do
                    Humanoid:SetStateEnabled(v, true)
                end
            end
        end,
    })
end

do
	ToggleFreecam = Movement:CreateToggle({
		Text = "Freecam",
		Info = "Allows your camera to move around freely.",
		Function = function(FreecamEnabled)
			if FreecamEnabled then
				StartFreecam()
			else
				StopFreecam()
			end
		end,
	})
	ToggleFreecam:CreateSlider({
		Text = "Freecam Speed",
		Default = 10,
		Min = 0,
		Max = 100,
		Function = function(Val)
			FreecamSpeed = Vector3.new(Val, Val, Val)
		end,
		Function2 = function(Val)
			FreecamSpeed = Vector3.new(Val, Val, Val)
		end,
	})
end

do
	local PrevNoclip

	ToggleWalkFling = Movement:CreateToggle({
		Text = "Walk Fling",
		Info = "Flings players without spinning.",
		Function = function(WalkFling)
			if WalkFling then
				PrevNoclip = ToggleNoclip.Boolean
				ToggleNoclip:Enable({NoNotify = true})
				Connections.WalkFlingLoop = RunService.Heartbeat:Connect(function()
					local Char = GetChar(Plr)
					local Root = GetRoot(Char)
					if not (Char and Root) then return end
					local Vel = Root.Velocity
					Root.Velocity = Vel * 10000 + Vector3.new(0, 10000, 0)
					RunService.RenderStepped:Wait()
					Root.Velocity = Vel
				end)
			else
				if Connections.WalkFlingLoop then
					Connections.WalkFlingLoop:Disconnect()
					Connections.WalkFlingLoop = nil
				end
				if PrevNoclip == false then
					ToggleNoclip:Disable({NoNotify = true})
				end
			end
		end,
	})
end

ToggleSpiderHack = Movement:CreateToggle({
	Text = "Spider Hack",
	Info = "Allows you to climb up walls (hold shift to use noclip over spider hack).",
	Function = function(SpiderHack)
		if SpiderHack then
			local Params = RaycastParams.new()
			Params.RespectCanCollide = true
			Params.IgnoreWater = true
			Connections.Movement.SpiderHackLoop = RunService.Heartbeat:Connect(function()
				if TidalWaveKeybinds.UseNoclipOverSpiderHack and UIS:IsKeyDown(TidalWaveKeybinds.UseNoclipOverSpiderHack) and Noclip then return end
				local Char = GetChar(Plr)
				local Root = GetRoot(Char)
				local Humanoid = GetHumanoid(Char)
				if Char and Root and Humanoid then
					Params.FilterDescendantsInstances = GetAllCharacters()
					local Raycast = workspace:Raycast(Root.Position, Humanoid.MoveDirection * SpiderHackRadius, Params)
					if Raycast then
						Root.AssemblyLinearVelocity = Vector3.new(0, SpiderHackSpeed, 0)
					end
				end
			end)
		else
			if Connections.Movement.SpiderHackLoop then
				Connections.Movement.SpiderHackLoop:Disconnect()
				Connections.Movement.SpiderHackLoop = nil
			end
		end
	end,
})
SpiderHackRadiusSlider = ToggleSpiderHack:CreateSlider({
    Text = "Radius",
    Min = 0,
    Default = 3,
    Max = 30,
    Function = function(Val)
        SpiderHackRadius = Val
    end,
    Function2 = function(Val)
        SpiderHackRadius = Val
    end,
})
SpiderHackSpeedSlider = ToggleSpiderHack:CreateSlider({
    Text = "Speed",
    Min = 0,
    Default = 50,
    Max = 500,
    Function = function(Val)
        SpiderHackSpeed = Val
    end,
    Function2 = function(Val)
        SpiderHackSpeed = Val
    end,
})

ToggleFollowPlayer = Movement:CreateTextbox({
	ButtonText = "Follow Player",
	PlaceholderText = "[Player Name]",
	Info = "Follows a specified player.",
	Function = function(FollowPlayer)
		if FollowPlayer then
            Connections.Movement.FollowPlayerThread = task.spawn(function()
                local Path
                while true do
                    local Char = GetChar(Plr)
                    local Root = GetRoot(Char)
                    local Humanoid = GetHumanoid(Char)
                    local Player = FindPlayer(ToggleFollowPlayer.Textbox.Text)
                    local PlayerChar = GetChar(Player)
                    local PlayerRoot = GetRoot(PlayerChar)
                    if not (Char and Root and Humanoid and Player and PlayerChar and PlayerRoot) then continue end
                    if PathfindFollowPlayer then
                        Path = PathfindingService:CreatePath()
                        Path:ComputeAsync(Root.Position, PlayerRoot.Position)
                        local Waypoints = Path:GetWaypoints()
                        for i, Waypoint in pairs(Waypoints) do
                            if Waypoint.Action == Enum.PathWaypointAction.Jump and Humanoid then
                                Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                            end
                            Humanoid:MoveTo(Waypoint.Position)
                        end
                    else
                        Humanoid:MoveTo(PlayerRoot.Position)
                    end
                    task.wait()
                end
            end)
        else
            if Connections.Movement.FollowPlayer then
                task.cancel(Connections.Movement.FollowPlayer)
                Connections.Movement.FollowPlayer = nil
            end
        end
	end,
})

TogglePathfindFollowPlayer = ToggleFollowPlayer:CreateToggle({
    Text = "Pathfind",
    Info = "Makes you pathfind to the player.",
    Function = function(Bool)
        PathfindFollowPlayer = Bool
    end,
})

do
	local OrbitLookAtEnabled = true

	ToggleOrbitPlayer = nil; ToggleOrbitPlayer = Movement:CreateTextbox({
		ButtonText = "Orbit",
		PlaceholderText = "[Player Name]",
		Info = "Orbits around the specified player.",
		EnabledIndicator = true,
		Function = function(OrbitPlayer)
			if OrbitPlayer then
				local Rotation = 0
				Connections.Movement.OrbitLoop = RunService.Heartbeat:Connect(function()
					local Player = FindPlayer(ToggleOrbitPlayer.Textbox.Text)
					local PlayerChar = GetChar(Player)
					local PlayerRoot = GetRoot(PlayerChar)
					local Char = GetChar(Plr)
					local Root = GetRoot(Char)
					if not (Player and PlayerChar and PlayerRoot and Char and Root) then return end
					Rotation += OrbitSpeed
					Root.CFrame = CFrame.new(PlayerRoot.Position) * CFrame.Angles(0, math.rad(Rotation), 0) * CFrame.new(OrbitDistance, 0, 0)
					if not OrbitLookAtEnabled then return end
					Root.CFrame = CFrame.lookAt(Root.Position, PlayerRoot.Position)
				end)
			else
				if Connections.Movement.OrbitLoop then
					Connections.Movement.OrbitLoop:Disconnect()
					Connections.Movement.OrbitLoop = nil
				end
			end
		end,
	})

	OrbitDistanceSlider = ToggleOrbitPlayer:CreateSlider({
		Text = "Orbit Distance",
		Min = 0,
		Default = 6,
		Max = 60,
		Function = function(Val)
			OrbitDistance = Val
		end,
		Function2 = function(Val)
			OrbitDistance = Val
		end,
	})

	OrbitSpeedSlider = ToggleOrbitPlayer:CreateSlider({
		Text = "Orbit Speed",
		Min = 0,
		Default = 0.2,
		Max = 2,
		Function = function(Val)
			OrbitSpeed = Val
		end,
		Function2 = function(Val)
			OrbitSpeed = Val
		end,
	})

	ToggleOrbitPlayer:CreateToggle({
		Text = "Orbit Look At",
		Info = "Makes you look at the player while orbiting them.",
		Function = function(Bool)
			OrbitLookAtEnabled = Bool
		end,
	})
end

ToggleFlyJump = Movement:CreateToggle({
	Text = "Fly Jump",
	Info = "Makes you rapidly jump when holding space.",
	Function = function(FlyJump)
		if FlyJump then
			Connections.Movement.FlyJump = UIS.JumpRequest:Connect(function()
				local Char = GetChar(Plr)
				local Humanoid = GetHumanoid(Char)
				if Char and Humanoid then
					Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				end
			end)
		else
			if Connections.Movement.FlyJump then
				Connections.Movement.FlyJump:Disconnect()
				Connections.Movement.FlyJump = nil
			end
		end
	end,
})

do
	local AngVel = nil

    local function DestroyAngleVel()
        if AngVel then
            AngVel:Destroy()
            AngVel = nil
        end
    end

    local function UpdateAngleVel()
		if AngVel then
            AngVel.AngularVelocity = Vector3.new(0, SpinSpeed, 0)
        end
	end

	ToggleSpin = Movement:CreateToggle({
		Text = "Spin",
		Info = "Makes your character spin.",
		Function = function(Spinning)
			if Spinning then
				local Char = GetChar(Plr)
				local Root = GetRoot(Char)
				if not (Char or Root) then return end
                DestroyAngleVel()
				AngVel = Instance.new("BodyAngularVelocity")
				AngVel.MaxTorque = Vector3.new(0, math.huge, 0)
				AngVel.AngularVelocity = Vector3.new(0, SpinSpeed, 0)
                AngVel.Parent = Root
				AngVel.AncestryChanged:Once(DestroyAngleVel)
			else
				DestroyAngleVel()
			end
		end,
	})

    ToggleSpin:CreateSlider({
        Text = "Speed",
        Min = 0,
        Default = 10,
        Max = 100,
        Function = function(Val)
            SpinSpeed = Val
            UpdateAngleVel()
        end,
        Function2 = function(Val)
            SpinSpeed = Val
            UpdateAngleVel()
        end,
    })
end

ToggleStareAt = nil; ToggleStareAt = Movement:CreateTextbox({
	ButtonText = "Stare At",
	PlaceholderText = "[Player Name]",
	Info = "Stares At The Specified Player",
	Function = function(StareAt)
		if StareAt then
			Connections.Movement.StareAtLoop = RunService.RenderStepped:Connect(function()
				local Player = FindPlayer(ToggleStareAt.Textbox.Text)
				local PlayerChar = GetChar(Player)
				local PlayerRoot = GetRoot(PlayerChar)
				local Char = GetChar(Plr)
				local Root = GetRoot(Char)
				if not (Char and Root and Player and PlayerChar and PlayerRoot) then return end
				Root.CFrame = LookTowards(Root.Position, PlayerRoot.Position)
			end)
		else
			if Connections.Movement.StareAtLoop then
				Connections.Movement.StareAtLoop:Disconnect()
				Connections.Movement.StareAtLoop = nil
			end
		end
	end,
})

ToggleHeadSit = nil; ToggleHeadSit = Movement:CreateTextbox({
	ButtonText = "Head Sit",
	PlaceholderText = "[Player Name]",
	Info = "Sits On The Specified Players Head (Jump To Turn Off)",
	EnabledIndicator = true,
	MouseButton1Click = function(HeadSitEnabled)
		if HeadSitEnabled then
			local Char = GetChar(Plr)
			local Root = GetRoot(Char)
			local Humanoid = GetHumanoid(Char)

			Humanoid.Sit = true
			
			Connections.Movement.HeadSitLoop = RunService.Heartbeat:Connect(function()
				local Player = FindPlayer(ToggleHeadSit.Textbox.Text)
				local PlayerChar = GetChar(Player)
				local PlayerRoot = GetRoot(PlayerChar)
				Char = GetChar(Plr)
				Root = GetRoot(Char)
				Humanoid = GetHumanoid(Char)
				if not (Char and Root and Player and PlayerChar and PlayerRoot) then return end
				if Humanoid and Humanoid.Sit then
					Root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
					RunService.Heartbeat:Wait()
					Root.CFrame = PlayerRoot.CFrame:ToWorldSpace(CFrame.new(0, 1.6, 0.4))
				elseif Humanoid and not Humanoid.Sit then
					ToggleHeadSit:Disable({NoNotify = true})
				end
			end)
		else
			if Connections.Movement.HeadSitLoop then
				Connections.Movement.HeadSitLoop:Disconnect()
				Connections.Movement.HeadSitLoop = nil
			end
			local Char = GetChar(Plr)
			local Humanoid = GetHumanoid(Char)
			if not (Char and Humanoid) then return end
			Humanoid.Sit = false
		end
	end,
})

do
	local Anim = nil
	local LoadedAnim = nil

	ToggleCarpet = nil; ToggleCarpet = Movement:CreateTextbox({
		ButtonText = "Carpet",
		PlaceholderText = "[Player Name]",
		Info = "You Become Someones Carpet",
		EnabledIndicator = true,
		MouseButton1Click = function(CarpetEnabled)
			if CarpetEnabled then
				local Player = FindPlayer(ToggleCarpet.Textbox.Text)
				local PlayerChar = GetChar(Player)
				local PlayerRoot = GetRoot(PlayerChar)
				local Char = GetChar(Plr)
				local Root = GetRoot(Char)
				local Humanoid = GetHumanoid(Char)
				if not (Char and Root and Humanoid and PlayerChar and PlayerRoot) then return end
				Anim = Instance.new("Animation")
				Anim.AnimationId = "rbxassetid://282574440"
				LoadedAnim = Humanoid:LoadAnimation(Anim)
                LoadedAnim.Priority = Enum.AnimationPriority.Action4
				LoadedAnim:Play(0, 1, 1)
				Connections.Movement.CarpetLoop = RunService.Heartbeat:Connect(function()
					Root.CFrame = PlayerRoot.CFrame
				end)
			else
				if Anim then
					Anim = nil
				end
				if LoadedAnim then
					LoadedAnim:Stop()
					LoadedAnim = nil
				end
				if Connections.Movement.CarpetLoop then
					Connections.Movement.CarpetLoop:Disconnect()
				end
			end
		end,
	})
end

ToggleMaxSlopeAngle = Movement:CreateToggle({
	Text = "Max Slope Angle",
	Info = "Sets The Max Slope Angle Of The Specified Player",
	MouseButton1Click = function(LoopMaxSlopeAngle)
		if LoopMaxSlopeAngle then
			local Char = GetChar(Plr)
			local Humanoid = GetHumanoid(Char)
			if Char and Humanoid then
				Connections.Movement.LoopMaxSlopeAngle = Humanoid:GetPropertyChangedSignal("MaxSlopeAngle"):Connect(function()
					Humanoid.MaxSlopeAngle = MaxSlopeAngle
				end)
				Humanoid.MaxSlopeAngle = MaxSlopeAngle
			end
		else
			local Char = GetChar(Plr)
			local Humanoid = GetHumanoid(Char)
			if Char and Humanoid then
				Humanoid.MaxSlopeAngle = 89
			end
			if Connections.Movement.LoopMaxSlopeAngle then
				Connections.Movement.LoopMaxSlopeAngle:Disconnect()
				Connections.Movement.LoopMaxSlopeAngle = nil
			end
		end
	end,
})

MaxSlopeAngleSlider = ToggleMaxSlopeAngle:CreateSlider({
    Text = "Max Slope Angle",
    Min = 0,
    Max = 89.9,
    Default = 89,
    Function = function(Val)
        MaxSlopeAngle = Val
    end,
    Function2 = function(Val)
        MaxSlopeAngle = Val
    end,
})

------------------------------------------------------------------------------------------------------------------------------------- Custom Games

IsSkywars = game.GameId == 3258873704
IsChickNCoop = game.GameId == 6911629372
IsStairClimbingSimulator = game.GameId == 632417465
IsFleeTheFacility = game.GameId == 372226183
IsStrongmanSimulator = game.GameId == 2564505263
IsDeadByRoblox = game.GameId == 5135096867
IsOutNIn = game.GameId == 7012121531
IsViolenceDistrict = false

if IsSkywars then -- Skywars
    SkywarsCategory = CreateCategory({
        Name = "Skywars",
        Size = UDim2.fromScale(1, 0.5),
        Pos = UDim2.fromScale(0.77, 0),
        ClosedPos = UDim2.fromScale(0.45, 1),
    })
	KillESP = false
	LevelESP = false
	WinsESP = false
	WinStreakESP = false
	HelmetESP = false
	ChestplateESP = false
	LeggingESP = false
	RankESP = false
	TitleESP = false
	KillAura = false
	EggNuker = false
	AutoQueue = false
	PlaySwordAnimationDuringKillAura = false
	SilentAimbot = false
	AutoWin = false
	AutoConsume = false
	SpawnKill = false

	AmountOfChestsToLoot = 5
	SwordAnimationPlayRate = 0.5

	local ItemsToBuy = {}
	local WeaponsToBuy = {}

	ModeToAutoQueue = "SkyWarsSolo"

	local IsEggWars = game.PlaceId == 8951451142
	IsSkywars = game.PlaceId == 8542275097 or game.PlaceId == 8592115909
    local IsBridgeDuels = game.PlaceId == 13246639586
    
	TeleportToGoal = SkywarsCategory:CreateButton({
		Text = "Teleport To Goal",
		Info = 'Instantly Teleports You To Your Opponents Goal In Bridge Duels Or Uses "FireTouchInterest" If Your Exploit Supports It',
		Function = function()
            local Success, Portals = pcall(function()
                return workspace.BlockContainer.Map.Portals
            end)
			if Success then
				local Char = GetChar(Plr)
				local Root = GetRoot(Char)
				if not (Char and Root) then return end
				for i, Part in ipairs(Portals:GetChildren()) do
					if not Part:IsA("BasePart") then continue end
					if FireTouchInterest then
						FireTouchInterest(Part, Root, 0)
						FireTouchInterest(Part, Root, 1)
					else
						Root.CFrame = Part.CFrame
					end
                    task.wait()
				end
			else
				Notify({
					Text = "Failed To Find Goals",
					Duartion = 2,
				})
			end
		end,
	})

	PlayerEspTextSizeSlider = nil
	ToggleAutomaticPlayerEspTextColor = nil

	ToggleKillESP = SkywarsCategory:CreateToggle({
		Text = "Kills ESP",
		Info = "Shows Players Kills",
		Function = function(Bool)
			KillESP = Bool
		end,
		Function2 = function()
			PlayerEspTextSizeSlider.Visible = true
			ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
		end,
	})

	ToggleWinESP = SkywarsCategory:CreateToggle({
		Text = "Wins ESP",
		Info = "Shows Players Wins",
		Function = function(Bool)
			WinsESP = Bool
		end,
		Function2 = function()
			PlayerEspTextSizeSlider.Visible = true
			ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
		end,
	})

	ToggleWinStreakESP = SkywarsCategory:CreateToggle({
		Text = "Win Streak ESP",
		Info = "Shows Players Winstreak",
		Function = function(Bool)
			WinStreakESP = Bool
		end,
		Function2 = function()
			PlayerEspTextSizeSlider.Visible = true
			ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
		end,
	})

	ToggleLevelESP = SkywarsCategory:CreateToggle({
		Text = "Level ESP",
		Info = "Shows Players Level",
		Function = function(Bool)
			LevelESP = Bool
		end,
		Function2 = function()
			PlayerEspTextSizeSlider.Visible = true
			ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
		end,
	})

	ToggleRankESP = SkywarsCategory:CreateToggle({
		Text = "Rank ESP",
		Info = "Shows Players Rank",
		Function = function(Bool)
			RankESP = Bool
		end,
		Function2 = function()
			PlayerEspTextSizeSlider.Visible = true
			ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
		end,
	})

	ToggleTitleESP = SkywarsCategory:CreateToggle({
		Text = "Title ESP",
		Info = "Shows Players Title",
		Function = function(Bool)
			TitleESP = Bool
		end,
		Function2 = function()
			PlayerEspTextSizeSlider.Visible = true
			ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
		end,
	})

	ToggleHelmetESP = SkywarsCategory:CreateToggle({
		Text = "Helmet ESP",
		Info = "Shows Players Helmet",
		Function = function(Bool)
			HelmetESP = Bool
		end,
		Function2 = function()
			PlayerEspTextSizeSlider.Visible = true
			ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
		end,
	})

	ToggleChestplateESP = SkywarsCategory:CreateToggle({
		Text = "Chestplate ESP",
		Info = "Shows Players Chestplate",
		Function = function(Bool)
			ChestplateESP = Bool
		end,
		Function2 = function()
			PlayerEspTextSizeSlider.Visible = true
			ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
		end,
	})

	ToggleLeggingsESP = SkywarsCategory:CreateToggle({
		Text = "Helemt ESP",
		Info = "Shows Players Leggings",
		Function = function(Bool)
			LeggingESP = Bool
		end,
		Function2 = function()
			PlayerEspTextSizeSlider.Visible = true
			ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
		end,
	})

	local function GetRemoteFolder()
		for i, v in pairs(ReplicatedStorage:GetChildren()) do
			if #GetChildrenOfClass(v, "RemoteEvent") > 5 then
				return v
			end
		end
		return nil
	end

	local RemoteFolder = ReplicatedStorage:FindFirstChild("rM9") or ReplicatedStorage:FindFirstChild("Kw8")

	local EquipRemote = RemoteFolder and (RemoteFolder:FindFirstChild("8dd94a0e-0dd9-409c-8847-de1054173265") or RemoteFolder:FindFirstChild("5002e4bf-6aeb-4897-8103-b9be6d3a3e54"))
	local AttackRemote = RemoteFolder and (RemoteFolder:FindFirstChild("0f825f49-002e-4b7b-8d8c-24dbb3494845") or RemoteFolder:FindFirstChild("93b2718b-2b2a-4859-b36e-fd4614c7f0c9"))
	local OpenChestRemote = RemoteFolder and RemoteFolder:FindFirstChild("1b702374-6e55-4aa2-a7fa-4531cb9af1df")
	local CloseChestRemote = RemoteFolder and RemoteFolder:FindFirstChild("9d37e94c-2ed5-4889-8451-678bc8ad00ea")
	local LootChestRemote = RemoteFolder and RemoteFolder:FindFirstChild("41b07193-ec28-449b-8542-fff50405a58e")
	local MineEggRemote = RemoteFolder and RemoteFolder:FindFirstChild("39860ba3-e6f8-42ab-bfc2-49a7fcc8aa23")
	local SwordMineEggRemote = RemoteFolder and RemoteFolder:FindFirstChild("f32c9bc1-cb4b-4616-96ac-bddaefd35e92")
	local BlackSmithWeaponRemote = RemoteFolder and RemoteFolder:FindFirstChild("97c8fa11-dd8b-479e-ac76-ee2d8b654971")
	local BlackSmithItemRemote = RemoteFolder and RemoteFolder:FindFirstChild("11788c3d-970c-4db8-a442-8a6f6e823b72")
	local MerchantRemote = RemoteFolder and RemoteFolder:FindFirstChild("2fc3b306-ea1f-4b39-95ce-a7b0298a2d7f")
	local QueueRemote = RemoteFolder and (RemoteFolder:FindFirstChild("75e73d87-08a4-4086-bf6a-4be26d0af348") or RemoteFolder:FindFirstChild("f77d9402-9920-4322-8846-d72e6dd27c51"))
	local ProjectileRemote = RemoteFolder and (RemoteFolder:FindFirstChild("443626f4-a246-470c-b6da-b3c7feaa187f") or RemoteFolder:FindFirstChild("6775cddb-fefc-4342-976d-7cbf66bd0196"))
	
	local Swords = {
		[1] = "BronzeSword",
		[2] = "IronSword",
		[3] = "GoldSword",
		[4] = "DiamondSword",
		[5] = "OnyxSword",
	}
	
	local SwingAnimation = Instance.new("Animation")
	SwingAnimation.AnimationId = "rbxassetid://8542350607"
	local LoadedAnimation = nil
	
	ToggleKillAura = SkywarsCategory:CreateToggle({
		Text = "Kill Aura",
		Info = "Automatically attacks the closest player.",
		Function = function(KillAura)
			if not AttackRemote then return end
			if KillAura then
				local AnimLastRan = tick()
				Connections.Skywars.KillAuraLoop = RunService.Heartbeat:Connect(function()
					local Player = GetClosestPlayer()
					local PlayerChar = GetChar(Player)
					local PlayerRoot = GetRoot(PlayerChar)
					local Char = GetChar(Plr)
					local Root = GetRoot(Char)
					if Player and Player:GetAttribute("TeamId") ~= Plr:GetAttribute("TeamId") and PlayerChar and PlayerRoot and Char and Root and (Root.Position - PlayerRoot.Position).Magnitude < 20 then
						for i, Sword in ipairs(Swords) do
							EquipRemote:FireServer(Sword) -- Equipping Sword
						end
						AttackRemote:FireServer(Player) -- Attacking The Player
						if LoadedAnimation and tick() - AnimLastRan > SwordAnimationPlayRate then
							LoadedAnimation:Play()
							AnimLastRan = tick()
						end
					end
				end)
			else
				if Connections.Skywars.KillAuraLoop then
					Connections.Skywars.KillAuraLoop:Disconnect()
					Connections.Skywars.KillAuraLoop = nil
				end
			end
		end,
	})

    ToggleSwordAnimationDuringKillAura = ToggleKillAura:CreateToggle({
        Text = "Sword Animation",
        Info = "Plays the sword animation when using kill aura.",
        Function = function(Bool)
            PlaySwordAnimationDuringKillAura = Bool
            if PlaySwordAnimationDuringKillAura then
                local Char = GetChar(Plr)
                local Humanoid = GetHumanoid(Char)
                local Animator = nil
                if not (Char and Humanoid) then return end
                Animator = Humanoid:FindFirstChildWhichIsA("Animator", true) or Humanoid
                if Animator then
                    LoadedAnimation = Animator:LoadAnimation(SwingAnimation)
                    LoadedAnimation.Priority = Enum.AnimationPriority.Action4
                else
                    Notify({
                        Text = "Failed To Load Animation",
                    })
                end
            else
                LoadedAnimation = nil
            end
        end,
    })
    
    ToggleKillAura:CreateSlider({
        Text = "Animation Play Rate",
        Min = 0,
        Default = 0.1,
        Max = 1,
        Function = function(Val)
            SwordAnimationPlayRate = Val
        end,
        Function2 = function(Val)
            SwordAnimationPlayRate = Val
        end,
    })
	
	local Items = {
		-- Onyx Loot
		[1] = "OnyxSword",
		[2] = "OnyxChestplate",
		[3] = "OnyxLeggings",
		[4] = "OnyxHelmet",
		-- Diamond Loot
		[5] = "DiamondSword",
		[6] = "DiamondChestplate",
		[7] = "DiamondLeggings",
		[8] = "DiamondHelmet",
		-- Gold Loot
		[9] = "GoldSword",
		[10] = "GoldChestplate",
		[11] = "GoldLeggings",
		[12] = "GoldHelmet",
		-- Iron Loot
		[13] = "IronSword",
		[14] = "IronChestplate",
		[15] = "IronLeggings",
		[16] = "IronHelmet",
		-- Bronze Loot
		[17] = "BronzeSword",
		[18] = "BronzeChestplate",
		[19] = "BronzeLeggings",
		[20] = "BronzeHelmet",
		-- Other Loot
		[21] = "Bow",
		[22] = "Arrow",
		[23] = "Capybara",
		[24] = "Teleporter",
		[25] = "TeamConcrete",
		[26] = "Shield",
		[27] = "SpeedBoost",
		[28] = "JumpBoost",
		-- Pickaxes
		[29] = "OnyxPickaxe",
		[30] = "DiamondPickaxe",
		[31] = "GoldPickaxe",
		[32] = "IronPickaxe",
		[33] = "BronzePickaxe",
	}
	
	function GetClosestChest()
		local Success, ChestFolder = pcall(function()
            return workspace.BlockContainer.Map.Chests
        end)
		if not Success then return end
		local Char = GetChar(Plr)
		local Root = GetRoot(Char)
		if not (Char and Root) then return end
		local ClosestChest = nil
		local ClosestChestDistance = 100000
		for i, Chest in pairs(ChestFolder:GetChildren()) do
			if not Chest:IsA("Model") then continue end
			if not Chest.PrimaryPart then continue end
			
			local Mag = (Root.Position - Chest.PrimaryPart.Position).Magnitude
			
			if Mag < ClosestChestDistance then
				ClosestChest = Chest
				ClosestChestDistance = Mag
			end
		end
		return ClosestChest, ClosestChestDistance
	end
	
	ToggleAutoLoot = SkywarsCategory:CreateToggle({
		Text = "Auto Loot",
		Info = "Automatically loots chests for you.",
		Function = function(AutoLoot)
            if not (OpenChestRemote and LootChestRemote and CloseChestRemote and IsSkywars) then return end
			if AutoLoot then
                Connections.Skywars.AutoLootThread = task.spawn(function()
                    while true do
                        RunService.Heartbeat:Wait()
                        local Chest, Mag = GetClosestChest()
                        
                        local Char = GetChar(Plr)
                        local Root = GetRoot(Char)
                        
                        if not (Char and Root and Chest) or Mag > 12 then continue end
                        
                        OpenChestRemote:FireServer(Chest) -- Opening The Chest
                        
                        for i, Item in ipairs(Items) do
                            LootChestRemote:FireServer(Chest, Item, -1) -- Looting The Chest
                            RunService.Heartbeat:Wait()
                        end
                        
                        RunService.Heartbeat:Wait()
                        CloseChestRemote:FireServer(Chest) -- Closing The Chest
                    end
                end)
            else
                if Connections.Skywars.AutoLootThread then
                    task.cancel(Connections.Skywars.AutoLootThread)
                    Connections.Skywars.AutoLootThread = nil
                end
            end
		end,
	})
	
	local Pickaxes = {
		[1] = "BronzePickaxe",
		[2] = "IronPickaxe",
		[3] = "GoldPickaxe",
		[4] = "DiamondPickaxe",
		[5] = "OnyxPickaxe",
	}
	
	ToggleEggNuker = SkywarsCategory:CreateToggle({
		Text = "Egg Nuker",
		Info = "Automatically mines eggs for you.",
		Function = function(EggNuker)
			if not (EquipRemote and MineEggRemote) or IsSkywars then return end
			if EggNuker then
				Connections.Skywars.EggNukerLoop = RunService.Heartbeat:Connect(function()
					local Eggs = workspace:FindFirstChild("Eggs")
					if not Eggs then return end
					
					local Char = GetChar(Plr)
					local Root = GetRoot(Char)
					
					if not (Char and Root) then return end
					
					for i, Egg in pairs(Eggs:GetChildren()) do
						if Egg.PrimaryPart and (Egg.PrimaryPart.Position - Root.Position).Magnitude < 20 and Egg:GetAttribute("TeamId") ~= Plr:GetAttribute("TeamId") and Egg:GetAttribute("Health") > 0 then
							for i2, Pickaxe in ipairs(Pickaxes) do
								EquipRemote:FireServer(Pickaxe) -- Equipping The Pickaxe
							end
							MineEggRemote:FireServer(Egg.PrimaryPart.Position + Vector3.new(0, 1.5, 0)) -- Attacking The Egg
						end
					end
				end)
			else
				if Connections.Skywars.EggNukerLoop then
					Connections.Skywars.EggNukerLoop:Disconnect()
					Connections.Skywars.EggNukerLoop = nil
				end
			end
		end,
	})
	
	ToggleAutoQueue = SkywarsCategory:CreateToggle({
		Text = "Auto Queue",
		Info = "Automatically queues you for the specified gamemode.",
		Function = function(Bool)
			AutoQueue = Bool
		end,
	})

    local GameModeDropdown = ToggleAutoQueue:CreateDropdown({
        Text = "Gamemode",
        Default = "SkyWarsSolo",
    })
    
    GameModeDropdown:CreateButton({
        Text = "Skywars Solo",
        Function = function()
            ModeToAutoQueue = "SkyWarsSolo"
        end,
    })
    
    GameModeDropdown:CreateButton({
        Text = "Skywars Duos",
        Function = function()
            ModeToAutoQueue = "SkyWarsDuos"
        end,
    })
    
    GameModeDropdown:CreateButton({
        Text = "Eggwars Squads",
        Function = function()
            ModeToAutoQueue = "EggWarsQuads"
        end,
    })
    
    GameModeDropdown:CreateButton({
        Text = "Bridge Solo",
        Function = function()
            ModeToAutoQueue = "DuelsSolo"
        end,
    })
	
	local QueueCheck = false
	
	Plr:FindFirstChildWhichIsA("PlayerGui").ChildAdded:Connect(function(Child)
		if QueueCheck then return end
		if Child.Name == "Lobby" and Child:IsA("ScreenGui") and AutoQueue and QueueRemote then
			QueueCheck = true
			QueueRemote:FireServer(true, ModeToAutoQueue)
		end
	end)
	
	ToggleAutoBuyWeapons = SkywarsCategory:CreateToggle({
		Text = "Auto Buy Weapons",
		Info = "Automatically upgrades your armor, sword, and pickaxe.",
		Function = function(AutoBuyWeapons)
            if not (BlackSmithWeaponRemote and IsSkywars) then return end
			if AutoBuyWeapons then
                Connections.Skywars.AutoBuyWeaponsThread = task.spawn(function()
                    while true do
                        task.wait()
                        for i, Weapon in pairs(WeaponsToBuy) do
                            BlackSmithWeaponRemote:FireServer("Blacksmith", Weapon)
                            task.wait()
                        end
                    end
                end)
            else
                if Connections.Skywars.AutoBuyWeaponsThread then
                    task.cancel(Connections.Skywars.AutoBuyWeaponsThread)
                    Connections.Skywars.AutoBuyWeaponsThread = nil
                end
            end
		end,
	})

    local WeaponsDropdown = ToggleAutoBuyWeapons:CreateDropdown({
        Text = "Add Weapon",
        Default = "None",
    })
    
	for i = 0, 2 do
		WeaponsDropdown:CreateButton({
			Text = i == 0 and "Sword" or i == 1 and "Armor" or i == 2 and "Pickaxe",
			On = function()
				if not table.find(WeaponsToBuy, i) then
					table.insert(WeaponsToBuy, i)
				end
			end,
			Off = function()
				if table.find(WeaponsToBuy, i) then
					table.remove(WeaponsToBuy, table.find(WeaponsToBuy, i))
				end
			end,
		})
	end
	
	ToggleAutoBuyItems = SkywarsCategory:CreateToggle({
		Text = "Auto Buy Items",
		Info = "Automatically buys the specified items.",
		Function = function(AutoBuyItems)
            if not (BlackSmithItemRemote and IsSkywars) then return end
            if AutoBuyItems then
                Connections.Skywars.AutoBuyItemsThread = task.spawn(function()
                    while true do
                        task.wait()
                        for i, Item in pairs(ItemsToBuy) do
                            BlackSmithItemRemote:FireServer()
                            task.wait()
                        end
                    end
                end)
            else
                if Connections.Skywars.AutoBuyItemsThread then
                    task.cancel(Connections.Skywars.AutoBuyItemsThread)
                    Connections.Skywars.AutoBuyItemsThread = nil
                end
            end
		end,
	})

    ItemsDropdown = ToggleAutoBuyItems:CreateDropdown({
        Text = "Items To Buy",
    })

	for i = 0, 13 do
		local Text = i == 0 and "Concrete" or i == 1 and "Wood" or i == 2 and "Stone Bricks" or i == 3 and "Green Brick idk" or i == 4 and "Silver Brick" or i == 5 and "Snow Ball" or i == 6 and "Bow" or i == 7 and "Arrow" or i == 8 and "Ender Pearl" or i == 9 and "Dynamite" or i == 10 and "Syringe" or i == 11 and "Land Mine" or i == 12 and "Booster Thing idk" or i == 13 and "Fishing Rod"
		ItemsDropdown:CreateButton({
			Text = Text,
			On = function()
				if not table.find(ItemsToBuy, i) then
					table.insert(ItemsToBuy, i)
				end
			end,
			Off = function()
				local Index = table.find(ItemsToBuy, i)
				if Index then
					table.remove(ItemsToBuy, Index)
				end
			end,
		})
	end
    
	ToggleSilentAimbot = SkywarsCategory:CreateToggle({
		Text = "Silent Aimbot",
		Info = "Shoots your bow for you.",
		Function = function(Bool)
			SilentAimbot = Bool
			if not (EquipRemote and ProjectileRemote and SilentAimbot) then return end
			task.spawn(function()
				local Params = RaycastParams.new()
				Params.FilterType = Enum.RaycastFilterType.Exclude
				Params.RespectCanCollide = true
				Params.IgnoreWater = true
				while SilentAimbot do
					RunService.Heartbeat:Wait()
					local Player = GetClosestPlayer()
					local PlayerChar = GetChar(Player)
					local PlayerRoot = GetRoot(PlayerChar)
					local Char = GetChar(Plr)
					local Root = GetRoot(Char)
					
					if not (Player and PlayerChar and PlayerRoot and Char and Root) or ((Root.Position - PlayerRoot.Position).Magnitude > 500 or IsTeammate(Player)) then continue end
					
					Params.FilterDescendantsInstances = {Char}
					local Raycast = workspace:Raycast(Root.Position, (PlayerRoot.Position - Root.Position).Unit * 1000, Params)
					if Raycast and Raycast.Instance.Parent ~= PlayerChar then continue end
					
					EquipRemote:FireServer("Bow")
					
					local Trajectory = SolveTrajectory(Root.Position, 340, PlayerRoot.Position, PlayerRoot.AssemblyLinearVelocity)
					if Trajectory then
						ProjectileRemote:FireServer(Trajectory - Root.Position, 1)
						task.wait(0.5)
					else
						RunService.Heartbeat:Wait()
					end
				end
			end)
		end,
	})

	local function GameInProgress()
		local Success, SpawnLocations = pcall(function()
			return workspace.BlockContainer.Map.SpawnLocations
		end)
		if Success then
			local Started = true
			for i, v in ipairs(SpawnLocations:GetChildren()) do
				if #v:GetChildren() >= 1 then
					Started = false
					break
				end
			end
			if Started then
				return true
			end
		end
		return false
	end
	
	ToggleAutoWin = SkywarsCategory:CreateToggle({
		Text = "Auto Win",
		Info = "It Win For You (:",
		MouseButton1Click = function(Bool)
			AutoWin = Bool
			if AutoWin then
				ToggleSpawnKill:Disable({NoNotify = true})
				task.spawn(function()
                    while not GameInProgress() do
						RunService.Heartbeat:Wait()
                    end
					if not AutoWin then return end
					local Char = GetChar(Plr)
					local Root = GetRoot(Char)
					local Found = 0
                    local Success, Chests = pcall(function()
                        return workspace.BlockContainer.Map.Chests
                    end)
                    local Success2, Eggs = pcall(function()
                        return workspace.Eggs
                    end)
					if IsSkywars and Success then
						ToggleAutoLoot:Enable({NoNotify = true})
                        ToggleKillAura:Enable({NoNotify = true})
                        ToggleSilentAimbot:Enable({NoNotify = true})
						for i, Chest in ipairs(Chests:GetChildren()) do
							if Chest:IsA("Model") and Chest.PrimaryPart and Chest.Name == "ChestTierFour" and Root then
								Root.CFrame = Chest.PrimaryPart.CFrame
								Found += 1
								task.wait(0.5)
								if Found >= AmountOfChestsToLoot then break end
							end
						end
					elseif IsEggWars and Success2 then
						ToggleSilentAimbot:Enable({NoNotify = true})
						ToggleEggNuker:Enable({NoNotify = true})
						ToggleKillAura:Enable({NoNotify = true})
						for i, Egg in pairs(Eggs:GetChildren()) do
							if not Egg:IsA("Model") then continue end
							if not Egg.PrimaryPart then continue end
							if Egg:GetAttribute("TeamId") == Plr:GetAttribute("TeamId") or Egg:GetAttribute("Health") <= 0 then continue end
							local On = true
							task.delay(3, function()
								On = false
							end)
							while On and AutoWin do
								RunService.Stepped:Wait()
                                if not (Char and Root) then Char = GetChar(Plr); Root = GetRoot(Char); continue end
								
								Root.CFrame = Egg.PrimaryPart.CFrame:ToWorldSpace(CFrame.new(0, -10, 0))
								Root.Velocity = Vector3.new(0, 0, 0)
                                RunService.Heartbeat:Wait()
                                Root.CFrame = Egg.PrimaryPart.CFrame:ToWorldSpace(CFrame.new(0, -10, 0))
								Root.Velocity = Vector3.new(0, 0, 0)
							end
						end
                    elseif IsBridgeDuels and AutoWin then
                        while GameInProgress() do
							task.wait()
                            local Success3, SpawnLocations = pcall(function()
                                return workspace.BlockContainer.Map.SpawnLocations
                            end)
                            if not Success3 then continue end
                            for i, SpawnLocation in ipairs(SpawnLocations:GetChildren()) do
                                if #SpawnLocation:GetChildren() <= 0 then
                                    TeleportToGoal:Toggle({NoNotify = true})
                                    RunService.Heartbeat:Wait()
                                    break
                                end
                            end
                        end
                        return
					end
					if not AutoWin then return end
                    local AllPlayers = Players:GetPlayers()
                    if table.find(AllPlayers, Plr) then
                        table.remove(AllPlayers, table.find(AllPlayers, Plr))
                    end
                    local Target = 1
                    local Offset = Vector3.new(0, 0, 0)
                    local Params = RaycastParams.new()
                    Params.FilterType = Enum.RaycastFilterType.Exclude
                    Connections.Skywars.AutoWinLoop = RunService.Stepped:Connect(function()
                        AllPlayers = Players:GetPlayers()
                        if table.find(AllPlayers, Plr) then
                            table.remove(AllPlayers, table.find(AllPlayers, Plr))
                        end
                        if #AllPlayers == 0 then return end
                        if AllPlayers[Target] and not AllPlayers[Target]:GetAttribute("Alive") or AllPlayers[Target] and AllPlayers[Target]:GetAttribute("TeamId") == Plr:GetAttribute("TeamId") then Target += 1 end
                        if Target > #AllPlayers then Target = 1 end
                        local PlayerChar = GetChar(AllPlayers[Target])
                        local PlayerRoot = GetRoot(PlayerChar)
                        Char = GetChar(Plr)
                        Root = GetRoot(Char)
                        if not (Char and Root and PlayerChar and PlayerRoot) then return end
                        Root.Velocity = Vector3.new(0, 0, 0)
                        Params.FilterDescendantsInstances = GetAllCharacters()
                        local Raycast = workspace:Raycast(PlayerRoot.Position, PlayerRoot.Position + Vector3.new(0, -1000, 0), Params)
                        if not Raycast then Target += 1; return end
                        if Plr:GetAttribute("Health") < 25 then
                            Offset = Vector3.new(0, 250, 0)
                        else
                            Offset = Vector3.new(0, 0, 0)
                        end
                        Root.CFrame = PlayerRoot.CFrame:ToWorldSpace(CFrame.new(0, 3, 6)) + Offset
                        RunService.Heartbeat:Wait()

                        --- Heartbeat ---

                        Raycast = workspace:Raycast(PlayerRoot.Position, PlayerRoot.Position + Vector3.new(0, -1000, 0), Params)
                        if not Raycast then Target += 1; return end
                        if Plr:GetAttribute("Health") < 25 then
                            Offset = Vector3.new(0, 250, 0)
                        else
                            Offset = Vector3.new(0, 0, 0)
                        end
                        Root.CFrame = PlayerRoot.CFrame:ToWorldSpace(CFrame.new(0, 3, 6)) + Offset
                    end)
				end)
			else
				if Connections.Skywars.AutoWinLoop then
					Connections.Skywars.AutoWinLoop:Disconnect()
					Connections.Skywars.AutoWinLoop = nil
				end
			end
		end,
	})

	ToggleAutoWin:CreateSlider({
        Text = "Amount Of Chests To Loot",
        Min = 1,
        Default = 5,
        Max = 25,
        Function = function(Val)
            AmountOfChestsToLoot = Val
        end,
        Function2 = function(Val)
            AmountOfChestsToLoot = Val
        end,
    })

	ToggleSpawnKill = SkywarsCategory:CreateToggle({
		Text = "Spawn Kill",
		MouseButton1Click = function(SpawnKill)
			if SpawnKill then
				if Toggles.AutoWin.Boolean then
					ToggleAutoWin:Toggle({NoNotify = true})
				end
				if not ToggleKillAura.Boolean then
					ToggleKillAura:Toggle({NoNotify = true})
				end
				if not ToggleSilentAimbot.Boolean then
					ToggleSilentAimbot:Toggle({NoNotify = true})
				end
				task.spawn(function()
					if not SpawnKill then return end
					local Target = 1
					local Offset = Vector3.new(0, 0, 0)
					local Params = RaycastParams.new()
					Params.FilterType = Enum.RaycastFilterType.Exclude
					Connections.Skywars.SpawnKillLoop = RunService.Stepped:Connect(function()
						local AllPlayers = Players:GetPlayers()
						if table.find(AllPlayers, Plr) then
							table.remove(AllPlayers, table.find(AllPlayers, Plr))
						end
						if AllPlayers[Target] and not AllPlayers[Target]:GetAttribute("Alive") or AllPlayers[Target] and AllPlayers[Target]:GetAttribute("TeamId") == Plr:GetAttribute("TeamId") then Target += 1 end
						if Target > #AllPlayers then Target = 1 end
						local PlayerChar = GetChar(AllPlayers[Target])
						local PlayerRoot = GetRoot(PlayerChar)
						local Char = GetChar(Plr)
						local Root = GetRoot(Char)
						if not (Char and Root and PlayerChar and PlayerRoot) then return end
						Root.Velocity = Vector3.new(0, 0, 0)
						Params.FilterDescendantsInstances = GetAllCharacters()
						local Raycast = workspace:Raycast(PlayerRoot.Position, (PlayerRoot.Position + Vector3.new(0, -1000, 0)), Params)
						if not Raycast then Target += 1; return end
                        if Plr:GetAttribute("Health") < 25 then
							Offset = Vector3.new(0, 250, 0)
						else
							Offset = Vector3.new(0, 0, 0)
						end
						Root.CFrame = PlayerRoot.CFrame:ToWorldSpace(CFrame.new(0, 3, 6)) + Offset
                        RunService.Heartbeat:Wait()

                        --- Heartbeat ---
                        
                        Raycast = workspace:Raycast(PlayerRoot.Position, (PlayerRoot.Position + Vector3.new(0, -1000, 0)), Params)
						if not Raycast then Target += 1; return end
                        if Plr:GetAttribute("Health") < 25 then
							Offset = Vector3.new(0, 250, 0)
						else
							Offset = Vector3.new(0, 0, 0)
						end
						Root.CFrame = PlayerRoot.CFrame:ToWorldSpace(CFrame.new(0, 3, 6)) + Offset
					end)
				end)
			else
				if Connections.Skywars.SpawnKillLoop then
					Connections.Skywars.SpawnKillLoop:Disconnect()
					Connections.Skywars.SpawnKillLoop = nil
				end
			end
		end,
	})
	
	CollectAllGenerators = SkywarsCategory:CreateButton({
		Text = "Collect All Gens",
		MouseButton1Click = function()
			local Char = GetChar(Plr)
			local Root = GetRoot(Char)
            local Success, Generators = pcall(function()
                return workspace.BlockContainer.Generators
            end)
			
			if not (Char and Root and Success) then return end
			
			local PrevPos = Root.CFrame
			
			for i, Gen in pairs(Generators:GetChildren()) do
				if not Gen:IsA("Model") then continue end
				if not Gen.PrimaryPart then continue end
				Root.CFrame = Gen.PrimaryPart.CFrame:ToWorldSpace(CFrame.new(0, -5, 0))
				task.wait(0.1)
			end
			RunService.Heartbeat:Wait()
			Root.CFrame = PrevPos
		end,
	})

	if RemoteFolder then
        Notify({
			Text = "<font color = 'rgb(0, 255, 0)'>Successfully</font> Loaded Skywars Modules Have Fun (:"
		})
	else
		Notify({
			Text = "<font color = 'rgb(255, 0, 0)'>Error</font> Loading Skywars Modules: Remotes Have Been Changed ):",
			Duration = 5,
		})
	end
elseif IsChickNCoop or IsOutNIn then -- Chick-n-Coop And Out-n-In
    local GameName = "nil"
    if IsChickNCoop then
        GameName = "Chick-n-Coop"
    elseif IsOutNIn then
        GameName = "Out-n-In"
    end
    ChickNCoopCategory = CreateCategory({
        Name = GameName,
        Size = UDim2.fromScale(1, 0.5),
        Pos = UDim2.fromScale(0.77, 0),
        ClosedPos = UDim2.fromScale(0.45, 1),
    })
	local ExcludeSelf = false

	local function RemotesChanged()
        local Success = pcall(function()
            return ReplicatedStorage.VehicleSpawnerSystemReplicatedStorage.Events.SpawnVehicle.Vehicles.Category1["Honda Civic (Mobile Car)"].Vehicle["Honda Civic (Mobile Car)"]
        end)
		return not Success
	end

	local KillPlayerTextbox; KillPlayerTextbox = ChickNCoopCategory:CreateTextbox({
		ButtonText = "Kill",
		PlaceholderText = "[Player Name]",
		Function = function()
			if RemotesChanged() then return end
            local Player = FindPlayer(KillPlayerTextbox.Textbox.Text)
			if Player then
				if ExcludeSelf and Player == Plr then return end
				ReplicatedStorage.VehicleSpawnerSystemReplicatedStorage.Events.SpawnVehicle:FireServer(Player.Character, ReplicatedStorage.VehicleSpawnerSystemReplicatedStorage.Vehicles.Category1["Honda Civic (Mobile Car)"].Vehicle["Honda Civic (Mobile Car)"])
			end
		end,
	})

	KillServer = ChickNCoopCategory:CreateButton({
		Text = "Kill Server",
		Info = "It Kill All Players In Server",
		Function = function()
			if RemotesChanged() then return end
			for i, Player in pairs(Players:GetPlayers()) do
				if ExcludeSelf and Player == Plr then continue end
				ReplicatedStorage.VehicleSpawnerSystemReplicatedStorage.Events.SpawnVehicle:FireServer(Player.Character, ReplicatedStorage.VehicleSpawnerSystemReplicatedStorage.Vehicles.Category1["Honda Civic (Mobile Car)"].Vehicle["Honda Civic (Mobile Car)"])
			end
		end,
	})

	ToggleExcludeSelf = KillServer:CreateToggle({
		Text = "Exclude Self",
		Info = "Excludes You From Getting Killed",
		Function = function(Bool)
			ExcludeSelf = Bool
		end,
	})

	ChickNCoopLagServer = ChickNCoopCategory:CreateButton({
		Text = "Lag Server",
		Info = "Kinda Make Server Laggy",
		Function = function()
			if RemotesChanged() then return end
			for i, v in pairs(workspace:GetDescendants()) do
				if v:IsA("BasePart") or v:IsA("Model") then
				    ReplicatedStorage.VehicleSpawnerSystemReplicatedStorage.Events.SpawnVehicle:FireServer(v, ReplicatedStorage.VehicleSpawnerSystemReplicatedStorage.Vehicles.Category1["Honda Civic (Mobile Car)"].Vehicle["Honda Civic (Mobile Car)"])
				end
			end
		end,
	})

	if RemotesChanged() then
		Notify({
			Text = "<font color = 'rgb(255, 0, 0)'>Error</font> Loading " .. GameName .. " Modules: Remotes Have Been Changed ):",
			Duration = 5,
        })
	else
		Notify({
			Text = "<font color = 'rgb(0, 255, 0)'>Successfully</font> Loaded " .. GameName .. " Modules Have Fun (:"
		})
	end
elseif IsStairClimbingSimulator then -- Stair Climbing Simulator
    StairClimbingSimulatorCategory = CreateCategory({
        Name = "Stair Climbing Simulator",
        Size = UDim2.fromScale(1, 0.5),
        Pos = UDim2.fromScale(0.77, 0),
        ClosedPos = UDim2.fromScale(0.45, 1),
    })
	AutoRebirth = false

	Connections.StairClimbingSimulator = {}

    local function TpToEnd()
        local Char = GetChar(Plr)
        local Root = GetRoot(Char)

        if not (Char and Root) then return end

        local Goal = {CFrame = CFrame.new(0, 15100, 40026)}
        local Info = TweenInfo.new(0.9, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
        local Tween = TweenService:Create(Root, Info, Goal)
        Tween:Play()
        Tween.Completed:Wait()
        RunService.Stepped:Wait()
        if Root then
            Root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
        end
        RunService.Heartbeat:Wait()
        if Root then
            Root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
        end
    end

	TeleportToEnd = StairClimbingSimulatorCategory:CreateButton({
		Text = "Teleport To End",
		MouseButton1Click = function()
			TpToEnd()
		end,
	})
	
	Rebirth = StairClimbingSimulatorCategory:CreateButton({
		Text = "Rebirth",
		MouseButton1Click = function()
			TpToEnd()
            task.wait(0.2)

			local RebirthRemote = ReplicatedStorage:FindFirstChild("TurtleEvent")

			if RebirthRemote then
				RebirthRemote:FireServer()
			end
		end,
	})
    
	ToggleAutoRebirth = StairClimbingSimulatorCategory:CreateToggle({
		Text = "Auto Rebirth",
		MouseButton1Click = function(Bool)
			AutoRebirth = Bool
			task.spawn(function()
				if not AutoRebirth then return end
				while AutoRebirth and not StopScript do
					TpToEnd()
                    task.wait(0.2)

					local RebirthRemote = ReplicatedStorage:FindFirstChild("TurtleEvent")

					if RebirthRemote then
						RebirthRemote:FireServer()
					end

					task.wait(0.2)
				end
			end)
		end,
	})

	Notify({
		Text = "<font color = 'rgb(0, 255, 0)'>Successfully</font> Loaded Stair Climbing Simulator Modules Have Fun (:"
	})
elseif IsFleeTheFacility then -- Flee The Facility
    FleeTheFacilityCategory = CreateCategory({
        Name = "Flee The Facility",
        Size = UDim2.fromScale(1, 0.5),
        Pos = UDim2.fromScale(0.77, 0),
        ClosedPos = UDim2.fromScale(0.45, 1),
    })
	Connections.FleeTheFacility = {}
	ComputerEspOutlineTransparency = 0
	ComputerEspFillTransparency = 0.5
	VentEspOutlineTransparency = 0
	VentEspFillTransparency = 0.5
	FreezePodEspOutlineTransparency = 0
	FreezePodEspFillTransparency = 0.5
	ExitEspOutlineTransparency = 0
	ExitEspFillTransparency = 0.5
	WindowEspOutlineTransparency = 0
	WindowEspFillTransparency = 0.5
	DoorEspOutlineTransparency = 0
	DoorEspFillTransparency = 0.5
	LockerEspOutlineTransparency = 0
	LockerEspFillTransparency = 0.5
	SpawnEspOutlineTransparency = 0
	SpawnEspFillTransparency = 0.5
	DoorTriggerEspTransparency = 0.5
	ExitTriggerEspTransparency = 0.5
	FreezePodTriggerEspTransparency = 0.5
	ComputerTriggerEspTransparency = 0.5
    BeastMusicVolume = 0.4
    CustomBeastMusicID = nil
    
	VentEspOutlineColor = Color3.fromRGB(52, 54, 66)
	VentEspFillColor = Color3.fromRGB(52, 54, 66)
	FreezePodEspOutlineColor = Color3.fromRGB(0, 255, 255)
	FreezePodEspFillColor = Color3.fromRGB(0, 255, 255)
	ExitEspOutlineColor = Color3.fromRGB(255, 255, 0)
	ExitEspFillColor = Color3.fromRGB(255, 255, 0)
	WindowEspOutlineColor = Color3.fromRGB(85, 255, 255)
	WindowEspFillColor = Color3.fromRGB(85, 255, 255)
	DoorEspOutlineColor = Color3.fromRGB(167, 109, 70)
	DoorEspFillColor = Color3.fromRGB(167, 109, 70)
	LockerEspOutlineColor = Color3.fromRGB(52, 54, 66)
	LockerEspFillColor = Color3.fromRGB(52, 54, 66)
	SpawnEspOutlineColor = Color3.fromRGB(0, 85, 255)
	SpawnEspFillColor = Color3.fromRGB(0, 85, 255)

	local function GetMap()
		for i, Map in pairs(workspace:GetChildren()) do
			if Map:FindFirstChild("Thumbnail") or Map:FindFirstChild("_LightingSettings") or Map:FindFirstChild("Barriers") then
				return Map
			end
		end
		return nil
	end

	local function IsMap(Map)
		if Map:FindFirstChild("Thumbnail") or Map:FindFirstChild("_LightingSettings") or Map:FindFirstChild("Barriers") then
			return true
		else
			return false
		end
	end

    Connections.Other.BeastMusicAddedConnections = {}

    local ToggleBeastMusicVolume
    local ToggleCustomBeastMusic

    local function OnCharacterAdded(Character)
        local Success, SoundChaseMusic = pcall(function()
            Character:WaitForChild("Hammer", 3):WaitForChild("Handle", 3):WaitForChild("SoundChaseMusic", 3)
            return Character.Hammer.Handle.SoundChaseMusic
        end)
        if Success then
            if ToggleBeastMusicVolume.Enabled then
                SoundChaseMusic.Volume = BeastMusicVolume
                if Connections.Other.BeastMusicChanged then
                    Connections.Other.BeastMusicChanged:Disconnect()
                    Connections.Other.BeastMusicChanged = nil
                end
                Connections.Other.BeastMusicChanged = SoundChaseMusic:GetPropertyChangedSignal("Volume"):Connect(function()
                    SoundChaseMusic.Volume = BeastMusicVolume
                end)
            else
                SoundChaseMusic.Volume = 0.4
            end
            if ToggleCustomBeastMusic.Enabled then
                if CustomBeastMusicID then
                    SoundChaseMusic.SoundId = CustomBeastMusicID
                end
                if Connections.Other.BeastMusicIdChanged then
                    Connections.Other.BeastMusicIdChanged:Disconnect()
                    Connections.Other.BeastMusicIdChanged = nil
                end
                Connections.Other.BeastMusicIdChanged = SoundChaseMusic:GetPropertyChangedSignal("SoundId"):Connect(function()
                    if CustomBeastMusicID then
                        SoundChaseMusic.SoundId = CustomBeastMusicID
                    end
                end)
            else
                SoundChaseMusic.SoundId = "rbxassetid://1846863084"
            end
        end
    end

    local function OnPlayerAdded(Player)
        local Character = GetChar(Player)
        task.spawn(OnCharacterAdded, Character)
        if Connections.Other.BeastMusicAddedConnections[`BeastMusicAdded_{Player.Name}`] then
            Connections.Other.BeastMusicAddedConnections[`BeastMusicAdded_{Player.Name}`]:Disconnect()
            Connections.Other.BeastMusicAddedConnections[`BeastMusicAdded_{Player.Name}`] = nil
        end
        Connections.Other.BeastMusicAddedConnections[`BeastMusicAdded_{Player.Name}`] = Player.CharacterAdded:Connect(OnCharacterAdded)
    end

    ToggleBeastMusicVolume = FleeTheFacilityCategory:CreateToggle({
        Text = "Beast Music Volume",
        MouseButton1Click = function(Enabled)
            if Enabled then
                for i, Player in ipairs(Players:GetPlayers()) do
                    OnPlayerAdded(Player)
                end
                Connections.Other.BeastMusicPlayerAdded = Players.PlayerAdded:Connect(OnPlayerAdded)
            else
                if Connections.Other.BeastMusicChanged then
                    Connections.Other.BeastMusicChanged:Disconnect()
                    Connections.Other.BeastMusicChanged = nil
                end
                if Connections.Other.BeastMusicPlayerAdded then
                    Connections.Other.BeastMusicPlayerAdded:Disconnect()
                    Connections.Other.BeastMusicPlayerAdded = nil
                end
                for i, v in pairs(Connections.Other.BeastMusicAddedConnections) do
                    v:Disconnect()
                    v = nil
                end
            end
        end,
    })

    ToggleBeastMusicVolume:CreateSlider({
        Text = "Volume",
        Default = BeastMusicVolume,
        Min = 0,
        Max = 10,
        Function = function(Val)
            BeastMusicVolume = Val
            if ToggleBeastMusicVolume.Disabled then return end
            for i, Player in ipairs(Players:GetPlayers()) do
                OnPlayerAdded(Player)
            end
        end,
        Function2 = function(Val)
            BeastMusicVolume = Val
            if ToggleBeastMusicVolume.Disabled then return end
            for i, Player in ipairs(Players:GetPlayers()) do
                OnPlayerAdded(Player)
            end
        end,
    })

    ToggleCustomBeastMusic = FleeTheFacilityCategory:CreateToggle({
        Text = "Custom Beast Music",
        MouseButton1Click = function(Enabled)
            if Enabled then
                for i, Player in ipairs(Players:GetPlayers()) do
                    OnPlayerAdded(Player)
                end
                Connections.Other.CustomBeastMusicPlayerAdded = Players.PlayerAdded:Connect(OnPlayerAdded)
            else
                if Connections.Other.BeastMusicIdChanged then
                    Connections.Other.BeastMusicIdChanged:Disconnect()
                    Connections.Other.BeastMusicIdChanged = nil
                end
                if Connections.Other.CustomBeastMusicPlayerAdded then
                    Connections.Other.CustomBeastMusicPlayerAdded:Disconnect()
                    Connections.Other.CustomBeastMusicPlayerAdded = nil
                end
            end
        end,
    })

    local CustomBeastMusicTextbox; CustomBeastMusicTextbox = ToggleCustomBeastMusic:CreateTextbox({
        ButtonText = "Custom Beast Music",
        PlaceholderText = "[Sound ID]",
        EnabledIndicator = true,
        MouseButton1Click = function()
            if CustomBeastMusicTextbox.Textbox.Text:find("rbxassetid://") then
                CustomBeastMusicID = CustomBeastMusicTextbox.Textbox.Text
            else
                CustomBeastMusicID = `rbxassetid://{CustomBeastMusicTextbox.Textbox.Text}`
            end
            if ToggleCustomBeastMusic.Enabled then
                for i, Player in ipairs(Players:GetPlayers()) do
                    OnPlayerAdded(Player)
                end
            end
        end,
    })

	local function UpdateComputerEspTransparency()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_ComputerESP_") and v:IsA("Highlight") then
				v.OutlineTransparency = ComputerEspOutlineTransparency
				v.FillTransparency = ComputerEspFillTransparency
			end
		end
	end

	local function EspAllComputers(Map)
		if not Map then return end
		for i, Computer in pairs(Map:GetChildren()) do
			if Computer.Name == "ComputerTable" and Computer:FindFirstChild("MainComputerScript") then
                local Screen = Computer:FindFirstChild("Screen")
                if not Screen then return end
				local Highlight = Instance.new("Highlight")
                Highlight.OutlineColor = Screen.Color
				Highlight.FillColor = Highlight.OutlineColor
                Highlight.OutlineTransparency = ComputerEspOutlineTransparency
				Highlight.FillTransparency = ComputerEspFillTransparency
				Highlight.Adornee = Computer
				Highlight.Name = "FleeTheFacility_ComputerESP_" .. tostring(i)
                Highlight.Parent = EspFolder
				Connections.FleeTheFacility["ComputerESPLoop_" .. tostring(i)] = Screen:GetPropertyChangedSignal("Color"):Connect(function()
                    Highlight.OutlineColor = Screen.Color
					Highlight.FillColor = Highlight.OutlineColor
					Highlight.OutlineTransparency = ComputerEspOutlineTransparency
				    Highlight.FillTransparency = ComputerEspFillTransparency
				end)
			end
		end
	end
	
	ToggleComputerESP = FleeTheFacilityCategory:CreateToggle({
		Text = "Computer ESP",
		Info = "Creates Outlines Around Computers",
		MouseButton1Click = function(ComputerESP)
			if ComputerESP then
				local Map = GetMap()
				EspAllComputers(Map)
				Connections.FleeTheFacility.ComputerEspWorkspaceChildAddedConnection = workspace.ChildAdded:Connect(function(Child)
                    if IsMap(Child) then
                        EspAllComputers(Child)
                    end
				end)
			else
				if Connections.FleeTheFacility.ComputerEspWorkspaceChildAddedConnection then
					Connections.FleeTheFacility.ComputerEspWorkspaceChildAddedConnection:Disconnect()
					Connections.FleeTheFacility.ComputerEspWorkspaceChildAddedConnection = nil
				end
				for i, Highlight in pairs(EspFolder:GetChildren()) do
					if string.find(Highlight.Name, "FleeTheFacility_ComputerESP_") then
						Highlight:Destroy()
					end
				end
			end	
		end,
	})

	ComputerEspOutlineTransparencySlider = ToggleComputerESP:CreateSlider({
		Text = "Outline Transparency",
        Min = 0,
		Default = 0,
		Max = 1,
		Function = function(Val)
			ComputerEspOutlineTransparency = Val
			UpdateComputerEspTransparency()
		end,
		Function2 = function(Val)
			ComputerEspOutlineTransparency = Val
			UpdateComputerEspTransparency()
		end,
	})

	ComputerEspFillTransparencySlider = ToggleComputerESP:CreateSlider({
		Text = "Fill Transparency",
        Min = 0,
		Default = 0.5,
		Max = 1,
		Function = function(Val)
			ComputerEspFillTransparency = Val
			UpdateComputerEspTransparency()
		end,
		Function2 = function(Val)
			ComputerEspFillTransparency = Val
			UpdateComputerEspTransparency()
		end,
	})

	local ShownComputerTriggers = {}
	ToggleComputerTriggerESP = ToggleComputerESP:CreateToggle({
		Text = "Trigger ESP",
		MouseButton1Click = function(ComputerTriggerESP)
			if ComputerTriggerESP then
				local Map = GetMap()
				if not Map then return end
				for i, Computer in ipairs(Map:GetChildren()) do
					if Computer.Name == "ComputerTable" then
						for i2, Trigger in ipairs(Computer:GetChildren()) do
							if Trigger:IsA("BasePart") and (Trigger:FindFirstChild("ActionSign") or Trigger:FindFirstChildWhichIsA("BindableEvent")) then
								Trigger.Transparency = ComputerTriggerEspTransparency
								table.insert(ShownComputerTriggers, Trigger)
							end
						end
					end
				end
			else
				for i, v in ipairs(ShownComputerTriggers) do
					v.Transparency = 1
				end
				table.clear(ShownComputerTriggers)
			end
		end,
	})
	
	local function UpdateComputerTriggerEspTransparency()
		for i, v in ipairs(ShownComputerTriggers) do
			v.Transparency = ComputerTriggerEspTransparency
		end
	end

	ComputerTriggerEspTransparencySlider = ToggleComputerESP:CreateSlider({
		Text = "Trigger ESP Transparency",
        Min = 0,
		Default = 0.5,
		Max = 1,
		Function = function(Val)
			ComputerTriggerEspTransparency = Val
			UpdateComputerTriggerEspTransparency()
		end,
		Function2 = function(Val)
			ComputerTriggerEspTransparency = Val
			UpdateComputerTriggerEspTransparency()
		end,
	})

	local function EspAllVents(Map)
		if not Map then return end
		for i, v in ipairs(Map:GetChildren()) do
            if v.Name == "AirVent" or v.Name == "Museum Vent" then
                local Highlight = Instance.new("Highlight")
                Highlight.OutlineColor = VentEspOutlineColor
                Highlight.FillColor = VentEspFillColor
                Highlight.OutlineTransparency = VentEspOutlineTransparency
                Highlight.FillTransparency = VentEspFillTransparency
                Highlight.Adornee = v
                Highlight.Name = "FleeTheFacility_VentESP_" .. tostring(i)
                Highlight.Parent = EspFolder
            end
		end
	end

	local function UpdateVentEspTransparency()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_VentESP_") and v:IsA("Highlight") then
				v.OutlineTransparency = VentEspOutlineTransparency
				v.FillTransparency = VentEspFillTransparency
			end
		end
	end

	local function UpdateVentEspColor()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_VentESP_") and v:IsA("Highlight") then
				v.OutlineColor = VentEspOutlineColor
				v.FillColor = VentEspFillColor
			end
		end
	end

	ToggleVentESP = FleeTheFacilityCategory:CreateToggle({
		Text = "Vent ESP",
		MouseButton1Click = function(VentESP)
			if VentESP then
				local Map = GetMap()
				EspAllVents(Map)

				Connections.FleeTheFacility.VentEspWorkspaceChildAddedConnection = workspace.ChildAdded:Connect(function(Child)
					RunService.Heartbeat:Wait()
					if IsMap(Child) then
						EspAllVents(Child)
					end
				end)
			else
				if Connections.FleeTheFacility.VentEspWorkspaceChildAddedConnection then
					Connections.FleeTheFacility.VentEspWorkspaceChildAddedConnection:Disconnect()
					Connections.FleeTheFacility.VentEspWorkspaceChildAddedConnection = nil
				end
				for i, Highlight in pairs(EspFolder:GetChildren()) do
					if string.find(Highlight.Name, "FleeTheFacility_VentESP_") then
						Highlight:Destroy()
					end
				end
			end
		end,
	})

	VentEspOutlineColorPicker = ToggleVentESP:CreateColorPicker({
		Text = "Vent ESP Outline Color",
		Default = VentEspOutlineColor,
		Function = function(Color)
			VentEspOutlineColor = Color
			UpdateVentEspColor()
		end,
	})

	VentEspFillColorPicker = ToggleVentESP:CreateColorPicker({
		Text = "Vent ESP Fill Color",
		Default = VentEspFillColor,
		Function = function(Color)
			VentEspFillColor = Color
			UpdateVentEspColor()
		end,
	})

	VentEspOutlineTransparencySlider = ToggleVentESP:CreateSlider({
		Text = "Vent ESP Outline Transparency",
        Min = 0,
		Default = 0,
		Max = 1,
		Function = function(Val)
			VentEspOutlineTransparency = Val
			UpdateVentEspTransparency()
		end,
		Function2 = function(Val)
			VentEspOutlineTransparency = Val
			UpdateVentEspTransparency()
		end,
	})

	VentEspFillTransparencySlider = ToggleVentESP:CreateSlider({
		Text = "Vent ESP Fill Transparency",
        Min = 0,
		Default = 0.5,
		Max = 1,
		Function = function(Val)
			VentEspFillTransparency = Val
			UpdateVentEspTransparency()
		end,
		Function2 = function(Val)
			VentEspFillTransparency = Val
			UpdateVentEspTransparency()
		end,
	})

	local function EspAllFreezePods(Map)
		if not Map then return end
		for i, v in ipairs(Map:GetChildren()) do
			if not (v:IsA("Model") and v.Name == "FreezePod") then continue end
			local Highlight = Instance.new("Highlight")
			Highlight.OutlineColor = FreezePodEspOutlineColor
			Highlight.FillColor = FreezePodEspFillColor
			Highlight.OutlineTransparency = FreezePodEspOutlineTransparency
			Highlight.FillTransparency = FreezePodEspFillTransparency
			Highlight.Adornee = v
			Highlight.Name = "FleeTheFacility_FreezePodESP_" .. tostring(i)
            Highlight.Parent = EspFolder
		end
	end
	
	local function UpdateFreezePodEspTransparency()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_FreezePodESP_") and v:IsA("Highlight") then
				v.OutlineTransparency = FreezePodEspOutlineTransparency
				v.FillTransparency = FreezePodEspFillTransparency
			end
		end
	end

	local function UpdateFreezePodEspColor()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_FreezePodESP_") and v:IsA("Highlight") then
				v.OutlineColor = FreezePodEspOutlineColor
				v.FillColor = FreezePodEspFillColor
			end
		end
	end
	
	ToggleFreezePodESP = FleeTheFacilityCategory:CreateToggle({
		Text = "Freeze Pod ESP",
		MouseButton1Click = function(FreezePodESP)
			if FreezePodESP then
				local Map = GetMap()
				EspAllFreezePods(Map)
				Connections.FleeTheFacility.FreezePodEspWorkspaceChildAddedConnection = workspace.ChildAdded:Connect(function(Child)
					RunService.Heartbeat:Wait()
					if IsMap(Child) then
						EspAllFreezePods(Child)
					end
				end)
			else
				if Connections.FleeTheFacility.FreezePodEspWorkspaceChildAddedConnection then
					Connections.FleeTheFacility.FreezePodEspWorkspaceChildAddedConnection:Disconnect()
					Connections.FleeTheFacility.FreezePodEspWorkspaceChildAddedConnection = nil
				end
				for i, Highlight in pairs(EspFolder:GetChildren()) do
					if string.find(Highlight.Name, "FleeTheFacility_FreezePodESP_") then
						Highlight:Destroy()
					end
				end
			end
		end,
	})

	FreezePodEspOutlineTransparencySlider = ToggleFreezePodESP:CreateSlider({
		Text = "Freeze Pod ESP Outline Transparency",
        Min = 0,
		Default = 0,
		Max = 1,
		Function = function(Val)
			FreezePodEspOutlineTransparency = Val
			UpdateFreezePodEspTransparency()
		end,
		Function2 = function(Val)
			FreezePodEspOutlineTransparency = Val
			UpdateFreezePodEspTransparency()
		end,
	})

	FreezePodEspFillTransparencySlider = ToggleFreezePodESP:CreateSlider({
		Text = "Freeze Pod ESP Fill Transparency",
        Min = 0,
		Default = 0.5,
		Max = 1,
		Function = function(Val)
			FreezePodEspFillTransparency = Val
			UpdateFreezePodEspTransparency()
		end,
		Function2 = function(Val)
			FreezePodEspFillTransparency = Val
			UpdateFreezePodEspTransparency()
		end,
	})

	FreezePodEspOutlineColorPicker = ToggleFreezePodESP:CreateColorPicker({
		Text = "Freeze Pod ESP Outline Color",
        Default = FreezePodEspOutlineColor,
		Function = function(Color)
			FreezePodEspOutlineColor = Color
			UpdateFreezePodEspColor()
		end,
	})

	FreezePodEspFillColorPicker = ToggleFreezePodESP:CreateColorPicker({
		Text = "Freeze Pod ESP Fill Color",
        Default = FreezePodEspFillColor,
		Function = function(Color)
			FreezePodEspFillColor = Color
			UpdateFreezePodEspColor()
		end,
	})

	local ShownFreezePodTriggers = {}
	ToggleFreezePodTriggerESP = ToggleFreezePodESP:CreateToggle({
		Text = "Trigger ESP",
		MouseButton1Click = function(FreezePodTriggerESP)
			if FreezePodTriggerESP then
				local Map = GetMap()
				if not Map then return end
				for i, FreezePod in ipairs(Map:GetChildren()) do
					if FreezePod.Name == "FreezePod" then
						for i2, Trigger in ipairs(FreezePod:GetChildren()) do
							if Trigger:IsA("BasePart") and (Trigger:FindFirstChild("ActionSign") or Trigger:FindFirstChildWhichIsA("BindableEvent")) then
								Trigger.Transparency = FreezePodTriggerEspTransparency
								table.insert(ShownFreezePodTriggers, Trigger)
							end
						end
					end
				end
			else
				for i, v in ipairs(ShownFreezePodTriggers) do
					v.Transparency = 1
				end
				table.clear(ShownFreezePodTriggers)
			end
		end,
	})

	local function UpdateFreezePodTriggerEspTransparency()
		for i, v in ipairs(ShownFreezePodTriggers) do
			v.Transparency = FreezePodTriggerEspTransparency
		end
	end
	
	FreezePodTriggerEspTransparencySlider = ToggleFreezePodESP:CreateSlider({
		Text = "Trigger ESP Transparency",
        Min = 0,
		Default = 0.5,
		Max = 1,
		Function = function(Val)
			FreezePodTriggerEspTransparency = Val
			UpdateFreezePodTriggerEspTransparency()
		end,
		Function2 = function(Val)
			FreezePodTriggerEspTransparency = Val
			UpdateFreezePodTriggerEspTransparency()
		end,
	})

	local function EspAllExits(Map)
		if not Map then return end
		for i, v in ipairs(Map:GetChildren()) do
			if not (v:IsA("Model") and v.Name == "ExitDoor") then continue end
			local Highlight = Instance.new("Highlight")
			Highlight.OutlineColor = ExitEspOutlineColor
			Highlight.FillColor = ExitEspFillColor
			Highlight.OutlineTransparency = VentEspOutlineTransparency
			Highlight.FillTransparency = VentEspFillTransparency
			Highlight.Adornee = v
			Highlight.Name = "FleeTheFacility_ExitESP_" .. tostring(i)
            Highlight.Parent = EspFolder
		end
	end

	local function UpdateExitEspTransparency()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_ExitESP_") and v:IsA("Highlight") then
				v.OutlineTransparency = ExitEspOutlineTransparency
				v.FillTransparency = ExitEspFillTransparency
			end
		end
	end

	local function UpdateExitEspColor()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_ExitESP_") and v:IsA("Highlight") then
				v.OutlineColor = ExitEspOutlineColor
				v.FillColor = ExitEspFillColor
			end
		end
	end

	ToggleExitESP = FleeTheFacilityCategory:CreateToggle({
		Text = "Exit ESP",
		MouseButton1Click = function(ExitESP)
			if ExitESP then
				local Map = GetMap()
				EspAllExits(Map)

				Connections.Visuals.FleeTheFacility.ExitEspWorkspaceChildAddedConnection = workspace.ChildAdded:Connect(function(Child)
					RunService.Heartbeat:Wait()
					if IsMap(Child) then
						EspAllExits(Child)
					end
				end)
			else
				if Connections.Visuals.FleeTheFacility.ExitEspWorkspaceChildAddedConnection then
					Connections.Visuals.FleeTheFacility.ExitEspWorkspaceChildAddedConnection:Disconnect()
					Connections.Visuals.FleeTheFacility.ExitEspWorkspaceChildAddedConnection = nil
				end
				for i, Highlight in pairs(EspFolder:GetChildren()) do
					if string.find(Highlight.Name, "FleeTheFacility_ExitESP_") then
						Highlight:Destroy()
					end
				end
			end
		end,
	})
	
	ExitEspOutlineTransparencySlider = ToggleExitESP:CreateSlider({
		Text = "Exit ESP Outline Transparency",
        Min = 0,
		Default = 0,
		Max = 1,
		Function = function(Val)
			ExitEspOutlineTransparency = Val
			UpdateExitEspTransparency()
		end,
		Function2 = function(Val)
			ExitEspOutlineTransparency = Val
			UpdateExitEspTransparency()
		end,
	})

	ExitEspFillTransparencySlider = ToggleExitESP:CreateSlider({
		Text = "Exit ESP Fill Transparency",
        Min = 0,
		Default = 0.5,
		Max = 1,
		Function = function(Val)
			ExitEspFillTransparency = Val
			UpdateExitEspTransparency()
		end,
		Function2 = function(Val)
			ExitEspFillTransparency = Val
			UpdateExitEspTransparency()
		end,
	})

	ExitEspOutlineColorPicker = ToggleExitESP:CreateColorPicker({
		Text = "Exit ESP Outline Color",
        Default = ExitEspOutlineColor,
		Function = function(Color)
			ExitEspOutlineColor = Color
			UpdateExitEspColor()
		end,
	})

	ExitEspFillColorPicker = ToggleExitESP:CreateColorPicker({
		Text = "Exit ESP Fill Color",
        Default = ExitEspFillColor,
		Function = function(Color)
			ExitEspFillColor = Color
			UpdateExitEspColor()
		end,
	})

	local ShownExitTriggers = {}
	ToggleExitTriggerESP = ToggleExitESP:CreateToggle({
		Text = "Trigger ESP",
		MouseButton1Click = function(ExitTriggerESP)
			if ExitTriggerESP then
				local Map = GetMap()
				if not Map then return end
				for i, Exit in ipairs(Map:GetChildren()) do
					if Exit.Name == "ExitDoor" then
						for i2, Trigger in ipairs(Exit:GetChildren()) do
							if Trigger:IsA("BasePart") and (Trigger:FindFirstChild("ActionSign") or Trigger:FindFirstChildWhichIsA("BindableEvent")) then
								Trigger.Transparency = ExitTriggerEspTransparency
								table.insert(ShownExitTriggers, Trigger)
							end
						end
					end
				end
			else
				for i, v in ipairs(ShownExitTriggers) do
					v.Transparency = 1
				end
				table.clear(ShownExitTriggers)
			end
		end,
	})

	local function UpdateExitTriggerEspTransparency()
		for i, v in ipairs(ShownExitTriggers) do
			v.Transparency = ExitTriggerEspTransparency
		end
	end

	ExitTriggerEspTransparencySlider = ToggleExitESP:CreateSlider({
		Text = "Trigger ESP Transparency",
        Min = 0,
		Default = 0.5,
		Max = 1,
		Function = function(Val)
			ExitTriggerEspTransparency = Val
			UpdateExitTriggerEspTransparency()
		end,
		Function2 = function(Val)
			ExitTriggerEspTransparency = Val
			UpdateExitTriggerEspTransparency()
		end,
	})

	local function EspAllWindows(Map)
		if not Map then return end
		for i, v in ipairs(Map:GetChildren()) do
			if not (v:IsA("Model") and v.Name == "Window") then continue end
			local Highlight = Instance.new("Highlight")
			Highlight.OutlineColor = WindowEspOutlineColor
			Highlight.FillColor = WindowEspFillColor
			Highlight.OutlineTransparency = WindowEspOutlineTransparency
			Highlight.FillTransparency = WindowEspFillTransparency
			Highlight.Adornee = v
			Highlight.Name = "FleeTheFacility_WindowESP_" .. tostring(i)
            Highlight.Parent = EspFolder
		end
	end

	local function UpdateWindowEspTransparency()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_WindowESP_") and v:IsA("Highlight") then
				v.OutlineTransparency = WindowEspOutlineTransparency
				v.FillTransparency = WindowEspFillTransparency
			end
		end
	end

	local function UpdateWindowEspColor()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_WindowESP_") and v:IsA("Highlight") then
				v.OutlineColor = WindowEspOutlineColor
				v.FillColor = WindowEspFillColor
			end
		end
	end

	ToggleWindowESP = FleeTheFacilityCategory:CreateToggle({
		Text = "Window ESP",
		MouseButton1Click = function(WindowESP)
			if WindowESP then
				local Map = GetMap()
				EspAllWindows(Map)
				
				Connections.Visuals.FleeTheFacility.WindowEspWorkspaceChildAddedConnection = workspace.ChildAdded:Connect(function(Child)
					RunService.Heartbeat:Wait()
					if IsMap(Child) then
						EspAllWindows(Child)
					end
				end)
			else
				if Connections.Visuals.FleeTheFacility.WindowEspWorkspaceChildAddedConnection then
					Connections.Visuals.FleeTheFacility.WindowEspWorkspaceChildAddedConnection:Disconnect()
					Connections.Visuals.FleeTheFacility.WindowEspWorkspaceChildAddedConnection = nil
				end
				for i, Highlight in pairs(EspFolder:GetChildren()) do
					if string.find(Highlight.Name, "FleeTheFacility_WindowESP_") then
						Highlight:Destroy()
					end
				end
			end
		end,
	})

	WindowEspOutlineTransparencySlider = ToggleWindowESP:CreateSlider({
		Text = "Window ESP Outline Transparency",
        Min = 0,
		Default = 0,
		Max = 1,
		Function = function(Val)
			WindowEspOutlineTransparency = Val
			UpdateWindowEspTransparency()
		end,
		Function2 = function(Val)
			WindowEspOutlineTransparency = Val
			UpdateWindowEspTransparency()
		end,
	})

	WindowEspFillTransparencySlider = ToggleWindowESP:CreateSlider({
		Text = "Window ESP Fill Transparency",
        Min = 0,
		Default = 0.5,
		Max = 1,
		Function = function(Val)
			WindowEspFillTransparency = Val
			UpdateWindowEspTransparency()
		end,
		Function2 = function(Val)
			WindowEspFillTransparency = Val
			UpdateWindowEspTransparency()
		end,
	})

	WindowEspOutlineColorPicker = ToggleWindowESP:CreateColorPicker({
		Text = "Window ESP Outline Color",
        Default = WindowEspOutlineColor,
		Function = function(Color)
			WindowEspOutlineColor = Color
			UpdateWindowEspColor()
		end,
	})

	WindowEspFillColorPicker = ToggleWindowESP:CreateColorPicker({
		Text = "Window ESP Fill Color",
        Default = WindowEspFillColor,
		Function = function(Color)
			WindowEspFillColor = Color
			UpdateWindowEspColor()
		end,
	})

	local function EspAllDoors(Map)
		if not Map then return end
		for i, v in ipairs(Map:GetChildren()) do
			if not (v:IsA("Model") and v.Name == "SingleDoor" or v.Name == "DoubleDoor") then continue end
			local Highlight = Instance.new("Highlight")
			Highlight.OutlineColor = DoorEspOutlineColor
			Highlight.FillColor = DoorEspFillColor
			Highlight.OutlineTransparency = DoorEspOutlineTransparency
			Highlight.FillTransparency = DoorEspFillTransparency
			Highlight.Adornee = v
			Highlight.Name = "FleeTheFacility_DoorESP_" .. tostring(i)
            Highlight.Parent = EspFolder
		end
	end
	
	local function UpdateDoorEspTransparency()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_DoorESP_") and v:IsA("Highlight") then
				v.OutlineTransparency = DoorEspOutlineTransparency
				v.FillTransparency = DoorEspFillTransparency
			end
		end
	end

	local function UpdateDoorEspColor()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_DoorESP_") and v:IsA("Highlight") then
				v.OutlineColor = DoorEspOutlineColor
				v.FillColor = DoorEspFillColor
			end
		end
	end

	ToggleDoorESP = FleeTheFacilityCategory:CreateToggle({
		Text = "Door ESP",
		MouseButton1Click = function(DoorESP)
			if DoorESP then
				local Map = GetMap()
				EspAllDoors(Map)

				Connections.Visuals.FleeTheFacility.DoorEspWorkspaceChildAddedConnection = workspace.ChildAdded:Connect(function(Child)
					RunService.Heartbeat:Wait()
					if IsMap(Child) then
						EspAllDoors(Child)
					end
				end)
			else
				if Connections.Visuals.FleeTheFacility.DoorEspWorkspaceChildAddedConnection then
					Connections.Visuals.FleeTheFacility.DoorEspWorkspaceChildAddedConnection:Disconnect()
					Connections.Visuals.FleeTheFacility.DoorEspWorkspaceChildAddedConnection = nil
				end
				for i, Highlight in pairs(EspFolder:GetChildren()) do
					if string.find(Highlight.Name, "FleeTheFacility_DoorESP_") then
						Highlight:Destroy()
					end
				end
			end
		end,
	})

	DoorEspOutlineTransparencySlider = ToggleDoorESP:CreateSlider({
		Text = "Door ESP Outline Transparency",
        Min = 0,
		Default = 0,
		Max = 1,
		Function = function(Val)
			DoorEspOutlineTransparency = Val
			UpdateDoorEspTransparency()
		end,
		Function2 = function(Val)
			DoorEspOutlineTransparency = Val
			UpdateDoorEspTransparency()
		end,
	})

	DoorEspFillTransparencySlider = ToggleDoorESP:CreateSlider({
		Text = "Door ESP Fill Transparency",
        Min = 0,
		Default = 0.5,
		Max = 1,
		Function = function(Val)
			DoorEspFillTransparency = Val
			UpdateDoorEspTransparency()
		end,
		Function2 = function(Val)
			DoorEspFillTransparency = Val
			UpdateDoorEspTransparency()
		end,
	})

	DoorEspOutlineColorPicker = ToggleDoorESP:CreateColorPicker({
		Text = "Door ESP Outline Color",
        Default = DoorEspOutlineColor,
		Function = function(Color)
			DoorEspOutlineColor = Color
			UpdateDoorEspColor()
		end,
	})

	DoorEspFillColorPicker = ToggleDoorESP:CreateColorPicker({
		Text = "Door ESP Fill Color",
        Default = DoorEspFillColor,
		Function = function(Color)
			DoorEspFillColor = Color
			UpdateDoorEspColor()
		end,
	})

	local ShownDoorTriggers = {}
	ToggleDoorTriggerESP = ToggleDoorESP:CreateToggle({
		Text = "Door Trigger ESP",
		MouseButton1Click = function(DoorTriggerESP)
			if DoorTriggerESP then
				local Map = GetMap()
				if not Map then return end
				for i, Door in ipairs(Map:GetChildren()) do
					if Door.Name == "SingleDoor" or Door.Name == "DoubleDoor" then
						for i2, Trigger in ipairs(Door:GetChildren()) do
							if Trigger:IsA("BasePart") and (Trigger:FindFirstChild("ActionSign") or Trigger:FindFirstChildWhichIsA("BindableEvent")) then
								Trigger.Transparency = DoorTriggerEspTransparency
								table.insert(ShownDoorTriggers, Trigger)
							end
						end
					end
				end
			else
				for i, v in ipairs(ShownDoorTriggers) do
					v.Transparency = 1
				end
				table.clear(ShownDoorTriggers)
			end
		end,
	})

	local function UpdateDoorTriggerEspTransparency()
		for i, v in ipairs(ShownDoorTriggers) do
			v.Transparency = DoorTriggerEspTransparency
		end
	end

	DoorTriggerEspTransparencySlider = ToggleDoorESP:CreateSlider({
		Text = "Door Trigger ESP Transparency",
        Min = 0,
		Default = 0.5,
		Max = 1,
		Function = function(Val)
			DoorTriggerEspTransparency = Val
			UpdateDoorTriggerEspTransparency()
		end,
		Function2 = function(Val)
			DoorTriggerEspTransparency = Val
			UpdateDoorTriggerEspTransparency()
		end,
	})

	local function EspAllLockers(Map)
		if not Map then return end
		for i, v in ipairs(Map:GetChildren()) do
			if not (v:IsA("Model") and v.Name == "HidingCloset") then continue end
			local Highlight = Instance.new("Highlight")
			Highlight.OutlineColor = DoorEspOutlineColor
			Highlight.FillColor = DoorEspFillColor
			Highlight.OutlineTransparency = DoorEspOutlineTransparency
			Highlight.FillTransparency = DoorEspFillTransparency
			Highlight.Adornee = v
			Highlight.Name = "FleeTheFacility_LockerESP_" .. tostring(i)
            Highlight.Parent = EspFolder
		end
	end

	local function UpdateLockerEspTransparency()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_LockerESP_") and v:IsA("Highlight") then
				v.OutlineTransparency = LockerEspOutlineTransparency
				v.FillTransparency = LockerEspFillTransparency
			end
		end
	end

	local function UpdateLockerEspColor()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_LockerESP_") and v:IsA("Highlight") then
				v.OutlineColor = LockerEspOutlineColor
				v.FillColor = LockerEspFillColor
			end
		end
	end
	
	ToggleLockerESP = FleeTheFacilityCategory:CreateToggle({
		Text = "Locker ESP",
		MouseButton1Click = function(LockerESP)
			if LockerESP then
				local Map = GetMap()
				EspAllLockers(Map)

				Connections.Visuals.FleeTheFacility.LockerEspWorkspaceChildAddedConnection = workspace.ChildAdded:Connect(function(Child)
					RunService.Heartbeat:Wait()
					if IsMap(Child) then
						EspAllLockers(Child)
					end
				end)
			else
				if Connections.Visuals.FleeTheFacility.LockerEspWorkspaceChildAddedConnection then
					Connections.Visuals.FleeTheFacility.LockerEspWorkspaceChildAddedConnection:Disconnect()
					Connections.Visuals.FleeTheFacility.LockerEspWorkspaceChildAddedConnection = nil
				end
				for i, Highlight in pairs(EspFolder:GetChildren()) do
					if string.find(Highlight.Name, "FleeTheFacility_LockerESP_") then
						Highlight:Destroy()
					end
				end
			end
		end,
	})

	LockerEspOutlineTransparencySlider = ToggleLockerESP:CreateSlider({
		Text = "Locker ESP Outline Transparency",
        Min = 0,
		Default = 0,
		Max = 1,
		Function = function(Val)
			LockerEspOutlineTransparency = Val
			UpdateLockerEspTransparency()
		end,
		Function2 = function(Val)
			LockerEspOutlineTransparency = Val
			UpdateLockerEspTransparency()
		end,
	})

	LockerEspFillTransparencySlider = ToggleLockerESP:CreateSlider({
		Text = "Locker ESP Fill Transparency",
        Min = 0,
		Default = 0.5,
		Max = 1,
		Function = function(Val)
			LockerEspFillTransparency = Val
			UpdateLockerEspTransparency()
		end,
		Function2 = function(Val)
			LockerEspFillTransparency = Val
			UpdateLockerEspTransparency()
		end,
	})

	LockerEspOutlineColorPicker = ToggleLockerESP:CreateColorPicker({
		Text = "Locker ESP Outline Color",
        Default = LockerEspOutlineColor,
		Function = function(Color)
			DoorEspOutlineColor = Color
			UpdateLockerEspColor()
		end,
	})

	LockerEspFillColorPicker = ToggleLockerESP:CreateColorPicker({
		Text = "Locker ESP Fill Color",
        Default = LockerEspFillColor,
		Function = function(Color)
			DoorEspFillColor = Color
			UpdateLockerEspColor()
		end,
	})

	local function EspAllSpawns(Map)
		if not Map then return end
		for i, v in ipairs(Map:GetChildren()) do
			if not (v:IsA("Model") and v.Name == "GameSpawnPads") then continue end
			local Highlight = Instance.new("Highlight")
			Highlight.OutlineColor = DoorEspOutlineColor
			Highlight.FillColor = DoorEspFillColor
			Highlight.OutlineTransparency = DoorEspOutlineTransparency
			Highlight.FillTransparency = DoorEspFillTransparency
			Highlight.Adornee = v
			Highlight.Name = "FleeTheFacility_SpawnESP_" .. tostring(i)
            Highlight.Parent = EspFolder
			for i2, v2 in ipairs(v:GetChildren()) do
				if v2:IsA("BasePart") then
					v2.Transparency = 0
				end
			end
		end
	end
	
	local function UpdateSpawnEspTransparency()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_SpawnESP_") and v:IsA("Highlight") then
				v.OutlineTransparency = SpawnEspOutlineTransparency
				v.FillTransparency = SpawnEspFillTransparency
			end
		end
	end
	
	local function UpdateSpawnEspColor()
		for i, v in ipairs(EspFolder:GetChildren()) do
			if string.find(v.Name, "FleeTheFacility_SpawnESP_") and v:IsA("Highlight") then
				v.OutlineColor = SpawnEspOutlineColor
				v.FillColor = SpawnEspFillColor
			end
		end
	end
	
	ToggleSpawnESP = FleeTheFacilityCategory:CreateToggle({
		Text = "Spawn ESP",
		MouseButton1Click = function(SpawnESP)
			if SpawnESP then
				local Map = GetMap()
				EspAllSpawns(Map)

				Connections.Visuals.FleeTheFacility.SpawnEspWorkspaceChildAddedConnection = workspace.ChildAdded:Connect(function(Child)
					RunService.Heartbeat:Wait()
					if IsMap(Child) then
						EspAllSpawns(Child)
					end
				end)
			else
				if Connections.Visuals.FleeTheFacility.SpawnEspWorkspaceChildAddedConnection then
					Connections.Visuals.FleeTheFacility.SpawnEspWorkspaceChildAddedConnection:Disconnect()
					Connections.Visuals.FleeTheFacility.SpawnEspWorkspaceChildAddedConnection = nil
				end
				for i, Highlight in pairs(EspFolder:GetChildren()) do
					if string.find(Highlight.Name, "FleeTheFacility_SpawnESP_") then
						Highlight:Destroy()
					end
				end
			end
		end,
	})

	SpawnEspOutlineTransparencySlider = ToggleSpawnESP:CreateSlider({
		Text = "Locker ESP Outline Transparency",
        Min = 0,
		Default = 0,
		Max = 1,
		Function = function(Val)
			LockerEspOutlineTransparency = Val
			UpdateSpawnEspTransparency()
		end,
		Function2 = function(Val)
			LockerEspOutlineTransparency = Val
			UpdateSpawnEspTransparency()
		end,
	})

	SpawnEspFillTransparencySlider = ToggleSpawnESP:CreateSlider({
		Text = "Locker ESP Fill Transparency",
        Min = 0,
		Default = 0.5,
		Max = 1,
		Function = function(Val)
			LockerEspFillTransparency = Val
			UpdateSpawnEspTransparency()
		end,
		Function2 = function(Val)
			LockerEspFillTransparency = Val
			UpdateSpawnEspTransparency()
		end,
	})

	SpawnEspOutlineColorPicker = ToggleSpawnESP:CreateColorPicker({
		Text = "Spawn ESP Outline Color",
        Default = SpawnEspOutlineColor,
		Function = function(Color)
			DoorEspOutlineColor = Color
			UpdateSpawnEspColor()
		end,
	})

	SpawnEspFillColorPicker = ToggleSpawnESP:CreateColorPicker({
		Text = "Spawn ESP Fill Color",
        Default = SpawnEspFillColor,
		Function = function(Color)
			DoorEspFillColor = Color
			UpdateSpawnEspColor()
		end,
	})

	local function GetClosestComputers()
		local ClosestComputerDistance
        local ClosestComputer
		local ClosestComputers = {}
        local Computers = {}
		local Map = GetMap()
		if not Map then return nil end
		local Char = GetChar(Plr)
		local Root = GetRoot(Char)
		if not (Char and Root) then return nil end

        for i, v in ipairs(Map:GetChildren()) do
            if v:IsA("Model") and v.Name == "ComputerTable" then
                table.insert(Computers, v)
            end
        end

        for i = 1, #Computers do
            ClosestComputerDistance = math.huge
            for i, v in ipairs(Computers) do
                local Screen = v:FindFirstChild("Screen")
                if Screen and Screen.Color == Color3.fromRGB(13, 105, 172) then
                    local ComputerRoot = GetRoot(v) or v:FindFirstChild("BasePart") or v:FindFirstChild("ClearTable") or v:FindFirstChild("Table")
                    if not ComputerRoot then continue end
                    local Mag = (Root.Position - ComputerRoot.Position).Magnitude
                    if Mag < ClosestComputerDistance then
                        ClosestComputerDistance = Mag
                        ClosestComputer = v
                    end
                end
            end
            table.insert(ClosestComputers, ClosestComputer)
        end
		
		return ClosestComputers
	end
    
	KillAura = false

    ToggleKillAura = FleeTheFacilityCategory:CreateToggle({
        Text = "Kill Aura",
        MouseButton1Click = function(KillAura)
            if KillAura then
                Connections.Combat.FleeTheFacilityKillAuraLoop = RunService.Heartbeat:Connect(function()
                    local Player = GetClosestPlayer()
                    local PlayerChar = GetChar(Player)
                    local PlayerRoot = GetRoot(PlayerChar)
                    local Char = GetChar(Plr)
                    if not (Player and PlayerChar and PlayerRoot and Char) then return end
                    if Char:FindFirstChild("Hammer") and Char.Hammer:FindFirstChild("HammerEvent") then
                        Char.Hammer.HammerEvent:FireServer("HammerHit", PlayerRoot)
                    end
                end)
            else
                if Connections.Combat.FleeTheFacilityKillAuraLoop then
                    Connections.Combat.FleeTheFacilityKillAuraLoop:Disconnect()
                    Connections.Combat.FleeTheFacilityKillAuraLoop = nil
                end
            end
        end,
    })

    CrouchAsBeast = false

    ToggleCrouchAsBeast = FleeTheFacilityCategory:CreateToggle({
        Text = "Crouch As Beast",
        MouseButton1Click = function(CrouchAsBeast)
            if CrouchAsBeast then
                local Char = GetChar(Plr)
                local CrawlScript = Char and Char:FindFirstChild("CrawlScript")
                if CrawlScript then
                    CrawlScript.Enabled = true
                    Connections.Other.CrouchAsBeastConnection = CrawlScript:GetPropertyChangedSignal("Enabled"):Connect(function()
                        CrawlScript.Enabled = true
                    end)
                end
            else
                if Connections.Other.CrouchAsBeastConnection then
                    Connections.Other.CrouchAsBeastConnection:Disconnect()
                    Connections.Other.CrouchAsBeastConnection = nil
                end
                local Char = GetChar(Plr)
                local CrawlScript = Char and Char:FindFirstChild("CrawlScript")
                if CrawlScript then
                    CrawlScript.Enabled = Char and Char:FindFirstChild("Hammer") == nil or true
                end
            end
        end,
    })

    AutoWin = false
    local PathfindingModifiers = {}

    local function GetBeast()
        local Beast = nil
        for i, Player in ipairs(Players:GetPlayers()) do
            if Player == Plr or Player.UserId == Plr.UserId then continue end
            local PlayerChar = GetChar(Player)
            if PlayerChar and PlayerChar:FindFirstChild("Hammer") then
                Beast = Player
            end
        end
        return Beast
    end

    local function GetClosestVents()
        local ClosestVentDistance
        local ClosestVent
        local ClosestVents = {}
        local Vents = {}
        local Map = GetMap()
        if not Map then return end
        local Char = GetChar(Plr)
        local Root = GetRoot(Char)
        if not (Char and Root) then return end

        for i, v in ipairs(Map:GetChildren()) do
            if v.Name == "AirVent" or v.Name == "Museum Vent" then
                table.insert(Vents, v)
            end
        end

        for i = 1, #Vents do
            ClosestVentDistance = math.huge
            for i, Vent in ipairs(Vents) do
                local Magnitude = ((Vent.PrimaryPart or Vent.WorldPivot).Position - Root.Position).Magnitude
                if Magnitude < ClosestVentDistance then
                    ClosestVentDistance = Magnitude
                    ClosestVent = Vent
                end
            end
            table.insert(ClosestVents, ClosestVent)
        end
        return ClosestVents
    end

    local function GetClosestWindows()
        local ClosestWindowDistance
        local ClosestWindow
        local ClosestWindows = {}
        local Windows = {}
        local Map = GetMap()
        if not Map then return end
        local Char = GetChar(Plr)
        local Root = GetRoot(Char)
        if not (Char and Root) then return end

        for i, v in ipairs(Map:GetChildren()) do
            if v.Name == "Window" then
                table.insert(Windows, v)
            end
        end

        for i = 1, #Windows do
            ClosestWindowDistance = math.huge
            for i, Window in ipairs(Windows) do
                local Magnitude = ((Window.PrimaryPart or Window.WorldPivot).Position - Root.Position).Magnitude
                if Magnitude < ClosestWindowDistance then
                    ClosestWindowDistance = Magnitude
                    ClosestWindow = Window
                end
            end
            table.insert(ClosestWindows, ClosestWindow)
        end
        return ClosestWindows
    end

    local function GetClosestDoors()
        local ClosestDoorDistance
        local ClosestDoor
        local ClosestDoors = {}
        local Doors = {}
        local Map = GetMap()
        if not Map then return end
        local Char = GetChar(Plr)
        local Root = GetRoot(Char)
        if not (Char and Root) then return end

        for i, v in ipairs(Map:GetChildren()) do
            if v.Name == "SingleDoor" or v.Name == "DoubleDoor" then
                table.insert(Doors, v)
            end
        end

        for i = 1, #Doors do
            ClosestDoorDistance = math.huge
            for i, Door in ipairs(Doors) do
                local Magnitude = ((Door.PrimaryPart or Door.WorldPivot).Position - Root.Position)
                if Magnitude < ClosestDoorDistance then
                    ClosestDoorDistance = Magnitude
                    ClosestDoor = Door
                end
            end
            table.insert(ClosestDoors, ClosestDoor)
        end
        return ClosestDoors
    end

    ToggleAutoWin = FleeTheFacilityCategory:CreateToggle({
        Text = "Auto Win",
        Info = "Only Works As Beast",
        MouseButton1Click = function(Bool)
			AutoWin = Bool
            task.spawn(function()
                if KillAura then
                    ToggleKillAura:Toggle({NoNotify = true})
                end
                local Map = GetMap()
                local Beast
                while AutoWin do
                    RunService.Heartbeat:Wait()
                    if not ReplicatedStorage.IsGameActive.Value then continue end
                    local Char = GetChar(Plr)
                    local Root = GetRoot(Char)
                    local Humanoid = GetHumanoid(Char)
                    if not (Char and Root) then continue end
                    local Hammer = Char:FindFirstChild("Hammer")
                    if Hammer then
                        local AllPlayers = Players:GetPlayers()
                        table.remove(AllPlayers, table.find(AllPlayers, Plr))
                        local FreezePods = {}
                        Map = Map or GetMap()
                        if not Map then RunService.Heartbeat:Wait(); continue end
                        for i, FreezePod in ipairs(Map:GetChildren()) do
                            if FreezePod.Name == "FreezePod" then
                                table.insert(FreezePods, FreezePod)
                            end
                        end
                        for i, Player in ipairs(AllPlayers) do
                            local PlayerChar = GetChar(Player)
                            local PlayerRoot = GetRoot(PlayerChar)
                            if not (PlayerChar and PlayerRoot) then continue end
                            Root.CFrame = PlayerRoot.CFrame
                            task.wait(0.1)
                            RunService.Heartbeat:Wait()
                            Char.Hammer.HammerEvent:FireServer("HammerHit", PlayerRoot)
                            task.wait(0.1)
                            RunService.Heartbeat:Wait()
                            Char.Hammer.HammerEvent:FireServer("HammerTieUp", PlayerRoot, PlayerRoot.Position)
                            if FreezePods[i] and FreezePods[i].PrimaryPart then
                                Root.CFrame = FreezePods[i].PrimaryPart.CFrame * CFrame.new(0, 4, -4)
                                task.wait(0.1)
                                RunService.Heartbeat:Wait()
                                ReplicatedStorage.RemoteEvent:FireServer("Input", "Action", true)
                            end
                        end
                    else
                        if not Humanoid then RunService.Heartbeat:Wait(); continue end
                        Map = Map or GetMap()
                        if not Map then RunService.Heartbeat:Wait(); continue end
                        for i, v in ipairs(PathfindingModifiers) do
                            v:Destroy()
                            v = nil
                        end
                        if Connections.Other.SkillCheckConnection then
                            Connections.Other.SkillCheckConnection:Disconnect()
                            Connections.Other.SkillCheckConnection = nil
                        end
                        Beast = GetBeast()
                        local BeastChar = GetChar(Beast)
                        local BeastRoot = GetRoot(BeastChar)
                        if (BeastRoot.Position - Root.Position).Magnitude >= 75 then
                            local ClosestComputers = GetClosestComputers()
                            if #ClosestComputers > 0 then
                                for i, Computer in ipairs(ClosestComputers) do
                                    local ComputerRoot = GetRoot(Computer)
                                    if not ComputerRoot then continue end
                                    if (BeastRoot.Position - ComputerRoot.Position).Magnitude >= 75 then
                                        local Path = PathfindingService:CreatePath({
                                            AgentHeight = 1.8,
                                            AgentRadius = 2.1,
                                            AgentCanClimb = true,
                                        })
                                        local Start = Root.Position
                                        if not AutoWin then break end
                                        local Screen = Computer:FindFirstChild("Screen")
                                        local ComputerTrigger1 = Computer:FindFirstChild("ComputerTrigger1")
                                        local ComputerTrigger1Value = ComputerTrigger1 and ComputerTrigger1:FindFirstChild("ActionSign")
                                        local ComputerTrigger2 = Computer:FindFirstChild("ComputerTrigger2")
                                        local ComputerTrigger2Value = ComputerTrigger2 and ComputerTrigger2:FindFirstChild("ActionSign")
                                        local ComputerTrigger3 = Computer:FindFirstChild("ComputerTrigger3")
                                        local ComputerTrigger3Value = ComputerTrigger3 and ComputerTrigger3:FindFirstChild("ActionSign")
                                        local Goal = if ComputerTrigger1 and ComputerTrigger1Value and ComputerTrigger1Value.Value == 20 then ComputerTrigger1.Position elseif ComputerTrigger2 and ComputerTrigger2Value and ComputerTrigger2Value.Value == 20 then ComputerTrigger2.Position elseif ComputerTrigger3 and ComputerTrigger3Value and ComputerTrigger3Value.Value == 20 then ComputerTrigger3.Position else nil
                                        if Goal then
                                            Path:ComputeAsync(Start, Goal)
                                            if Path.Status == Enum.PathStatus.NoPath then continue end
                                            local Params = RaycastParams.new()
                                            Params.FilterDescendantsInstances = {Char}
                                            local ClosestVents = GetClosestVents()
                                            for i, Waypoint in ipairs(Path:GetWaypoints()) do
                                                if (Root.Position - BeastRoot.Position).Magnitude < 75 then break end
                                                if not AutoWin then break end
                                                local Raycast = workspace:Raycast(Root.Position, Waypoint.Position - Root.Position, Params)
                                                if Raycast and Raycast.Instance then
                                                    local Door = Raycast.Instance:FindFirstAncestor("SingleDoor") or Raycast.Instance:FindFirstAncestor("DoubleDoor")
                                                    if Door then
                                                        local RemoteEvent = ReplicatedStorage:FindFirstChild("RemoteEvent")
                                                        if RemoteEvent then
                                                            RemoteEvent:FireServer("Input", "Action", true)
                                                            task.wait(0.25)
                                                        end
                                                    end
                                                end
                                                if ((ClosestVents[1].PrimaryPart or ClosestVents[1].WorldPivot).Position - Root.Position).Magnitude < 3 then
                                                    KeyPress(KeycodeMap.LeftShift)
                                                end
                                                if Waypoint.Action == Enum.PathWaypointAction.Jump then
                                                    Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                                                end
                                                Humanoid:MoveTo(Waypoint.Position)
                                                local ModdedRootPos = Vector3.new(Root.Position.X, 0, Root.Position.Z)
                                                local ModdedWaypointPos = Vector3.new(Waypoint.Position.X, 0, Waypoint.Position.Z)
                                                local Clock = os.clock()
                                                repeat
                                                    RunService.Heartbeat:Wait()
                                                    ModdedRootPos = Vector3.new(Root.Position.X, 0, Root.Position.Z)
                                                until ((ModdedRootPos - ModdedWaypointPos).Magnitude < 1) or (os.clock() - Clock > 5) or (not AutoWin) or ((Root.Position - BeastRoot.Position).Magnitude < 75)
                                                if ((ClosestVents[1].PrimaryPart or ClosestVents[1].WorldPivot).Position - Root.Position).Magnitude < 3 then
                                                    KeyRelease(KeycodeMap.LeftShift)
                                                end
                                                if not AutoWin then
                                                    break
                                                end
                                            end
                                            local Success, ActionBox = pcall(function()
                                                return Plr.PlayerGui.ScreenGui.ActionBox
                                            end)
                                            if Success then
                                                repeat
                                                    task.wait()
                                                until ActionBox.Visible
                                                task.wait(0.1)
                                            else
                                                task.wait(0.25)
                                            end
                                            local RemoteEvent = ReplicatedStorage:FindFirstChild("RemoteEvent")
                                            if RemoteEvent then
                                                RemoteEvent:FireServer("Input", "Action", true)
                                            end
                                            local Success, TimingCircle, TimingPin = pcall(function()
                                                return Plr.PlayerGui.ScreenGui.TimingCircle.TimingBase, Plr.PlayerGui.ScreenGui.TimingCircle.TimingPin
                                            end)
                                            Connections.Other.SkillCheckConnection = Success and TimingCircle:GetPropertyChangedSignal("Visible"):Connect(function()
                                                if TimingCircle.Visible and RemoteEvent then
                                                    repeat
                                                        task.wait()
                                                    until math.abs(TimingCircle.Rotation - TimingPin) < 10
                                                    RemoteEvent:FireServer("SetPlayerMinigameResult", true)
                                                end
                                            end)
                                            repeat task.wait() until Screen.Color == Color3.fromRGB(40, 127, 71) or not AutoWin
                                        end
                                        break
                                    else
                                        local ClosestVents = GetClosestVents()
                                        local ClosestWindows = GetClosestWindows()
                                        local ClosestVent
                                        local ClosestWindow
                                        local VentMagnitude
                                        local WindowMagnitude
                                        for i, v in ipairs(ClosestVents) do
                                            local VentPos = (v.PrimaryPart or ClosestVents:FindFirstChildWhichIsA("BasePart")).Position
                                            if (BeastRoot.Position - VentPos).Magnitude > (BeastRoot.Position - Root.Position).Magnitude then
                                                ClosestVent = v
                                                VentMagnitude = (Root.Position - VentPos).Magnitude
                                            end
                                        end
                                        for i, v in ipairs(ClosestWindows) do
                                            local WindowPos = (v.PrimaryPart or ClosestWindows:FindFirstChildWhichIsA("BasePart")).Position
                                            if (BeastRoot.Position - WindowPos).Magnitude > (BeastRoot.Position - Root.Position).Magnitude then
                                                ClosestWindow = v
                                                WindowMagnitude = (Root.Position - WindowPos).Magnitude
                                            end
                                        end

                                        local ClosestResource = if WindowMagnitude < VentMagnitude then ClosestWindow else ClosestVent
                                        
                                        local Path = PathfindingService:CreatePath({
                                            AgentHeight = 1.8,
                                            AgentRadius = 2.1,
                                            AgentCanClimb = true,
                                        })
                                        Path:ComputeAsync(Root.Position, (ClosestResource.PrimaryPart or ClosestResource.WorldPivot).Position)
                                        if Path.Status == Enum.PathStatus.Success then
                                            local Waypoints = Path:GetWaypoints()
                                            for i, Waypoint in ipairs(Waypoints) do
                                                if not AutoWin then break end
                                                if ClosestResource.Name == "AirVent" or ClosestResource.Name == "Museum Vent" then
                                                    KeyPress(KeycodeMap.LeftShift)
                                                end
                                                if Waypoint.Action == Enum.PathWaypointAction.Jump then
                                                    Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                                                end
                                                Humanoid:MoveTo(Waypoint.Position)
                                                local ModdedRootPos = Vector3.new(Root.Position.X, 0, Root.Position.Z)
                                                local ModdedWaypointPos = Vector3.new(Waypoint.Position.X, 0, Waypoint.Position.Z)
                                                local Clock = os.clock()
                                                repeat
                                                    RunService.Heartbeat:Wait()
                                                    ModdedRootPos = Vector3.new(Root.Position.X, 0, Root.Position.Z)
                                                until ((ModdedRootPos - ModdedWaypointPos).Magnitude < 1) or (os.clock() - Clock > 5) or (not AutoWin) or ((Root.Position - BeastRoot.Position).Magnitude < 75)
                                                if ClosestResource.Name == "AirVent" or ClosestResource.Name == "Museum Vent" then
                                                    KeyRelease(KeycodeMap.LeftShift)
                                                end
                                                if not AutoWin then
                                                    break
                                                end
                                            end
                                        end
                                    end
                                end
                            else
                                local Exit = Map:FindFirstChild("ExitDoor")
                                if Exit then
                                    
                                end
                            end
                        end
                    end
                end
                if Connections.Other.SkillCheckConnection then
                    Connections.Other.SkillCheckConnection:Disconnect()
                    Connections.Other.SkillCheckConnection = nil
                end
            end)
        end,
    })

	Notify({
		Text = "<font color = 'rgb(0, 255, 0)'>Successfully</font> Loaded Flee The Facility Modules Have Fun (:"
	})
elseif IsStrongmanSimulator then -- Strongman Simulator
    StrongmanSimulatorCategory = CreateCategory({
        Name = "Strongman Simulator",
        Size = UDim2.fromScale(1, 0.5),
        Pos = UDim2.fromScale(0.77, 0),
        ClosedPos = UDim2.fromScale(0.45, 1),
    })
    Connections.StrongmanSimulator = {}
    local MasslessItems = {}

    ToggleWeightlessItems = StrongmanSimulatorCategory:CreateToggle({
        Text = "Weightless Items",
        Info = "Makes Items Weightless And Easy To Pull",
        MouseButton1Click = function(WeightlessItems)
            if WeightlessItems then
                local PlrDraggables = workspace.PlayerDraggables:FindFirstChild(Plr.UserId)
                if not PlrDraggables then return end
                Connections.StrongmanSimulator.WeightlessItemsLoop = PlrDraggables.ChildAdded:Connect(function(Child)
                    RunService.Heartbeat:Wait()
                    if Child:IsA("BasePart") then
                        Child.Massless = true
                        Child.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                    end
                    for i, v in ipairs(Child:GetChildren()) do
                        if v:IsA("BasePart") then
                            v.Massless = true
                            v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                            table.insert(MasslessItems, v)
                        end
                    end
                end)
            else
                if Connections.StrongmanSimulator.WeightlessItemsLoop then
                    Connections.StrongmanSimulator.WeightlessItemsLoop:Disconnect()
                    Connections.StrongmanSimulator.WeightlessItemsLoop = nil
                end

                local PlrDraggables = workspace.PlayerDraggables:FindFirstChild(Plr.UserId)
                if not PlrDraggables then return end

                for i, v in ipairs(MasslessItems) do
                    v.Massless = false
                end
                table.clear(MasslessItems)
            end
        end,
    })
    
    ToggleNoGamepassPopups = StrongmanSimulatorCategory:CreateToggle({
        Text = "No Gamepass Popups",
        Info = "Removes Gamepass/Product Popups In Strongman Simulator",
        MouseButton1Click = function(NoStrongmanSimulatorPopups)
            local Success, PopupScript = pcall(function()
                return Plr.PlayerGui.PopupPurchase.AdPopup
            end)
            if Success then
                PopupScript.Disabled = NoStrongmanSimulatorPopups
            end
        end,
    })

    ToggleInstantSellItems = StrongmanSimulatorCategory:CreateToggle({
        Text = "Instant Sell Items",
        Info = "Instantly Sells Items When You Grab Them",
        MouseButton1Click = function(InstantSellItems)
            if not FireTouchInterest then NotifyExploitDoesntSupportFunction("FireTouchInterest"); return end
            if InstantSellItems then
                local PlrDraggables = workspace.PlayerDraggables:FindFirstChild(Plr.UserId)
                if not PlrDraggables then return end
                Connections.StrongmanSimulator.InstantSellItems = PlrDraggables.ChildAdded:Connect(function(Child)
                    local Success, Goal = pcall(function()
                        return workspace.Areas.Area20_Princess.Goal
                    end)
                    if Child:IsA("BasePart") and Success then
                        FireTouchInterest(Goal, Child, 0)
                        FireTouchInterest(Goal, Child, 1)
                    end
                end)
            else
                if Connections.StrongmanSimulator.InstantSellItems then
                    Connections.StrongmanSimulator.InstantSellItems:Disconnect()
                    Connections.StrongmanSimulator.InstantSellItems = nil
                end
            end
        end,
    })

    Notify({
        Text = "<font color = 'rgb(0, 255, 0)'>Successfully</font> Loaded Strongman Simulator Modules Have Fun (:"
    })
elseif IsDeadByRoblox then -- Dead By Roblox
    WalkSpeedSlider:UpdateSlider(15)
    DeadByRobloxCategory = CreateCategory({
        Name = "Dead By Roblox",
        Size = UDim2.fromScale(1, 0.5),
        Pos = UDim2.fromScale(0.77, 0),
        ClosedPos = UDim2.fromScale(0.45, 1),
    })

    GeneratorEspMethod = "Highlight"
    WindowEspMethod = "Highlight"
    PalletEspMethod = "Highlight"

    PalletEspOutlineTransparency = 0
    PalletEspFillTransparency = 0.5
    WindowEspOutlineTransparency = 0
    WindowEspFillTransparency = 0.5
    GeneratorEspOutlineTransparency = 0
    GeneratorEspFillTransparency = 0.5

    PalletEspOutlineColor = Color3.fromRGB(255, 255, 0)
    PalletEspFillColor = Color3.fromRGB(255, 255, 0)
    WindowEspOutlineColor = Color3.fromRGB(255, 255, 0)
    WindowEspFillColor = Color3.fromRGB(255, 255, 0)
    GeneratorEspOutlineColor = Color3.fromRGB(255, 255, 0)
    GeneratorEspFillColor = Color3.fromRGB(255, 255, 0)
    
    local function ClearGeneratorESP()
        for i, v in ipairs(EspFolder:GetChildren()) do
            if v.Name:find("GeneratorESP_") or v.Name:find("GeneratorDrawingESP_") then
                v:Destroy()
            end
        end
        for i,  v in pairs(Connections.Visuals.GeneratorDrawingEspConnections) do
            v:Disconnect()
            v = nil
        end
    end

    local function UpdateGeneratorESP()
        for i, v in ipairs(EspFolder:GetChildren()) do
            if v.Name:find("GeneratorESP_") then
                v.OutlineColor = PalletEspOutlineColor
                v.FillColor = PalletEspFillColor
                v.OutlineTransparency = PalletEspOutlineTransparency
                v.FillTransparency = PalletEspFillTransparency
            elseif v.Name:find("GeneratorDrawingESP_") then
                v.BackgroundColor3 = PalletEspFillColor
                v.BackgroundTransparency = PalletEspFillTransparency
                v.UIStroke.Color = PalletEspOutlineColor
                v.UIStroke.Transparency = PalletEspOutlineTransparency
            end
        end
    end

    Connections.Visuals.GeneratorDrawingEspConnections = {}

    local function EspGenerators()
        if GeneratorEspMethod == "Highlight" or GeneratorEspMethod == "HighlightAndDrawing" then
            for i, v in ipairs(workspace:GetChildren()) do
                if v.Name:find("Generator") then
                    local Highlight = Instance.new("Highlight")
                    Highlight.Adornee = v
                    Highlight.OutlineColor = GeneratorEspOutlineColor
                    Highlight.FillColor = GeneratorEspFillColor
                    Highlight.OutlineTransparency = GeneratorEspOutlineTransparency
                    Highlight.FillTransparency = GeneratorEspFillTransparency
                    Highlight.Name = `GeneratorESP_{v.Name:sub(#v.Name, #v.Name)}`
                    Highlight.Parent = EspFolder
                end
            end
        end
        if GeneratorEspMethod == "Drawing" or GeneratorEspMethod == "HighlightAndDrawing" then
            for i, v in ipairs(workspace:GetChildren()) do
                if v.Name:find("Generator") then
                    local Frame = Instance.new("Frame")
                    Frame.BackgroundTransparency = 1
                    Frame.BorderSizePixel = 0
                    Frame.AnchorPoint = Vector2.new(0.5, 0.5)
                    Frame.Name = `GeneratorDrawingESP_{v.Name:sub(#v.Name, #v.Name)}`
                    Frame.Parent = EspFolder
                    local UIStroke = Instance.new("UIStroke")
                    UIStroke.Thickness = 1
                    UIStroke.Parent = Frame
                    Connections.Visuals.GeneratorDrawingEspConnections[`GeneratorDrawingESP_{v.Name:sub(#v.Name, #v.Name)}`] = RunService.RenderStepped:Connect(function()
                        local GeneratorRoot = GetRoot(v)
                        if not GeneratorRoot then return end
                        local Vector, OnScreen = Camera:WorldToViewportPoint(GeneratorRoot.Position)
                        if OnScreen then
                            Frame.Position = UDim2.fromOffset(Vector.X, Vector.Y)
                            Frame.Size = UDim2.fromOffset(1000 / Vector.Z, 1000 / Vector.Z)
                            Frame.BackgroundColor3 = GeneratorEspFillColor
                            Frame.BackgroundTransparency = GeneratorEspFillTransparency
                            UIStroke.Color = GeneratorEspOutlineColor
                            UIStroke.Transparency = GeneratorEspOutlineTransparency
                            Frame.Visible = true
                        else
                            Frame.Visible = false
                        end
                    end)
                end
            end
        end
    end

    ToggleGeneratorESP = DeadByRobloxCategory:CreateToggle({
        Text = "Generator ESP",
        MouseButton1Click = function(GeneratorESP)
            ClearGeneratorESP()
            if not GeneratorESP then return end
            EspGenerators()
        end,
    })

    ToggleGeneratorESP:CreateColorPicker({
        Text = "Outline Color",
        Default = GeneratorEspOutlineColor,
        Function = function(Color)
            GeneratorEspOutlineColor = Color
            UpdateGeneratorESP()
        end,
    })

    ToggleGeneratorESP:CreateColorPicker({
        Text = "Fill Color",
        Default = GeneratorEspFillColor,
        Function = function(Color)
            GeneratorEspFillColor = Color
            UpdateGeneratorESP()
        end,
    })

    local GeneratorEspMethodDropdown = ToggleGeneratorESP:CreateDropdown({
        Text = "Method",
        Default = "None",
    })
    GeneratorEspMethodDropdown:CreateButton({
        Text = "Highlight",
        MouseButton1Click = function()
            GeneratorEspMethod = "Highlight"
            ClearGeneratorESP()
            EspGenerators()
        end,
    })
    GeneratorEspMethodDropdown:CreateButton({
        Text = "Drawing",
        MouseButton1Click = function()
            GeneratorEspMethod = "Drawing"
            ClearGeneratorESP()
            EspGenerators()
        end,
    })
    GeneratorEspMethodDropdown:CreateButton({
        Text = "Highlight And Drawing",
        MouseButton1Click = function()
            GeneratorEspMethod = "HighlightAndDrawing"
            ClearGeneratorESP()
            EspGenerators()
        end,
    })

    ToggleGeneratorESP:CreateSlider({
        Text = "Outline Transparency",
        Default = GeneratorEspOutlineTransparency,
        Min = 0,
        Max = 1,
        Function = function(Val)
            GeneratorEspOutlineTransparency = Val
            UpdateGeneratorESP()
        end,
        Function2 = function(Val)
            GeneratorEspOutlineTransparency = Val
            UpdateGeneratorESP()
        end,
    })

    ToggleGeneratorESP:CreateSlider({
        Text = "Fill Transparency",
        Default = GeneratorEspFillTransparency,
        Min = 0,
        Max = 1,
        Function = function(Val)
            GeneratorEspFillTransparency = Val
            UpdateGeneratorESP()
        end,
        Function2 = function(Val)
            GeneratorEspFillTransparency = Val
            UpdateGeneratorESP()
        end,
    })
    
    local function ClearWindowESP()
        for i, v in ipairs(EspFolder:GetChildren()) do
            if v.Name:find("WindowESP_") or v.Name:find("WindowDrawingESP_") then
                v:Destroy()
            end
        end
        
        for i,  v in pairs(Connections.Visuals.WindowDrawingEspConnections) do
            v:Disconnect()
            v = nil
        end
    end

    local function UpdateWindowESP()
        for i, v in ipairs(EspFolder:GetChildren()) do
            if v.Name:find("WindowESP_") then
                v.OutlineColor = PalletEspOutlineColor
                v.FillColor = PalletEspFillColor
                v.OutlineTransparency = PalletEspOutlineTransparency
                v.FillTransparency = PalletEspFillTransparency
            elseif v.Name:find("WindowDrawingESP_") then
                v.BackgroundColor3 = PalletEspFillColor
                v.BackgroundTransparency = PalletEspFillTransparency
                v.UIStroke.Color = PalletEspOutlineColor
                v.UIStroke.Transparency = PalletEspOutlineTransparency
            end
        end
    end

    Connections.Visuals.WindowDrawingEspConnections = {}

    local function EspWindows()
        if WindowEspMethod == "Highlight" or WindowEspMethod == "HighlightAndDrawing" then
            for i, v in ipairs(workspace:GetChildren()) do
                if v.Name:find("Window") then
                    local Highlight = Instance.new("Highlight")
                    Highlight.Adornee = v
                    Highlight.OutlineColor = WindowEspOutlineColor
                    Highlight.FillColor = WindowEspFillColor
                    Highlight.OutlineTransparency = WindowEspOutlineTransparency
                    Highlight.FillTransparency = WindowEspFillTransparency
                    Highlight.Name = `WindowESP_{v.Name:sub(7, #v.Name)}`
                    Highlight.Parent = EspFolder
                end
            end
        end
        if WindowEspMethod == "Drawing" or WindowEspMethod == "HighlightAndDrawing" then
            for i, v in ipairs(workspace:GetChildren()) do
                if v.Name:find("Window") then
                    local Frame = Instance.new("Frame")
                    Frame.BackgroundTransparency = 1
                    Frame.BorderSizePixel = 0
                    Frame.AnchorPoint = Vector2.new(0.5, 0.5)
                    Frame.Name = `WindowDrawingESP_{v.Name:sub(7, #v.Name)}`
                    Frame.Parent = EspFolder
                    local UIStroke = Instance.new("UIStroke")
                    UIStroke.Thickness = 1
                    UIStroke.Parent = Frame
                    Connections.Visuals.WindowDrawingEspConnections[`WindowDrawingESP_{v.Name:sub(7, #v.Name)}`] = RunService.RenderStepped:Connect(function()
                        local WindowRoot = GetRoot(v)
                        if not WindowRoot then return end
                        local Vector, OnScreen = Camera:WorldToViewportPoint(WindowRoot.Position)
                        if OnScreen then
                            Frame.Position = UDim2.fromOffset(Vector.X, Vector.Y)
                            Frame.Size = UDim2.fromOffset(1000 / Vector.Z, 1000 / Vector.Z)
                            Frame.BackgroundColor3 = WindowEspFillColor
                            Frame.BackgroundTransparency = WindowEspFillTransparency
                            UIStroke.Color = WindowEspOutlineColor
                            UIStroke.Transparency = WindowEspOutlineTransparency
                            Frame.Visible = true
                        else
                            Frame.Visible = false
                        end
                    end)
                end
            end
        end
    end

    ToggleWindowESP = DeadByRobloxCategory:CreateToggle({
        Text = "Window ESP",
        MouseButton1Click = function(WindowESP)
            ClearWindowESP()
            if not WindowESP then return end
            EspWindows()
        end,
    })

    ToggleWindowESP:CreateColorPicker({
        Text = "Outline Color",
        Default = WindowEspOutlineColor,
        Function = function(Color)
            WindowEspOutlineColor = Color
            UpdateWindowESP()
        end,
    })

    ToggleWindowESP:CreateColorPicker({
        Text = "Fill Color",
        Default = WindowEspFillColor,
        Function = function(Color)
            WindowEspFillColor = Color
            UpdateWindowESP()
        end,
    })

    ToggleWindowESP:CreateSlider({
        Text = "Outline Transparency",
        Default = WindowEspOutlineTransparency,
        Min = 0,
        Max = 1,
        Function = function(Val)
            WindowEspOutlineTransparency = Val
            UpdateWindowESP()
        end,
        Function2 = function(Val)
            WindowEspOutlineTransparency = Val
            UpdateWindowESP()
        end,
    })

    ToggleWindowESP:CreateSlider({
        Text = "Fill Transparency",
        Default = WindowEspFillTransparency,
        Min = 0,
        Max = 1,
        Function = function(Val)
            WindowEspFillTransparency = Val
            UpdateWindowESP()
        end,
        Function2 = function(Val)
            WindowEspFillTransparency = Val
            UpdateWindowESP()
        end,
    })

    local WindowEspMethodDropdown = ToggleWindowESP:CreateDropdown({
        Text = "Window ESP Method",
        Default = "None",
    })
    WindowEspMethodDropdown:CreateButton({
        Text = "Highlight",
        MouseButton1Click = function()
            WindowEspMethod = "Highlight"
            ClearWindowESP()
            EspWindows()
        end,
    })
    WindowEspMethodDropdown:CreateButton({
        Text = "Drawing",
        MouseButton1Click = function()
            WindowEspMethod = "Drawing"
            ClearWindowESP()
            EspWindows()
        end,
    })
    WindowEspMethodDropdown:CreateButton({
        Text = "Highlight And Drawing",
        MouseButton1Click = function()
            WindowEspMethod = "HighlightAndDrawing"
            ClearWindowESP()
            EspWindows()
        end,
    })

    local function ClearPalletESP()
        for i, v in ipairs(EspFolder:GetChildren()) do
            if v.Name:find("PalletESP_") or v.Name:find("PalletDrawingESP_") then
                v:Destroy()
            end
        end
        
        for i,  v in pairs(Connections.Visuals.PalletDrawingEspConnections) do
            v:Disconnect()
            v = nil
        end
    end

    local function UpdatePalletESP()
        for i, v in ipairs(EspFolder:GetChildren()) do
            if v.Name:find("PalletESP_") then
                v.OutlineColor = PalletEspOutlineColor
                v.FillColor = PalletEspFillColor
                v.OutlineTransparency = PalletEspOutlineTransparency
                v.FillTransparency = PalletEspFillTransparency
            elseif v.Name:find("PalletDrawingESP_") then
                v.BackgroundColor3 = PalletEspFillColor
                v.BackgroundTransparency = PalletEspFillTransparency
                v.UIStroke.Color = PalletEspOutlineColor
                v.UIStroke.Transparency = PalletEspOutlineTransparency
            end
        end
    end

    Connections.Visuals.PalletDrawingEspConnections = {}

    local function EspPallets()
        if PalletEspMethod == "Highlight" or PalletEspMethod == "HighlightAndDrawing" then
            for i, v in ipairs(workspace:GetChildren()) do
                if v.Name:find("Pallet") then
                    local Highlight = Instance.new("Highlight")
                    Highlight.Adornee = v
                    Highlight.OutlineColor = PalletEspOutlineColor
                    Highlight.FillColor = PalletEspFillColor
                    Highlight.OutlineTransparency = PalletEspOutlineTransparency
                    Highlight.FillTransparency = PalletEspFillTransparency
                    Highlight.Name = `PalletESP_{v.Name:sub(7, #v.Name)}`
                    Highlight.Parent = EspFolder
                end
            end
        end
        if PalletEspMethod == "Drawing" or PalletEspMethod == "HighlightAndDrawing" then
            for i, v in ipairs(workspace:GetChildren()) do
                if v.Name:find("Pallet") then
                    local Frame = Instance.new("Frame")
                    Frame.BackgroundTransparency = 1
                    Frame.BorderSizePixel = 0
                    Frame.AnchorPoint = Vector2.new(0.5, 0.5)
                    Frame.Name = `PalletDrawingESP_{v.Name:sub(7, #v.Name)}`
                    Frame.Parent = EspFolder
                    local UIStroke = Instance.new("UIStroke")
                    UIStroke.Thickness = 1
                    UIStroke.Parent = Frame
                    Connections.Visuals.PalletDrawingEspConnections[`PalletDrawingESP_{v.Name:sub(7, #v.Name)}`] = RunService.RenderStepped:Connect(function()
                        local PalletRoot = GetRoot(v)
                        if not PalletRoot then return end
                        local Vector, OnScreen = Camera:WorldToViewportPoint(PalletRoot.Position)
                        if OnScreen then
                            Frame.Position = UDim2.fromOffset(Vector.X, Vector.Y)
                            Frame.Size = UDim2.fromOffset(1000 / Vector.Z, 1000 / Vector.Z)
                            Frame.BackgroundColor3 = PalletEspFillColor
                            Frame.BackgroundTransparency = PalletEspFillTransparency
                            UIStroke.Color = PalletEspOutlineColor
                            UIStroke.Transparency = PalletEspOutlineTransparency
                            Frame.Visible = true
                        else
                            Frame.Visible = false
                        end
                    end)
                end
            end
        end
    end

    TogglePalletESP = DeadByRobloxCategory:CreateToggle({
        Text = "Pallet ESP",
        MouseButton1Click = function(PalletESP)
            ClearPalletESP()
            if not PalletESP then return end
            EspPallets()
        end,
    })

    TogglePalletESP:CreateColorPicker({
        Text = "Outline Color",
        Default = PalletEspOutlineColor,
        Function = function(Color)
            PalletEspOutlineColor = Color
            UpdatePalletESP()
        end,
    })

    TogglePalletESP:CreateColorPicker({
        Text = "Fill Color",
        Default = PalletEspFillColor,
        Function = function(Color)
            PalletEspFillColor = Color
            UpdatePalletESP()
        end,
    })

    TogglePalletESP:CreateSlider({
        Text = "Outline Transparency",
        Default = PalletEspOutlineTransparency,
        Min = 0,
        Max = 1,
        Function = function(Val)
            PalletEspOutlineTransparency = Val
            UpdatePalletESP()
        end,
        Function2 = function(Val)
            PalletEspOutlineTransparency = Val
            UpdatePalletESP()
        end,
    })

    TogglePalletESP:CreateSlider({
        Text = "Fill Transparency",
        Default = PalletEspFillTransparency,
        Min = 0,
        Max = 1,
        Function = function(Val)
            PalletEspFillTransparency = Val
            UpdatePalletESP()
        end,
        Function2 = function(Val)
            PalletEspFillTransparency = Val
            UpdatePalletESP()
        end,
    })

    local ToggleInstantWiggle

    local function OnHeld()
        local Success, Held = pcall(function()
            return Plr:FindFirstChildWhichIsA("Backpack").Scripts.values.Holded
        end)
        if Success and Held.Value then
            local Killer
            for i, Player in ipairs(Players:GetPlayers()) do
                local Success2, IsKiller = pcall(function()
                    return Player.Backpack.Scripts.Killer
                end)
                if Success2 and IsKiller.Value then
                    Killer = Player
                end
            end
            Notify({
                Text = "Decisive Strike Has Been Activated!",
                Duration = 2,
            })
            while Held.Value and ToggleInstantWiggle.Enabled do
                for i = 1, 10 do
                    ReplicatedStorage.RemoteEvents.Server_Event:FireServer("Wiggle", Killer)
                end
                task.wait()
            end
        end
    end
    
    ToggleInstantWiggle = DeadByRobloxCategory:CreateToggle({
        Text = "Infinite Decisive Strike",
        Info = "When the killer picks you up you will instantly escape their grasp (doesn't require the perk).",
        MouseButton1Click = function(InstantWiggle)
            if InstantWiggle then
                local Success, Held = pcall(function()
                    return Plr:FindFirstChildWhichIsA("Backpack").Scripts.values.Holded
                end)
                Connections.Other.InstantWiggle = Success and Held:GetPropertyChangedSignal("Value"):Connect(OnHeld)
                OnHeld()
            else
                if Connections.Other.InstantWiggle then
                    Connections.Other.InstantWiggle:Disconnect()
                    Connections.Other.InstantWiggle = nil
                end
            end
        end,
    })

	Connections.World.AntiTrapConnections = {}
	local function EnableTrap(Trap, Bool)
		if Trap.Name:sub(1, 4) ~= "Trap" then return end
		local Hitbox = Trap:FindFirstChild("Hitbox")
		if Hitbox and Hitbox:IsA("BasePart") then
			Hitbox.CanTouch = Bool
			if Bool == false then
				Connections.World.AntiTrapConnections[Trap.Name] = Hitbox:GetPropertyChangedSignal("CanTouch"):Connect(function()
					Hitbox.CanTouch = Bool
				end)
			end
		end
	end

	ToggleAntiTrap = DeadByRobloxCategory:CreateToggle({
		Text = "Anti Trap",
		Info = "Turns off collision of all the trapper's traps making his ability completely useless.",
		MouseButton1Click = function(AntiTrap)
			if AntiTrap then
				for i, v in ipairs(workspace:GetChildren()) do
					EnableTrap(v, false)
				end
				Connections.World.AntiTrapConnections.AntiTrapChildAdded = workspace.ChildAdded:Connect(function(Child)
					if Child.Name:sub(1, 4) ~= "Trap" then return end
					if Child:WaitForChild("Hitbox", 5) then
                        EnableTrap(Child, false)
                    end
				end)
			else
				for i, v in pairs(Connections.World.AntiTrapConnections) do
					v:Disconnect()
                    v = nil
				end
				for i, v in ipairs(workspace:GetChildren()) do
					EnableTrap(v, true)
				end
			end
		end,
	})

    local ToggleUseDeadHardWhenDowned

    ToggleAutoDeadHard = DeadByRobloxCategory:CreateToggle({
        Text = "Auto Dead Hard",
        Info = "Automatically uses dead hard when you get hit (requires the perk).",
        MouseButton1Click = function(AutoDeadHard)
            if AutoDeadHard then
                if ToggleUseDeadHardWhenDowned.Enabled then
                    local Char = GetChar(Plr)
                    Connections.Player.AutoDeadHardConnection = Char and Char:GetAttributeChangedSignal("Blood"):Connect(function()
                        ReplicatedStorage.RemoteEvents.Perk_Event:FireServer("Dodge")
                    end)
                else
                    local Success, HealthState = pcall(function()
                        return Plr:FindFirstChildWhichIsA("Backpack").Scripts.values.HealthState
                    end)
                    Connections.Player.AutoDeadHardConnection = Success and HealthState:GetPropertyChangedSignal("Value"):Connect(function()
                        if HealthState.Value == 0 then
                            ReplicatedStorage.RemoteEvents.Perk_Event:FireServer("Dodge")
                        end
                    end)
                end
            else
                if Connections.Player.AutoDeadHardConnection then
                    Connections.Player.AutoDeadHardConnection:Disconnect()
                    Connections.Player.AutoDeadHardConnection = nil
                end
            end
        end,
    })
    
    ToggleUseDeadHardWhenDowned = ToggleAutoDeadHard:CreateToggle({
        Text = "Use When Downed",
        Info = "Uses dead hard even while you're downed. If dead hard gets used while you're downed you will instantly recover from the dying state.",
        MouseButton1Click = function(UseDeadHardWhenDowned)
            if ToggleAutoDeadHard.Enabled then
                if Connections.Player.AutoDeadHardConnection then
                    Connections.Player.AutoDeadHardConnection:Disconnect()
                    Connections.Player.AutoDeadHardConnection = nil
                end
                if UseDeadHardWhenDowned then
                    local Char = GetChar(Plr)
                    Connections.Player.AutoDeadHardConnection = Char and Char:GetAttributeChangedSignal("Blood"):Connect(function()
                        ReplicatedStorage.RemoteEvents.Perk_Event:FireServer("Dodge")
                    end)
                else
                    local Success, HealthState = pcall(function()
                        return Plr:FindFirstChildWhichIsA("Backpack").Scripts.values.HealthState
                    end)
                    Connections.Player.AutoDeadHardConnection = Success and HealthState:GetPropertyChangedSignal("Value"):Connect(function()
                        if HealthState.Value == 0 then
                            ReplicatedStorage.RemoteEvents.Perk_Event:FireServer("Dodge")
                        end
                    end)
                end
            end
        end,
    })

    local ToggleInfiniteUnbreakable; ToggleInfiniteUnbreakable = DeadByRobloxCategory:CreateToggle({
        Text = "Infinite Unbreakable",
        Info = "Allows you to fully recover from the dying state without having unbreakable.",
        MouseButton1Click = function(InfiniteUnbreakable)
            if InfiniteUnbreakable then
                local Success, Recovering = pcall(function()
                    return Plr:FindFirstChildWhichIsA("Backpack").Scripts.values.Recovering
                end)
                Connections.Player.InfiniteUnbreakableConnection = Success and Recovering:GetPropertyChangedSignal("Value"):Connect(function()
                    if Recovering.Value then
                        ReplicatedStorage.RemoteEvents.ClientToServer.HealingEvent:FireServer(Plr.Name, "Start", {
                            IsMending = false,
                            SelfHealing = true,
                            RestrictValues = false,
                            SumKeys = {
                                "SelfCare"
                            },
                        })
                        local Success, HealProgress, Progress_Info, ProgressBar, ActionText = pcall(function()
                            local PlayerGui = Plr:FindFirstChildWhichIsA("PlayerGui")
                            return Plr:FindFirstChildWhichIsA("Backpack").Scripts.values.HealProgress, PlayerGui.HUD.Controls_Display.Progress_Info, PlayerGui.HUD.Controls_Display.Progress_Info.Progress_Holder.Progress.Bar, PlayerGui.HUD.Controls_Display.Progress_Info.ActionText
                        end)
                        while UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
                            if ToggleInfiniteUnbreakable.Disabled or not Connections.Player.InfiniteUnbreakableConnection then break end
                            RunService.RenderStepped:Wait()
                            if Success then
                                Progress_Info.Visible = true
                                ActionText.Text = "Recovering"
                                ProgressBar.Size = UDim2.fromScale(HealProgress.Value / 1000, 1)
                            end
                        end
                        Progress_Info.Visible = false
                        ReplicatedStorage.RemoteEvents.ClientToServer.HealingEvent:FireServer(Plr.Name, "Stop")
                    end 
                end)
            else
                if Connections.Player.InfiniteUnbreakableConnection then
                    Connections.Player.InfiniteUnbreakableConnection:Disconnect()
                    Connections.Player.InfiniteUnbreakableConnection = nil
                    ReplicatedStorage.RemoteEvents.ClientToServer.HealingEvent:FireServer(Plr.Name, "Stop")
                end
            end
        end,
    })

    local SelfCareAnimation
    local LoadedSelfCareAnimation

    local ToggleSelfCare; ToggleSelfCare = DeadByRobloxCategory:CreateToggle({
        Text = "Self Care",
        Info = "Allows you to self care without having self care. If you fully heal yourself while you're healthy, you become invincible until you get grabbed from a locker. Click while holding left control to heal.",
        MouseButton1Click = function(SelfCare)
            if SelfCare then
                Connections.Player.SelfCareConnection = UIS.InputBegan:Connect(function(Input, Proc)
                    if Proc then return end
                    if UIS:IsKeyDown(Enum.KeyCode.LeftControl) and Input.UserInputType == Enum.UserInputType.MouseButton1 then
                        ReplicatedStorage.RemoteEvents.ClientToServer.HealingEvent:FireServer(Plr.Name, "Start", {
                            IsMending = false,
                            SelfHealing = true,
                            RestrictValues = false,
                        })
                        local Success, HealProgress, Progress_Info, ProgressBar, ActionText = pcall(function()
                            local Backpack = Plr:FindFirstChildWhichIsA("Backpack")
                            local PlayerGui = Plr:FindFirstChildWhichIsA("PlayerGui")
                            return Backpack.Scripts.values.HealProgress, PlayerGui.HUD.Controls_Display.Progress_Info, PlayerGui.HUD.Controls_Display.Progress_Info.Progress_Holder.Progress.Bar, PlayerGui.HUD.Controls_Display.Progress_Info.ActionText
                        end)
                        SelfCareAnimation = Instance.new("Animation")
                        SelfCareAnimation.AnimationId = "rbxassetid://102741425499863"
                        local Char = GetChar(Plr)
                        local Humanoid = GetHumanoid(Char)
                        if Char and Humanoid then
                            LoadedSelfCareAnimation = Humanoid:LoadAnimation(SelfCareAnimation)
                            LoadedSelfCareAnimation.Priority = Enum.AnimationPriority.Action4
                            LoadedSelfCareAnimation.Looped = true
                            LoadedSelfCareAnimation:Play()
                        end
                        while UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
                            if not ToggleSelfCare.Boolean or not Connections.Player.SelfCareConnection then break end
                            RunService.RenderStepped:Wait()
                            if Success then
                                Progress_Info.Visible = true
                                ActionText.Text = "Healing"
                                ProgressBar.Size = UDim2.fromScale(HealProgress.Value / 1000, 1)
                            end
                        end
                        if SelfCareAnimation then
                            SelfCareAnimation:Destroy()
                            SelfCareAnimation = nil
                        end
                        if LoadedSelfCareAnimation then
                            LoadedSelfCareAnimation:Stop()
                            LoadedSelfCareAnimation:Destroy()
                            LoadedSelfCareAnimation = nil
                        end
                        Progress_Info.Visible = false
                        ReplicatedStorage.RemoteEvents.ClientToServer.HealingEvent:FireServer(Plr.Name, "Stop")
                    end
                end)
            else
                if Connections.Player.SelfCareConnection then
                    Connections.Player.SelfCareConnection:Disconnect()
                    Connections.Player.SelfCareConnection = nil
                end
            end
        end,
    })

    DeadByRobloxCategory:CreateToggle({
        Text = "Infinite Nurse Blinks",
        Info = "It like gives you infinte nurse blinks probably.",
        MouseButton1Click = function(InfiniteNurseBlinks)
            local Success, PowerRemote = pcall(function()
                return GetChar(Plr).Blink.PowerValues.PowerRemote
            end)
            if Success then
                PowerRemote:FireServer("SetValue", "Blinks", if InfiniteNurseBlinks then 69420 else 2)
            end
        end,
    })

    local LungeDuration = 0.5

    local ToggleLungeDuration

    local function UpdateLungeDuration()
        local PlayerValues = Plr:FindFirstChild("PlayerValues")
        if PlayerValues and ToggleLungeDuration.Enabled then
            PlayerValues:SetAttribute("LungeDuration", LungeDuration)
        end 
    end

    ToggleLungeDuration = DeadByRobloxCategory:CreateToggle({
        Text = "Lunge Duration",
        Info = `The duration of your lunge. Default lunge duration is {LungeDuration}.`,
        MouseButton1Click = function(Enabled)
            if Enabled then
                local PlayerValues = Plr:FindFirstChild("PlayerValues")
                if PlayerValues then
                    UpdateLungeDuration()
                    Connections.Movement.LungeDurationChanged = PlayerValues:GetAttributeChangedSignal("LungeDuration"):Connect(UpdateLungeDuration)
                end
            else
                if Connections.Movement.LungeDurationChanged then
                    Connections.Movement.LungeDurationChanged:Disconnect()
                    Connections.Movement.LungeDurationChanged = nil
                end
            end
        end,
    })

    ToggleLungeDuration:CreateSlider({
        Text = "Lunge Duration",
        Default = LungeDuration,
        Min = 0,
        Max = 100,
        Function = function(Val)
            LungeDuration = Val
            UpdateLungeDuration()
        end,
        Function2 = function(Val)
            LungeDuration = Val
            UpdateLungeDuration()
        end,
    })

    local LungeSpeed = 30

    local ToggleLungeSpeed

    local function UpdateLungeSpeed()
        local PlayerValues = Plr:FindFirstChild("PlayerValues")
        if PlayerValues and ToggleLungeSpeed.Enabled then
            PlayerValues:SetAttribute("LungeSpeed", LungeSpeed)
        end
    end

    ToggleLungeSpeed = DeadByRobloxCategory:CreateToggle({
        Text = "Lunge Speed",
        Info = `The speed you move at when lunging. Default lunge speed is {LungeSpeed}`,
        MouseButton1Click = function(Enabled)
            if Enabled then
                local PlayerValues = Plr:FindFirstChild("PlayerValues")
                if PlayerValues then
                    UpdateLungeSpeed()
                    Connections.Movement.LungeSpeedChanged = PlayerValues:GetAttributeChangedSignal("LungeSpeed"):Connect(UpdateLungeSpeed)
                end
            else
                if Connections.Movement.LungeSpeedChanged then
                    Connections.Movement.LungeSpeedChanged:Disconnect()
                    Connections.Movement.LungeSpeedChanged = nil
                end
            end
        end,
    })

    ToggleLungeSpeed:CreateSlider({
        Text = "Lunge Speed",
        Default = LungeSpeed,
        Min = 0,
        Max = 100,
        Function = function(Val)
            LungeSpeed = Val
            UpdateLungeSpeed()
        end,
        Function2 = function(Val)
            LungeSpeed = Val
            UpdateLungeSpeed()
        end,
    })

    local MissCooldown = 1.5

    local ToggleMissCooldown

    local function UpdateMissCooldown()
        local PlayerValues = Plr:FindFirstChild("PlayerValues")
        if PlayerValues and ToggleMissCooldown.Enabled then
            PlayerValues:SetAttribute("MissCooldown", MissCooldown)
        end
    end

    ToggleMissCooldown = DeadByRobloxCategory:CreateToggle({
        Text = "Miss Cooldown",
        Info = `The cooldown duration when you miss a hit. Default miss cooldown is {MissCooldown}`,
        MouseButton1Click = function(Enabled)
            if Enabled then
                local PlayerValues = Plr:FindFirstChild("PlayerValues")
                if PlayerValues then
                    UpdateMissCooldown()
                    Connections.Movement.MissCooldownChanged = PlayerValues:GetAttributeChangedSignal("MissCooldown"):Connect(UpdateMissCooldown)
                end
            else
                if Connections.Movement.MissCooldownChanged then
                    Connections.Movement.MissCooldownChanged:Disconnect()
                    Connections.Movement.MissCooldownChanged = nil
                end
            end
        end,
    })

    ToggleMissCooldown:CreateSlider({
        Text = "Miss Cooldown",
        Default = MissCooldown,
        Min = 0,
        Max = 10,
        Function = function(Val)
            MissCooldown = Val
            UpdateMissCooldown()
        end,
        Function2 = function(Val)
            MissCooldown = Val
            UpdateMissCooldown()
        end,
    })

    local WindowVaultSpeed = 1.65

    local ToggleWindowVaultSpeed

    local function UpdateWindowVaultSpeed()
        local PlayerValues = Plr:FindFirstChild("PlayerValues")
        if not PlayerValues then return end
        if ToggleWindowVaultSpeed.Enabled then
            PlayerValues:SetAttribute("WindowVaultSpeed", WindowVaultSpeed)
        end
    end

    ToggleWindowVaultSpeed = DeadByRobloxCategory:CreateToggle({
        Text = "Window Vault Speed",
        Info = `The speed at which you vault windows. Default is 1.65 for killer and 1 for survivor.`,
        MouseButton1Click = function(Enabled)
            if Enabled then
                local PlayerValues = Plr:FindFirstChild("PlayerValues")
                if not PlayerValues then return end
                UpdateWindowVaultSpeed()
                Connections.Player.WindowVaultSpeedChanged = PlayerValues:GetAttributeChangedSignal("WindowVaultSpeed"):Connect(UpdateWindowVaultSpeed)
            else
                if Connections.Player.WindowVaultSpeedChanged then
                    Connections.Player.WindowVaultSpeedChanged:Disconnect()
                    Connections.Player.WindowVaultSpeedChanged = nil
                end
            end
        end,
    })

    ToggleWindowVaultSpeed:CreateSlider({
        Text = "Window Vault Speed",
        Default = WindowVaultSpeed,
        Min = 0,
        Max = 10,
        Function = function(Val)
            WindowVaultSpeed = Val
            UpdateWindowVaultSpeed()
        end,
        Function2 = function(Val)
            WindowVaultSpeed = Val
            UpdateWindowVaultSpeed()
        end,
    })

    local WipeSpeed = 1

    local ToggleWipeSpeed

    local function UpdateWipeSpeed()
        local PlayerValues = Plr:FindFirstChild("PlayerValues")
        if not PlayerValues then return end
        if ToggleWipeSpeed.Enabled then
            PlayerValues:SetAttribute("WipeSpeed", WipeSpeed)
        end
    end

    ToggleWipeSpeed = DeadByRobloxCategory:CreateToggle({
        Text = "Wipe Speed",
        Info = `The speed at which you wipe your weapon after hitting someone. Default is {WipeSpeed}`,
        MouseButton1Click = function(Enabled)
            if Enabled then
                local PlayerValues = Plr:FindFirstChild("PlayerValues")
                if not PlayerValues then return end
                UpdateWipeSpeed()
                Connections.Player.WipeSpeedChanged = PlayerValues:GetAttributeChangedSignal("WipeSpeed"):Connect(UpdateWipeSpeed)
            else
                if Connections.Player.WipeSpeedChanged then
                    Connections.Player.WipeSpeedChanged:Disconnect()
                    Connections.Player.WipeSpeedChanged = nil
                end
            end
        end,
    })

    ToggleWipeSpeed:CreateSlider({
        Text = "Wipe Speed",
        Default = WipeSpeed,
        Min = 0,
        Max = 10,
        Function = function(Val)
            WipeSpeed = Val
            UpdateWipeSpeed()
        end,
        Function2 = function(Val)
            WipeSpeed = Val
            UpdateWipeSpeed()
        end,
    })

    DeadByRobloxCategory:CreateButton({
        Text = "Destroy All Pallets",
        MouseButton1Click = function()
            for i, v in ipairs(workspace:GetChildren()) do
                if v.Name:find("Pallet") then
                    ReplicatedStorage.RemoteEvents.Server_Event:FireServer("Pallet", "Killer_Kick", v)
                end
            end
        end,
    })

    DeadByRobloxCategory:CreateButton({
        Text = "Destroy All Walls",
        MouseButton1Click = function()
            for i, v in ipairs(workspace:GetChildren()) do
                if v.Name:find("BreakableWall") then
                    ReplicatedStorage.RemoteEvents.Server_Event:FireServer("Wall", "Killer_Kick", v)
                end
            end
        end,
    })

    DeadByRobloxCategory:CreateButton({
        Text = "Kick All Generators",
        MouseButton1Click = function()
            for i, v in ipairs(workspace:GetChildren()) do
                if v.Name:find("Generator") then
                    ReplicatedStorage.RemoteEvents.Server_Event:FireServer("Generator", "Killer_Kick", v, v.Workspots.Front)
                end
            end
        end,
    })

    DeadByRobloxCategory:CreateButton({
        Text = "Sacrifice All Survivors",
        MouseButton1Click = function()
            for i, Player in ipairs(Players:GetPlayers()) do
                local Hook = workspace:FindFirstChild(`Hook{i}`)
                local Char = GetChar(Player)
                ReplicatedStorage.RemoteEvents.Server_Event:FireServer("Hook", "Hook", Char, Hook)
                task.wait()
                ReplicatedStorage.RemoteEvents.Server_Event:FireServer("Hook", "Hook", Char, Hook)
                task.wait()
                ReplicatedStorage.RemoteEvents.Server_Event:FireServer("Hook", "Hook", Char, Hook)
                task.wait()
            end
        end,
    })

    DeadByRobloxCategory:CreateButton({
        Text = "Escape From Hatch",
        MouseButton1Click = function()
            ReplicatedStorage.RemoteEvents.HatchAction:FireServer("Use")
        end,
    })

    DeadByRobloxCategory:CreateButton({
        Text = "Close Hatch",
        MouseButton1Click = function()
            ReplicatedStorage.RemoteEvents.HatchAction:FireServer("Start_Close")
        end,
    })


    --[[ random dead by roblox remotes
        ---------- Pallet Break With Hillbilly Chainsaw ----------

        local args = {
        	"Chainsaw",
        	"Hit_Object",
        	Pallet
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Server_Event"):FireServer(unpack(args))

        ---------- Hit Player With Hillbilly Chainsaw ----------

        local args = {
            "Chainsaw",
            "Hit_Object",
            Player.Character
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Server_Event"):FireServer(unpack(args))
        task.wait()
        local args = {
            "Chainsaw",
            "Finished_Saw"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Server_Event"):FireServer(unpack(args))

        ---------- Pick Up Player (Works With Survivor) ----------

        local args = {
            "Carry",
            "Pickup_Default",
            Player,
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Server_Event"):FireServer(unpack(args))

        ----------

        rbxassetid://10258272240 -- shake it animation id
        game:GetService("ReplicatedStorage").Modules.Data.Codes -- codes module that shows all the currently working codes

        local args = {
            "Hook",
            "Hook",
            game:GetService("Players"):WaitForChild("Papus19kaka").Character,
            workspace:WaitForChild("Hook19")
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Server_Event"):FireServer(unpack(args))

        local args = {
            "Start_Close"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("HatchAction"):FireServer(unpack(args))

        local args = {
            "Pallet",
            "Killer_Kick",
            workspace:WaitForChild("Pallet26")
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Server_Event"):FireServer(unpack(args))

        local Hook = workspace.Hook5
        
        local args = {
            {
                D9v8 = {
                    C21 = game:GetService("Players").LocalPlayer:WaitForChild("Backpack"):WaitForChild("Scripts"):WaitForChild("values"):WaitForChild("Action"),
                    C20 = "Sabotaging",
                    C22 = "S101"
                },
                Bbh1O = {
                    C21 = game:GetService("Players").LocalPlayer:WaitForChild("Backpack"):WaitForChild("Scripts"):WaitForChild("values"):WaitForChild("Action"),
                    C20 = "Sabotaging",
                    C22 = "S101"
                },
                Dvh1O = {
                    C21 = game:GetService("Players").LocalPlayer:WaitForChild("Backpack"):WaitForChild("Scripts"):WaitForChild("values"):WaitForChild("Action"),
                    C20 = "Sabotaging",
                    C22 = "S101"
                },
                Dbh1O = {
                    C21 = game:GetService("Players").LocalPlayer:WaitForChild("Backpack"):WaitForChild("Scripts"):WaitForChild("values"):WaitForChild("Action"),
                    C20 = "Sabotaging",
                    C22 = "S101"
                },
                Dhv8 = {
                    C21 = game:GetService("Players").LocalPlayer:WaitForChild("Backpack"):WaitForChild("Scripts"):WaitForChild("values"):WaitForChild("Action"),
                    C20 = "Sabotaging",
                    C22 = "S101"
                }
            }
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("NewPropertie"):FireServer(unpack(args))

        local args = {
            {
                D9v8 = {
                    C21 = Hook:WaitForChild("Panel"):WaitForChild("Sabotaging"),
                    C20 = game:GetService("Players").LocalPlayer,
                    C22 = "O101"
                },
                Bbh1O = {
                    C21 = Hook:WaitForChild("Panel"):WaitForChild("Sabotaging"),
                    C20 = game:GetService("Players").LocalPlayer,
                    C22 = "O101"
                },
                Dvh1O = {
                    C21 = Hook:WaitForChild("Panel"):WaitForChild("Sabotaging"),
                    C20 = game:GetService("Players").LocalPlayer,
                    C22 = "O101"
                },
                Dbh1O = {
                    C21 = Hook:WaitForChild("Panel"):WaitForChild("Sabotaging"),
                    C20 = game:GetService("Players").LocalPlayer,
                    C22 = "O101"
                },
                Dhv8 = {
                    C21 = Hook:WaitForChild("Panel"):WaitForChild("Sabotaging"),
                    C20 = game:GetService("Players"):WaitForChild("DeadingByRobloxGamer"),
                    C22 = "O101"
                }
            }
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("NewPropertie"):FireServer(unpack(args))

        local args = {
            {
                D9v8 = {
                    C21 = game:GetService("Players").LocalPlayer.Character:WaitForChild("Gold_Toolbox"):WaitForChild("Using"),
                    C20 = true,
                    C22 = "B101"
                },
                Bbh1O = {
                    C21 = game:GetService("Players").LocalPlayer.Character:WaitForChild("Gold_Toolbox"):WaitForChild("Using"),
                    C20 = true,
                    C22 = "B101"
                },
                Dvh1O = {
                    C21 = game:GetService("Players").LocalPlayer.Character:WaitForChild("Gold_Toolbox"):WaitForChild("Using"),
                    C20 = true,
                    C22 = "B101"
                },
                Dbh1O = {
                    C21 = game:GetService("Players").LocalPlayer.Character:WaitForChild("Gold_Toolbox"):WaitForChild("Using"),
                    C20 = true,
                    C22 = "B101"
                },
                Dhv8 = {
                    C21 = game:GetService("Players").LocalPlayer.Character:WaitForChild("Gold_Toolbox"):WaitForChild("Using"),
                    C20 = true,
                    C22 = "B101"
                }
            }
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("NewPropertie"):FireServer(unpack(args))

        task.wait(3)

        local args = {
            {
                D9v8 = {
                    C21 = game:GetService("Players").LocalPlayer:WaitForChild("Backpack"):WaitForChild("Scripts"):WaitForChild("values"):WaitForChild("Action"),
                    C20 = "Nothing",
                    C22 = "S101"
                },
                Bbh1O = {
                    C21 = game:GetService("Players").LocalPlayer:WaitForChild("Backpack"):WaitForChild("Scripts"):WaitForChild("values"):WaitForChild("Action"),
                    C20 = "Nothing",
                    C22 = "S101"
                },
                Dvh1O = {
                    C21 = game:GetService("Players").LocalPlayer:WaitForChild("Backpack"):WaitForChild("Scripts"):WaitForChild("values"):WaitForChild("Action"),
                    C20 = "Nothing",
                    C22 = "S101"
                },
                Dbh1O = {
                    C21 = game:GetService("Players").LocalPlayer:WaitForChild("Backpack"):WaitForChild("Scripts"):WaitForChild("values"):WaitForChild("Action"),
                    C20 = "Nothing",
                    C22 = "S101"
                },
                Dhv8 = {
                    C21 = game:GetService("Players").LocalPlayer:WaitForChild("Backpack"):WaitForChild("Scripts"):WaitForChild("values"):WaitForChild("Action"),
                    C20 = "Nothing",
                    C22 = "S101"
                }
            }
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("NewPropertie"):FireServer(unpack(args))

        local args = {
            {
                D9v8 = {
                    C21 = game:GetService("Players").LocalPlayer.Character:WaitForChild("Gold_Toolbox"):WaitForChild("Using"),
                    C20 = false,
                    C22 = "B101"
                },
                Bbh1O = {
                    C21 = game:GetService("Players").LocalPlayer.Character:WaitForChild("Gold_Toolbox"):WaitForChild("Using"),
                    C20 = false,
                    C22 = "B101"
                },
                Dvh1O = {
                    C21 = game:GetService("Players").LocalPlayer.Character:WaitForChild("Gold_Toolbox"):WaitForChild("Using"),
                    C20 = false,
                    C22 = "B101"
                },
                Dbh1O = {
                    C21 = game:GetService("Players").LocalPlayer.Character:WaitForChild("Gold_Toolbox"):WaitForChild("Using"),
                    C20 = false,
                    C22 = "B101"
                },
                Dhv8 = {
                    C21 = game:GetService("Players").LocalPlayer.Character:WaitForChild("Gold_Toolbox"):WaitForChild("Using"),
                    C20 = false,
                    C22 = "B101"
                }
            }
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("NewPropertie"):FireServer(unpack(args))

        local args = {
            {
                D9v8 = {
                    C21 = Hook:WaitForChild("Panel"):WaitForChild("Sabotaging"),
                    C22 = "O101"
                },
                Bbh1O = {
                    C21 = Hook:WaitForChild("Panel"):WaitForChild("Sabotaging"),
                    C22 = "O101"
                },
                Dvh1O = {
                    C21 = Hook:WaitForChild("Panel"):WaitForChild("Sabotaging"),
                    C22 = "O101"
                },
                Dbh1O = {
                    C21 = Hook:WaitForChild("Panel"):WaitForChild("Sabotaging"),
                    C22 = "O101"
                },
                Dhv8 = {
                    C21 = Hook:WaitForChild("Panel"):WaitForChild("Sabotaging"),
                    C22 = "O101"
                }
            }
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("NewPropertie"):FireServer(unpack(args))

    ]]
    
    Notify({
        Text = "<font color = 'rgb(0, 255, 0)'>Successfully</font> Loaded Dead By Roblox Modules Have Fun (:"
    })
elseif IsViolenceDistrict then
    local ViolenceDistrictCategory = CreateCategory({
        Name = "Violence District",
        Size = UDim2.fromScale(1, 0.5),
        Pos = UDim2.fromScale(0.77, 0),
        ClosedPos = UDim2.fromScale(0.45, 1),
    })
    
    local ChangeGenProgress; ChangeGenProgress = ViolenceDistrictCategory:CreateTextbox({
        ButtonText = "Change Gen Progress",
        MouseButton1Click = function()
            local Map = workspace:FindFirstChild("Map")
            local Val = tonumber(ChangeGenProgress.Textbox.Text)
			if not (Map and Val) then return end
            for i, v in ipairs(Map:GetChildren()) do
                if v.Name == "Generator" then
                    for i2, v2 in ipairs(v:GetChildren()) do
                        if string.find(v2.Name, "GeneratorPoint") then
                            ReplicatedStorage.Remotes.Generator.SkillCheckResultEvent:FireServer("success", Val, v, v2)   
                            break
                        end
                    end
                end
            end
        end,
    })
    
    TimeStop = false

    local TogglePlayTimeStopSound

    ToggleTimeStop = ViolenceDistrictCategory:CreateToggle({
        Text = "Time Stop",
        MouseButton1Click = function(Bool)
            for i, Player in pairs(Players:GetPlayers()) do
               if Player == Plr or Player.UserId == Plr.UserId then continue end
                local PlayerChar = GetChar(Player)
                local PlayerRoot = GetRoot(PlayerChar)
                if not (PlayerChar and PlayerRoot) then continue end
                ReplicatedStorage.Remotes.Collision.Anchor:FireServer(PlayerRoot, TimeStop)
            end
            if TogglePlayTimeStopSound.Disabled then return end
            if Bool then
                local Sound = Instance.new("Sound")
                Sound.SoundId = "rbxassetid://5104670875"
                Sound.Parent = SoundsFolder
                Sound:Play()
                Sound.Ended:Once(function()
                    Sound:Destroy()
                end)
            else
                local Sound = Instance.new("Sound")
                Sound.SoundId = "rbxassetid://3101648169"
                Sound.Parent = SoundsFolder
                Sound:Play()
                Sound.Ended:Once(function()
                    Sound:Destroy()
                end)
            end
        end,
    })

    TogglePlayTimeStopSound = ToggleTimeStop:CreateToggle({
        Text = "Play Time Stop Sound",
        MouseButton1Click = function()
            
        end,
    })
end

----------------------------------------------------------------------------------------------------- Visuals Category

ToggleNoShadows = Visuals:CreateToggle({
	Text = "No Shadows",
	Info = "Removes All Shadows.",
	Function = function(NoShadows)
		if NoShadows then
			Lighting.GlobalShadows = false
			Connections.Visuals.RemoveShadowsLoop = Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(function()
				Lighting.GlobalShadows = false
			end)
		else
			if Connections.Visuals.RemoveShadowsLoop then 
				Connections.Visuals.RemoveShadowsLoop:Disconnect()
				Connections.Visuals.RemoveShadowsLoop = nil
			end
		end
	end,
})

Connections.RemoveDepthOfFieldLoops = {}

ToggleNoDepthOfField = Visuals:CreateToggle({
	Text = "No Depth Of Field",
	Info = "Removes Depth Of Field. (Depth Of Field Makes Far Away Stuff Blurry)",
	Function = function(NoDepthOfField)
		if NoDepthOfField then
			for i, v in ipairs(Lighting:GetDescendants()) do
                if not v:IsA("DepthOfFieldEffect") then continue end
                v.Enabled = false
				local Connection = v:GetPropertyChangedSignal("Enabled"):Connect(function()
                    v.Enabled = false
                end)
				table.insert(Connections.RemoveDepthOfFieldLoops, Connection)
			end
			Connections.DepthOfFieldAdded = Lighting.DescendantAdded:Connect(function(Child)
				if Child:IsA("DepthOfFieldEffect") then
					Child.Enabled = false
					local Connection = Child:GetPropertyChangedSignal("Enabled"):Connect(function()
                        Child.Enabled = false
                    end)
					table.insert(Connections.RemoveDepthOfFieldLoops, Connection)
				end
			end)
		else
			if Connections.DepthOfFieldAdded then
				Connections.DepthOfFieldAdded:Disconnect()
                Connections.DepthOfFieldAdded = nil
			end
			for i, v in pairs(Connections.RemoveDepthOfFieldLoops) do
				v:Disconnect()
				v = nil
			end
			table.clear(Connections.RemoveDepthOfFieldLoops)
		end
	end,
})

ToggleNoFog = Visuals:CreateToggle({
	Text = "No Fog",
	Info = "Removes Fog (Fog Makes It Foggy)",
	Function = function(NoFog)
		if NoFog then
			Lighting.FogStart = 100000
			Connections.Visuals.RemoveFogStartLoop = Lighting:GetPropertyChangedSignal("FogStart"):Connect(function()
				Lighting.FogStart = 100000
			end)
			Lighting.FogEnd = 100000
			Connections.Visuals.RemoveFogEndLoop = Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
				Lighting.FogEnd = 100000
			end)
		else
			if Connections.Visuals.RemoveFogStartLoop then
				Connections.Visuals.RemoveFogStartLoop:Disconnect()
				Connections.Visuals.RemoveFogStartLoop = nil
			end
			if Connections.Visuals.RemoveFogEndLoop then
				Connections.Visuals.RemoveFogEndLoop:Disconnect()
				Connections.Visuals.RemoveFogEndLoop = nil
			end
		end
	end,
})

Connections.Visuals.RemoveAtmosphereLoops = {}

ToggleNoAtmosphere = Visuals:CreateToggle({
    Text = "No Atmosphere",
    Info = "Atmosphere Makes It Hard To See.",
    Function = function(NoAtmosphere)
        if NoAtmosphere then
            for i, v in ipairs(Lighting:GetDescendants()) do
                if not v:IsA("Atmosphere") then continue end
                v.Density = 0
                local Connection = v:GetPropertyChangedSignal("Density"):Connect(function()
                    v.Density = 0
                end)
                v.Glare = 0
                local Connection2 = v:GetPropertyChangedSignal("Glare"):Connect(function()
                    v.Glare = 0
                end)
                v.Haze = 0
                local Connection3 = v:GetPropertyChangedSignal("Haze"):Connect(function()
                    v.Haze = 0
                end)
                table.insert(Connections.Visuals.RemoveAtmosphereLoops, Connection)
                table.insert(Connections.Visuals.RemoveAtmosphereLoops, Connection2)
                table.insert(Connections.Visuals.RemoveAtmosphereLoops, Connection3)
            end
            Connections.Visuals.AtmosphereAdded = Lighting.DescendantAdded:Connect(function(Child)
                if Child:IsA("Atmosphere") then
                    Child.Density = 0
                    local Connection = Child:GetPropertyChangedSignal("Density"):Connect(function()
                        Child.Density = 0
                    end)
                    Child.Glare = 0
                    local Connection2 = Child:GetPropertyChangedSignal("Glare"):Connect(function()
                        Child.Glare = 0
                    end)
                    Child.Haze = 0
                    local Connection3 = Child:GetPropertyChangedSignal("Haze"):Connect(function()
                        Child.Haze = 0
                    end)
                    table.insert(Connections.Visuals.RemoveAtmosphereLoops, Connection)
                    table.insert(Connections.Visuals.RemoveAtmosphereLoops, Connection2)
                    table.insert(Connections.Visuals.RemoveAtmosphereLoops, Connection3)
                end
            end)
        else
            if Connections.Visuals.AtmosphereAdded then
                Connections.Visuals.AtmosphereAdded:Disconnect()
                Connections.Visuals.AtmosphereAdded = nil
            end
            for i, v in pairs(Connections.Visuals.RemoveAtmosphereLoops) do
                v:Disconnect()
                v = nil
            end
            table.clear(Connections.Visuals.RemoveAtmosphereLoops)
        end
    end,
})

Connections.Visuals.RemoveBloomLoops = {}

ToggleNoBloom = Visuals:CreateToggle({
	Text = "No Bloom",
	Info = "Removes Bloom Effects",
	Function = function(NoBloom)
		if NoBloom then
			for i, v in pairs(Lighting:GetDescendants()) do
                if not v:IsA("BloomEffect") then continue end
                v.Enabled = false
				local Connection = v:GetPropertyChangedSignal("Enabled"):Connect(function()
                    v.Enabled = false
                end)
				table.insert(Connections.Visuals.RemoveBloomLoops, Connection)
			end
			Connections.Visuals.BloomAdded = Lighting.DescendantAdded:Connect(function(Child)
				if Child:IsA("BloomEffect") then
                    Child.Enabled = false
					local Connection = Child:GetPropertyChangedSignal("Enabled"):Connect(function()
                        Child.Enabled = false
                    end)
					table.insert(Connections.Visuals.RemoveBloomLoops, Connection)
				end
			end)
		else
			if Connections.Visuals.BloomAdded then
				Connections.Visuals.BloomAdded:Disconnect()
				Connections.Visuals.BloomAdded = nil
			end
			for i, v in pairs(Connections.Visuals.RemoveBloomLoops) do
				v:Disconnect()
				v = nil
			end
			table.clear(Connections.Visuals.RemoveBloomLoops)
		end
	end,
})

Connections.Visuals.RemoveBlurLoops = {}

ToggleNoBlur = Visuals:CreateToggle({
	Text = "No Blur",
	Info = "Removes Blur Effects",
	Function = function(NoBlur)
		if NoBlur then
			for i, v in ipairs(Lighting:GetDescendants()) do
				if not v:IsA("BlurEffect") then continue end
                v.Enabled = false
                local Connection = v:GetPropertyChangedSignal("Enabled"):Connect(function()
                    v.Enabled = false
                end)
                table.insert(Connections.Visuals.RemoveBlurLoops, Connection)
			end
			Connections.Visuals.BlurAdded = Lighting.DescendantAdded:Connect(function(Child)
				if Child:IsA("BlurEffect") then
                    Child.Enabled = false
					local Connection = Child:GetPropertyChangedSignal("Enabled"):Connect(function()
                        Child.Enabled = false
                    end)
					table.insert(Connections.Visuals.RemoveBlurLoops, Connection)
				end
			end)
		else
			if Connections.Visuals.BlurAdded then
				Connections.Visuals.BlurAdded:Disconnect()
				Connections.Visuals.BlurAdded = nil
			end
			for i, v in pairs(Connections.Visuals.RemoveBlurLoops) do
				v:Disconnect()
				v = nil
			end
			table.clear(Connections.Visuals.RemoveBlurLoops)
		end
	end,
})

Connections.Visuals.NoColorCorrectionLoops = {}

ToggleNoColorCorrection = Visuals:CreateToggle({
	Text = "No Color Correction",
	Info = "Removes Color Correction Effects",
	Function = function(NoColorCorrection)
		if NoColorCorrection then
			for i, v in ipairs(Lighting:GetDescendants()) do
                if not v:IsA("ColorCorrectionEffect") then continue end
                v.Enabled = false
				local Connection = v:GetPropertyChangedSignal("Enabled"):Connect(function()
                    v.Enabled = false
                end)
				table.insert(Connections.Visuals.NoColorCorrectionLoops, Connection)
			end
			Connections.Visuals.ColorCorrectionAdded = Lighting.DescendantAdded:Connect(function(Child)
				if Child:IsA("ColorCorrectionEffect") then
                    Child.Enabled = false
					local Connection = Child:GetPropertyChangedSignal("Enabled"):Connect(function()
                        Child.Enabled = false
                    end)
					table.insert(Connections.Visuals.NoColorCorrectionLoops, Connection)
				end
			end)
		else
			if Connections.Visuals.ColorCorrectionAdded then
				Connections.Visuals.ColorCorrectionAdded:Disconnect()
				Connections.Visuals.ColorCorrectionAdded = nil
			end
			for i, v in pairs(Connections.Visuals.NoColorCorrectionLoops) do
				v:Disconnect()
				v = nil
			end
			table.clear(Connections.Visuals.NoColorCorrectionLoops)
		end
	end,
})

Connections.Visuals.RemoveSunRaysLoops = {}

ToggleNoSunRays = Visuals:CreateToggle({
	Text = "No SunRays",
	Info = "Removes SunRay Effects",
	Function = function(NoSunRays)
		if NoSunRays then
			for i, v in ipairs(Lighting:GetDescendants()) do
                if not v:IsA("SunRaysEffect") then continue end
                v.Enabled = false
				local Connection = v:GetPropertyChangedSignal("Enabled"):Connect(function()
                    v.Enabled = false
                end)
				table.insert(Connections.Visuals.RemoveSunRaysLoops, Connection)
			end
			Connections.Visuals.SunRayAdded = Lighting.DescendantAdded:Connect(function(Child)
				if Child:IsA("SunRaysEffect") then
                    Child.Enabled = false
					local Connection = Child:GetPropertyChangedSignal("Enabled"):Connect(function()
                        Child.Enabled = false
                    end)
					table.insert(Connections.Visuals.RemoveSunRaysLoops, Connection)
				end
			end)
		else
			if Connections.Visuals.SunRayAdded then
				Connections.Visuals.SunRayAdded:Disconnect()
				Connections.Visuals.SunRayAdded = nil
			end
			for i, v in pairs(Connections.Visuals.RemoveSunRaysLoops) do
				v:Disconnect()
				v = nil
			end
			table.clear(Connections.Visuals.RemoveSunRaysLoops)
		end
	end,
})

do
    local function RemoveSky(Sky)
        Sky.CelestialBodiesShown = false
        Sky.MoonAngularSize = 0
        Sky.MoonTextureId = ""
        Sky.SkyboxBk = "rbxasset://textures/sky/sky512_bk.tex"
        Sky.SkyboxDn = "rbxasset://textures/sky/Dn.tex"
        Sky.SkyboxFt = "rbxasset://textures/sky/sky512_ft.tex"
        Sky.SkyboxLf = "rbxasset://textures/sky/sky512_lf.tex"
        Sky.SkyboxRt = "rbxasset://textures/sky/sky512_rt.tex"
        Sky.SkyboxUp = "rbxasset://textures/sky/sky512_up.tex"
        Sky.StarCount = 0
        Sky.SunAngularSize = 0
        Sky.SunTextureId = ""
    end

    Connections.Visuals.NoSkyLoops = {}

    ToggleNoSky = Visuals:CreateToggle({
        Text = "No Sky",
        Info = "This Will Force All Skyboxes To Be The Default Skybox",
        Function = function(NoSky)
            if NoSky then
                for i, v in ipairs(Lighting:GetDescendants()) do
                    if not v:IsA("Sky") then continue end
                    RemoveSky(v)
                    local Connection = v.Changed:Connect(function()
                        RemoveSky(v)
                    end)
                    table.insert(Connections.Visuals.NoSkyLoops, Connection)
                end
                Connections.Visuals.SkyAdded = Lighting.DescendantAdded:Connect(function(Child)
                    if Child:IsA("Sky") then
                        RemoveSky(Child)
                        local Connection = Child.Changed:Connect(function()
                            RemoveSky(Child)
                        end)
                        table.insert(Connections.Visuals.NoSkyLoops, Connection)
                    end
                end)
            else
                if Connections.Visuals.SkyAdded then
                    Connections.Visuals.SkyAdded:Disconnect()
                    Connections.Visuals.SkyAdded = nil
                end
                for i, v in pairs(Connections.Visuals.NoSkyLoops) do
                    v:Disconnect()
                    v = nil
                end
                table.clear(Connections.Visuals.NoSkyLoops)
            end
        end,
    })
end

Connections.Visuals.NoColorGradingEffects = {}

ToggleNoColorGrading = Visuals:CreateToggle({
	Text = "No Color Grading",
	Info = "Removes Color Grading Effects",
	Function = function(NoColorGrading)
		if NoColorGrading then
			for i, v in ipairs(Lighting:GetDescendants()) do
                if not v:IsA("ColorGradingEffect") then continue end
                v.Enabled = false
				local Connection = v:GetPropertyChangedSignal("Enabled"):Connect(function()
                    v.Enabled = false
                end)
				table.insert(Connections.Visuals.NoColorGradingEffects, Connection)
			end
			Connections.Visuals.ColorGradingAdded = Lighting.DescendantAdded:Connect(function(Child)
				if Child:IsA("ColorGradingEffect") then
                    Child.Enabled = false
					local Connection = Child:GetPropertyChangedSignal("Enabled"):Connect(function()
                        Child.Enabled = false
                    end)
					table.insert(Connections.Visuals.NoColorGradingEffects, Connection)
				end
			end)
		else
			if Connections.Visuals.ColorGradingAdded then
				Connections.Visuals.ColorGradingAdded:Disconnect()
				Connections.Visuals.ColorGradingAdded = nil
			end
			for i, v in pairs(Connections.Visuals.NoColorGradingEffects) do
				v:Disconnect()
				v = nil
			end
			table.clear(Connections.Visuals.NoColorGradingEffects)
		end
	end,
})

do
    ToggleForceTimeOfDay = nil
    local function UpdateTimeOfDay()
        if ToggleForceTimeOfDay.Enabled then
            Lighting.ClockTime = ForceTimeOfDay
        end
    end

    ToggleForceTimeOfDay = Visuals:CreateToggle({
        Text = "Force Time Of Day",
        Info = "Forces It To Be The Specified Time Of Day (In Hours)",
        Function = function(ForceTimeOfDayEnabled)
            if ForceTimeOfDayEnabled then
                UpdateTimeOfDay()
                Connections.Visuals.ForceTimeOfDayLoop = Lighting:GetPropertyChangedSignal("ClockTime"):Connect(UpdateTimeOfDay)
            else
                if Connections.Visuals.ForceTimeOfDayLoop then
                    Connections.Visuals.ForceTimeOfDayLoop:Disconnect()
                    Connections.Visuals.ForceTimeOfDayLoop = nil
                end
            end
        end,
    })

    ForceTimeOfDaySlider = ToggleForceTimeOfDay:CreateSlider({
        Text = "Time Of Day",
        Min = 0,
        Default = 12,
        Max = 24,
        Function = function(Val)
            ForceTimeOfDay = Val
            UpdateTimeOfDay()
        end,
        Function2 = function(Val)
            ForceTimeOfDay = Val
            UpdateTimeOfDay()
        end,
    })
end

do
    ToggleBrightness = nil
	local function UpdateBrightness()
		if ToggleBrightness.Enabled then
            Lighting.Brightness = Brightness
        end
	end

    ToggleBrightness = Visuals:CreateToggle({
        Text = "Brightness",
        Info = "Changes The Brightness Of Lighting. (Brightness Makes It Very Bright)",
        Function = function(BrightnessEnabled)
            if BrightnessEnabled then
                UpdateBrightness()
                Connections.Visuals.SetBrightnessLoop = Lighting:GetPropertyChangedSignal("Brightness"):Connect(UpdateBrightness)
            else
                if Connections.Visuals.SetBrightnessLoop then
                    Connections.Visuals.SetBrightnessLoop:Disconnect()
                    Connections.Visuals.SetBrightnessLoop = nil
                end
            end
        end,
    })

    BrightnessSlider = ToggleBrightness:CreateSlider({
        Text = "Brightness",
        Min = 0,
        Default = 3,
        Max = 30,
        Function = function(Val)
            Brightness = Val
            UpdateBrightness()
        end,
        Function2 = function(Val)
            Brightness = Val
            UpdateBrightness()
        end,
    })
end

ToggleWaterTransparency = Visuals:CreateToggle({
    Text = "Water Transparency",
    Info = "Sets Water Transparency To The Specified Value",
    MouseButton1Click = function(WaterTransparencyEnabled)
        if WaterTransparencyEnabled then
            local Terrain = workspace:FindFirstChildWhichIsA("Terrain")
            if not Terrain then return end
            Terrain.WaterTransparency = WaterTransparency
            Connections.Visuals.WaterTransparencyLoop = Terrain:GetPropertyChangedSignal("WaterTransparency"):Connect(function()
                Terrain.WaterTransparency = WaterTransparency
            end)
        else
            if Connections.Visuals.WaterTransparencyLoop then
                Connections.Visuals.WaterTransparencyLoop:Disconnect()
                Connections.Visuals.WaterTransparencyLoop = nil
            end
        end
    end,
})

WaterTransparencySlider = ToggleWaterTransparency:CreateSlider({
    Text = "Water Transparency",
    Min = 0,
    Default = 0.5,
    Max = 1,
    Function = function(Val)
        WaterTransparency = Val
    end,
    Function2 = function(Val)
        WaterTransparency = Val
    end,
})

ToggleGeographicLatitude = Visuals:CreateToggle({
    Text = "Geographic Latitude",
    MouseButton1Click = function(GeographicLatitudeEnabled)
        if GeographicLatitudeEnabled then
            Lighting.GeographicLatitude = GeographicLatitude
            Connections.Visuals.GeographicLatitudeConnection = Lighting:GetPropertyChangedSignal("GeographicLatitude"):Connect(function()
                Lighting.GeographicLatitude = GeographicLatitude
            end)
        else
            if Connections.Visuals.GeographicLatitudeConnection then
                Connections.Visuals.GeographicLatitudeConnection:Disconnect()
                Connections.Visuals.GeographicLatitudeConnection = nil
            end
        end
    end,
})

GeographicLatitudeSlider = ToggleGeographicLatitude:CreateSlider({
    Text = "Geographic Latitude",
    Min = 0,
    Default = 0,
    Max = 360,
    Function = function(Val)
        GeographicLatitude = Val
        if ToggleGeographicLatitude.Enabled then
            Lighting.GeographicLatitude = GeographicLatitude
        end
    end,
    Function2 = function(Val)
        GeographicLatitude = Val
        if ToggleGeographicLatitude.Enabled then
            Lighting.GeographicLatitude = GeographicLatitude
        end
    end,
})

ToggleColorShiftBottom = Visuals:CreateToggle({
    Text = "Color Shift Bottom",
    MouseButton1Click = function(ColorShiftBottomEnabled)
        if ColorShiftBottomEnabled then
            Lighting.ColorShift_Bottom = ColorShiftBottom
            Connections.Visuals.ColorShiftBottomConnection = Lighting:GetPropertyChangedSignal("ColorShift_Bottom"):Connect(function()
                Lighting.ColorShift_Bottom = ColorShiftBottom
            end)
        else
            if Connections.Visuals.ColorShiftBottomConnection then
                Connections.Visuals.ColorShiftBottomConnection:Disconnect()
                Connections.Visuals.ColorShiftBottomConnection = nil
            end
        end
    end,
})

ToggleColorShiftBottom:CreateColorPicker({
    Text = "Color Shift Bottom Color",
    Default = ColorShiftBottom,
    Function = function(Color)
        ColorShiftBottom = Color
        if ToggleColorShiftBottom.Enabled then
            Lighting.ColorShift_Bottom = ColorShiftBottom
        end
    end,
})

ToggleColorShiftTop = Visuals:CreateToggle({
    Text = "Color Shift Top",
    MouseButton1Click = function(ColorShiftTopEnabled)
        if ColorShiftTopEnabled then
            Lighting.ColorShift_Top = ColorShiftTop
            Connections.Visuals.ColorShiftTopConnection = Lighting:GetPropertyChangedSignal("ColorShift_Top"):Connect(function()
                Lighting.ColorShift_Top = ColorShiftTop
            end)
        else
            if Connections.Visuals.ColorShiftTopConnection then
                Connections.Visuals.ColorShiftTopConnection:Disconnect()
                Connections.Visuals.ColorShiftTopConnection = nil
            end
        end
    end,
})

ToggleColorShiftTop:CreateColorPicker({
    Text = "Color Shift Top Color",
    Default = ColorShiftTop,
    Function = function(Color)
        ColorShiftTop = Color
        if ToggleColorShiftTop.Enabled then
            Lighting.ColorShift_Top = ColorShiftTop
        end
    end,
})

ToggleAmbient = Visuals:CreateToggle({
    Text = "Ambient",
    MouseButton1Click = function(AmbientEnabled)
        if AmbientEnabled then
            Lighting.Ambient = Ambient
            Connections.Visuals.AmbientConnection = Lighting:GetPropertyChangedSignal("Ambient"):Connect(function()
                Lighting.Ambient = Ambient
            end)
        else
            if Connections.Visuals.AmbientConnection then
                Connections.Visuals.AmbientConnection:Disconnect()
                Connections.Visuals.AmbientConnection = nil
            end
        end
    end,
})

AmbientColorPicker = ToggleAmbient:CreateColorPicker({
    Text = "Ambient Color",
    Default = Ambient,
    Function = function(Color)
        Ambient = Color
        if ToggleAmbient.Enabled then
            Lighting.Ambient = Ambient
        end
    end,
})

ToggleOutdoorAmbient = Visuals:CreateToggle({
    Text = "Outdoor Ambient",
    MouseButton1Click = function(OutdoorAmbientEnabled)
        if OutdoorAmbientEnabled then
            Lighting.OutdoorAmbient = OutdoorAmbient
            Connections.Visuals.OutdoorAmbientConnection = Lighting:GetPropertyChangedSignal("OutdoorAmbient"):Connect(function()
                Lighting.OutdoorAmbient = OutdoorAmbient
            end)
        else
            if Connections.Visuals.OutdoorAmbientConnection then
                Connections.Visuals.OutdoorAmbientConnection:Disconnect()
                Connections.Visuals.OutdoorAmbientConnection = nil
            end
        end
    end,
})

OutdoorAmbientColorPicker = ToggleOutdoorAmbient:CreateColorPicker({
    Text = "Outdoor Ambient Color",
    Default = OutdoorAmbient,
    Function = function(Color)
        OutdoorAmbient = Color
        if ToggleOutdoorAmbient.Enabled then
            Lighting.OutdoorAmbient = OutdoorAmbient
        end
    end,
})

ToggleEnvironmentDiffuseScale = Visuals:CreateToggle({
    Text = "Environment Diffuse Scale",
    MouseButton1Click = function(EnvironmentDiffuseScaleEnabled)
        if EnvironmentDiffuseScaleEnabled then
            Lighting.EnvironmentDiffuseScale = EnvironmentDiffuseScale
            Connections.Visuals.EnvironmentDiffuseScaleConnection = Lighting:GetPropertyChangedSignal("EnvironmentDiffuseScale"):Connect(function()
                Lighting.EnvironmentDiffuseScale = EnvironmentDiffuseScale
            end)
        else
            if Connections.Visuals.EnvironmentDiffuseScaleConnection then
                Connections.Visuals.EnvironmentDiffuseScaleConnection:Disconnect()
                Connections.Visuals.EnvironmentDiffuseScaleConnection = nil
            end
        end
    end,
})

EnvironmentDiffuseScaleSlider = ToggleEnvironmentDiffuseScale:CreateSlider({
    Text = "Environment Diffuse Scale",
    Min = 0,
    Default = 1,
    Max = 1,
    Function = function(Val)
        EnvironmentDiffuseScale = Val
        if ToggleEnvironmentDiffuseScale.Enabled then
            Lighting.EnvironmentDiffuseScale = EnvironmentDiffuseScale
        end
    end,
    Function2 = function(Val)
        EnvironmentDiffuseScale = Val
        if ToggleEnvironmentDiffuseScale.Enabled then
            Lighting.EnvironmentDiffuseScale = EnvironmentDiffuseScale
        end
    end,
})

ToggleEnvironmentSpecularScale = Visuals:CreateToggle({
    Text = "Environment Specular Scale",
    MouseButton1Click = function(Enabled)
        if Enabled then
            Lighting.EnvironmentSpecularScale = EnvironmentSpecularScale
            Connections.Visuals.EnvironmentSpecularScaleConnection = Lighting:GetPropertyChangedSignal("EnvironmentSpecularScale"):Connect(function()
                Lighting.EnvironmentSpecularScale = EnvironmentSpecularScale
            end)
        else
            if Connections.Visuals.EnvironmentSpecularScaleConnection then
                Connections.Visuals.EnvironmentSpecularScaleConnection:Disconnect()
                Connections.Visuals.EnvironmentSpecularScaleConnection = nil
            end
        end
    end,
})

EnvironmentSpecularScaleSlider = ToggleEnvironmentSpecularScale:CreateSlider({
    Text = "EnvironmentSpecularScale",
    Min = 0,
    Default = EnvironmentSpecularScale,
    Max = 1,
    Function = function(Val)
        EnvironmentSpecularScale = Val
        if ToggleEnvironmentSpecularScale.Enabled then
            Lighting.EnvironmentSpecularScale = EnvironmentSpecularScale
        end
    end,
    Function2 = function(Val)
        EnvironmentSpecularScale = Val
        if ToggleEnvironmentSpecularScale.Enabled then
            Lighting.EnvironmentSpecularScale = EnvironmentSpecularScale
        end
    end,
})

ToggleShadowSoftness = Visuals:CreateToggle({
    Text = "Shadow Softness",
    MouseButton1Click = function(ShadowSoftnessEnabled)
        if ShadowSoftnessEnabled then
            Lighting.ShadowSoftness = ShadowSoftness
            Connections.Visuals.ShadowSoftnessConnection = Lighting:GetPropertyChangedSignal("ShadowSoftness"):Connect(function()
                Lighting.ShadowSoftness = ShadowSoftness
            end)
        else
            if Connections.Visuals.ShadowSoftnessConnection then
                Connections.Visuals.ShadowSoftnessConnection:Disconnect()
                Connections.Visuals.ShadowSoftnessConnection = nil
            end
        end
    end,
})

ShadowSoftnessSlider = ToggleShadowSoftness:CreateSlider({
    Text = "Shadow Softness",
    Min = 0,
    Default = ShadowSoftness,
    Max = 1,
    Function = function(Val)
        ShadowSoftness = Val
    end,
    Function2 = function(Val)
        ShadowSoftness = Val
    end,
})

ToggleExposureCompensation = Visuals:CreateToggle({
    Text = "Exposure Compensation",
    MouseButton1Click = function(ExposureCompensationEnabled)
        if ExposureCompensationEnabled then
            Lighting.ExposureCompensation = ExposureCompensation
            Connections.ExposureCompensationConnection = Lighting:GetPropertyChangedSignal("ExposureCompensation"):Connect(function()
                Lighting.ExposureCompensation = ExposureCompensation
            end)
        else
            if Connections.ExposureCompensationConnection then
                Connections.ExposureCompensationConnection:Disconnect()
                Connections.ExposureCompensationConnection = nil
            end
        end
    end,
})

ExposureCompensationSlider = ToggleExposureCompensation:CreateSlider({
    Text = "Exposure Compensation",
    Min = -3,
    Default = 0,
    Max = 3,
    Function = function(Val)
        ExposureCompensation = Val
    end,
    Function2 = function(Val)
        ExposureCompensation = Val
    end,
})

ToggleViewPlayer = nil; ToggleViewPlayer = Other:CreateTextbox({
	ButtonText = "View Player",
	PlaceholderText = "Player Name",
	Info = "Sets Your Humanoid Subject To The Specified Player.",
    EnabledIndicator = true,
	Function = function(ViewingPlayer)
		if ViewingPlayer then
			local Player = FindPlayer(ToggleViewPlayer.Textbox.Text)
			local PlayerChar = GetChar(Player)
			local PlayerRoot = GetRoot(PlayerChar)
			local PlayerHumanoid = GetHumanoid(PlayerChar)
			local Char = GetChar(Plr)
			local Root = GetRoot(Char)
			local Humanoid = GetHumanoid(Char)
			Camera.CameraSubject = PlayerHumanoid or PlayerRoot or Humanoid or Root
		else
			local Char = GetChar(Plr)
			local Humanoid = GetHumanoid(Char)
			local Root = GetRoot(Char)
			if Char and Humanoid then
				Camera.CameraSubject = Humanoid or Root
			end
		end
	end,
})

do
    Connections.Visuals.PlayerHighlightEspConnections = {}
    local PlayerHighlightEspPropertyChanged = Signal.new()

    ToggleAutomaticPlayerHighlightEspFillColor, ToggleAutomaticPlayerHighlightEspOutlineColor = nil, nil

    local function EspPlayer(Player)
        if Player == Plr or Player.UserId == Plr.UserId then return end
        local Highlight = Instance.new("Highlight")
        Highlight.Name = `{Player.Name}_PlayerHighlightESP`
        Highlight.Adornee = GetChar(Player)
        Highlight.Parent = EspFolder

        local function UpdatePlayerHighlightESP()
            local PlayerIsTeammate = IsTeammate(Player)
            if ToggleAutomaticPlayerHighlightEspOutlineColor.Enabled then
                Highlight.OutlineColor = GetTeamColor(Player)
            else
                if PlayerIsTeammate then
                    Highlight.OutlineColor = PlayerHighlightEspTeammateOutlineColor
                else
                    Highlight.OutlineColor = PlayerHighlightEspEnemyOutlineColor
                end
            end
            if ToggleAutomaticPlayerHighlightEspFillColor.Enabled then
                Highlight.FillColor = GetTeamColor(Player)
            else
                if PlayerIsTeammate then
                    Highlight.FillColor = PlayerHighlightEspTeammateFillColor
                else
                    Highlight.FillColor = PlayerHighlightEspEnemyFillColor
                end
            end
            Highlight.OutlineTransparency = PlayerHighlightEspOutlineTransparency
            Highlight.FillTransparency = PlayerHighlightEspFillTransparency
        end

        Connections.Visuals.PlayerHighlightEspConnections[`{Player.Name}_CharacterAddedConnection`] = Player.CharacterAdded:Connect(function(Char)
            Highlight.Adornee = Char
        end)
        Connections.Visuals.PlayerHighlightEspConnections[`{Player.Name}_TeamChangedConnection`] = Player:GetPropertyChangedSignal("Team"):Connect(UpdatePlayerHighlightESP)
        UpdatePlayerHighlightESP()
        Connections.Visuals.PlayerHighlightEspConnections[`{Player.Name}_PlayerHighlightEspPropertyChangedConnection`] = PlayerHighlightEspPropertyChanged:Connect(UpdatePlayerHighlightESP)
    end
    
    TogglePlayerHighlightESP = Visuals:CreateToggle({
        Text = "Player Highlight ESP",
        Info = "Uses Roblox Highlights To Make ESP.",
        Function = function(PlayerHighlightESP)
            if PlayerHighlightESP then
                for i, Player in ipairs(Players:GetPlayers()) do
                    EspPlayer(Player)
                end
                Connections.Visuals.PlayerHighlightEspPlayerAddedConnection = Players.PlayerAdded:Connect(EspPlayer)
                Connections.Visuals.PlayerHighlightEspPlayerRemovedConnection = Players.PlayerRemoving:Connect(function(Player)
                    for i, v in ipairs(EspFolder:GetChildren()) do
                        if v.Name:find(Player.Name) then
                            v:Destroy()
                        end
                    end
                    for i, v in pairs(Connections.Visuals.PlayerHighlightEspConnections) do
                        if i == `{Player.Name}_PlayerHighlightEspPropertyChangedConnection` or i == `{Player.Name}_TeamChangedConnection` or i == `{Player.Name}_CharacterAddedConnection` then
                            v:Disconnect()
                            v = nil
                        end
                    end
                end)
            else
                for Name, Connection in pairs(Connections.Visuals.PlayerHighlightEspConnections) do
                    Connection:Disconnect()
                    Connection = nil
                end
                if Connections.Visuals.PlayerHighlightEspPlayerAddedConnection then
                    Connections.Visuals.PlayerHighlightEspPlayerAddedConnection:Disconnect()
                    Connections.Visuals.PlayerHighlightEspPlayerAddedConnection = nil
                end
                if Connections.Visuals.PlayerHighlightEspPlayerRemovedConnection then
                    Connections.Visuals.PlayerHighlightEspPlayerRemovedConnection:Disconnect()
                    Connections.Visuals.PlayerHighlightEspPlayerRemovedConnection = nil
                end
                for i, Highlight in pairs(EspFolder:GetChildren()) do
                    if Highlight.Name:find("_PlayerHighlightESP") then
                        Highlight:Destroy()
                    end
                end
                PlayerHighlightEspPropertyChanged:DisconnectAll()
            end
        end,
    })
    
    PlayerHighlightEspTeammateOutlineColorPicker = TogglePlayerHighlightESP:CreateColorPicker({
        Text = "Teammate Outline Color",
        Default = PlayerHighlightEspTeammateOutlineColor,
        Function = function(Color)
            PlayerHighlightEspTeammateOutlineColor = Color
            PlayerHighlightEspPropertyChanged:Fire()
        end,
    })

    PlayerHighlightEspTeammateFillColorPicker = TogglePlayerHighlightESP:CreateColorPicker({
        Text = "Teammate Fill Color",
        Default = PlayerHighlightEspTeammateFillColor,
        Function = function(Color)
            PlayerHighlightEspTeammateFillColor = Color
            PlayerHighlightEspPropertyChanged:Fire()
        end,
    })

    PlayerHighlightEspEnemyOutlineColorPicker = TogglePlayerHighlightESP:CreateColorPicker({
        Text = "Enemy Outline Color",
        Default = PlayerHighlightEspEnemyOutlineColor,
        Function = function(Color)
            PlayerHighlightEspEnemyOutlineColor = Color
            PlayerHighlightEspPropertyChanged:Fire()
        end,
    })

    PlayerHighlightEspEnemyFillColorPicker = TogglePlayerHighlightESP:CreateColorPicker({
        Text = "Enemy Fill Color",
        Default = PlayerHighlightEspEnemyFillColor,
        Function = function(Color)
            PlayerHighlightEspEnemyFillColor = Color
            PlayerHighlightEspPropertyChanged:Fire()
        end,
    })

    PlayerHighlightEspOutlineTransparencySlider = TogglePlayerHighlightESP:CreateSlider({
        Text = "Outline Transparency",
        Min = 0,
        Default = 0,
        Max = 1,
        Function = function(Val)
            PlayerHighlightEspOutlineTransparency = Val
            PlayerHighlightEspPropertyChanged:Fire()
        end,
        Function2 = function(Val)
            PlayerHighlightEspOutlineTransparency = Val
            PlayerHighlightEspPropertyChanged:Fire()
        end,
    })

    PlayerHighlightEspFillTransparencySlider = TogglePlayerHighlightESP:CreateSlider({
        Text = "Fill Transparency",
        Min = 0,
        Default = 1,
        Max = 1,
        Function = function(Val)
            PlayerHighlightEspFillTransparency = Val
            PlayerHighlightEspPropertyChanged:Fire()
        end,
        Function2 = function(Val)
            PlayerHighlightEspFillTransparency = Val
            PlayerHighlightEspPropertyChanged:Fire()
        end,
    })

    ToggleAutomaticPlayerHighlightEspOutlineColor = TogglePlayerHighlightESP:CreateToggle({
        Text = "Automatic Outline Color",
        Function = function(Bool)
            AutomaticPlayerHighlightEspOutlineColor = Bool
            PlayerHighlightEspPropertyChanged:Fire()
        end,
    })
    
    ToggleAutomaticPlayerHighlightEspFillColor = TogglePlayerHighlightESP:CreateToggle({
        Text = "Automatic Fill Color",
        Function = function(Bool)
            AutomaticPlayerHighlightEspFillColor = Bool
            PlayerHighlightEspPropertyChanged:Fire()
        end,
    })
end

do
    local PlayerTracersHolder = Instance.new("ScreenGui")
    PlayerTracersHolder.Name = "PlayerTracers"
    PlayerTracersHolder.IgnoreGuiInset = true
    PlayerTracersHolder.DisplayOrder = 69419
    PlayerTracersHolder.Parent = EspFolder

    Connections.Visuals.PlayerTracerConnections = {}

    ToggleAutomaticPlayerTracersColor = nil

    local function TracePlayer(Player)
        if Player == Plr or Player.UserId == Plr.UserId then return end
        local Path2D = Instance.new("Path2D")
        Path2D.Name = tostring(Player.UserId)
        Path2D.Parent = PlayerTracersHolder
        Connections.Visuals.PlayerTracerConnections[Player.UserId] = RunService.RenderStepped:Connect(function()
            local Char = GetChar(Plr)
            local Root = GetRoot(Char)
            if not (Char and Root) then return end
            local PlayerChar = GetChar(Player)
            local PlayerRoot = GetRoot(PlayerChar)
            if not (PlayerChar and PlayerRoot) then return end
            local Vector, OnScreen = Camera:WorldToViewportPoint(PlayerRoot.Position)
            if OnScreen then
                Path2D:SetControlPoints({
                    Path2DControlPoint.new(UDim2.fromOffset(PlayerTracersPosition.X, PlayerTracersPosition.Y)),
                    Path2DControlPoint.new(UDim2.fromOffset(Vector.X, Vector.Y)),
                })
                Path2D.Color3 = if ToggleAutomaticPlayerTracersColor.Enabled then GetTeamColor(Player) else if IsTeammate(Player) then PlayerTracersTeammateColor else PlayerTracersEnemyColor
                Path2D.Thickness = PlayerTracersThickness
                Path2D.Visible = true
            else
                Path2D.Visible = false
            end
        end)
    end
    
    TogglePlayerTracers = Visuals:CreateToggle({
        Text = "Player Tracers",
        Info = "it traces players probably",
        Function = function(PlayerTracers)
            if PlayerTracers then
                for i, Player in ipairs(Players:GetPlayers()) do
                    TracePlayer(Player)
                end
                Connections.Visuals.TracersPlayerAddedConnection = Players.PlayerAdded:Connect(TracePlayer)
                Connections.Visuals.TracersPlayerRemovingConnection = Players.PlayerRemoving:Connect(function(Player)
                    if Connections.Visuals.PlayerTracerConnections[Player.UserId] then
                        Connections.Visuals.PlayerTracerConnections[Player.UserId]:Disconnect()
                        Connections.Visuals.PlayerTracerConnections[Player.UserId] = nil
                    end
                    local FoundTracer = PlayerTracersHolder:FindFirstChild(tostring(Player.UserId))
                    if FoundTracer then
                        FoundTracer:Destroy()
                    end
                end)
            else
                if Connections.Visuals.TracersPlayerAddedConnection then
                    Connections.Visuals.TracersPlayerAddedConnection:Disconnect()
                    Connections.Visuals.TracersPlayerAddedConnection = nil
                end
                if Connections.Visuals.TracersPlayerRemovingConnection then
                    Connections.Visuals.TracersPlayerRemovingConnection:Disconnect()
                    Connections.Visuals.TracersPlayerRemovingConnection = nil
                end
                for i, v in pairs(Connections.Visuals.PlayerTracerConnections) do
                    v:Disconnect()
                    v = nil
                end
                PlayerTracersHolder:ClearAllChildren()
            end
        end,
    })
end

PlayerTracersXPosSlider = TogglePlayerTracers:CreateSlider({
    Text = "Tracer X From",
    Min = 0,
    Default = PlayerTracersPosition.X,
    Max = 1920,
    Function = function(Val)
        PlayerTracersPosition = Vector2.new(Val, PlayerTracersPosition.Y)
    end,
    Function2 = function(Val)
        PlayerTracersPosition = Vector2.new(Val, PlayerTracersPosition.Y)
    end,
})

PlayerTracersYPosSlider = TogglePlayerTracers:CreateSlider({
    Text = "Tracers Y From",
    Min = 0,
    Default = PlayerTracersPosition.Y,
    Max = 1080,
    Function = function(Val)
        PlayerTracersPosition = Vector2.new(PlayerTracersPosition.X, Val)
    end,
    Function2 = function(Val)
        PlayerTracersPosition = Vector2.new(PlayerTracersPosition.X, Val)
    end,
})

PlayerTracersThicknessSlider = TogglePlayerTracers:CreateSlider({
    Text = "Tracers Thickness",
    Min = 1,
    Default = 1,
    Max = 30,
    Function = function(Val)
        PlayerTracersThickness = Val
    end,
    Function2 = function(Val)
        PlayerTracersThickness = Val
    end,
})

PlayerTracersTeammateColorPicker = TogglePlayerTracers:CreateColorPicker({
    Text = "Tracers Teammate Color",
    Default = PlayerTracersTeammateColor,
    Function = function(Color)
        PlayerTracersTeammateColor = Color
    end,
})

PlayerTracersEnemyColorPicker = TogglePlayerTracers:CreateColorPicker({
    Text = "Tracers Enemy Color",
    Default = PlayerTracersEnemyColor,
    Function = function(Color)
        PlayerTracersEnemyColor = Color
    end,
})

ToggleAutomaticPlayerTracersColor = TogglePlayerTracers:CreateToggle({
    Text = "Automatic Tracer Color",
    Function = function(Bool)
        AutomaticPlayerTracersColor = Bool
    end,
})

do
    Connections.Visuals.TextEspConnections = {}

    ToggleHealthESP, ToggleNameESP, ToggleDistanceESP, ToggleWalkSpeedESP, ToggleJumpPowerESP = nil, nil, nil, nil, nil

    local function EspPlayer(Player)
        if Connections.Visuals.TextEspConnections[Player.Name] then return end
        local Text = Instance.new("TextLabel")
        Text.Name = `{Player.Name}_TextESP`
		Text.BackgroundTransparency = 1
		Text.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		Text.Text = ""
		Text.Size = UDim2.fromOffset(0, 0)
		Text.TextColor3 = Color3.fromRGB(255, 255, 255)
        Text.AnchorPoint = Vector2.new(0.5, 0.5)
		Text.Parent = DrawingFolder

        Connections.Visuals.TextEspConnections[Player.Name] = RunService.RenderStepped:Connect(function()
            local PlayerChar = GetChar(Player)
            local PlayerRoot = GetRoot(PlayerChar)
            local PlayerHumanoid = GetHumanoid(PlayerChar)
            local Char = GetChar(Plr)
            local Root = GetRoot(Char)

            if PlayerChar and PlayerRoot and PlayerHumanoid and PlayerHumanoid.Health > 0 and Char and Root then
                local Vector, OnScreen = Camera:WorldToViewportPoint(PlayerRoot.Position)
                if OnScreen then
                    Text.Position = UDim2.fromOffset(Vector.X, Vector.Y)
                    if ToggleAutomaticPlayerEspTextColor then
                        Text.TextColor3 = GetTeamColor(Player)
                    else
                        if IsTeammate(Player) then
                            Text.TextColor3 = EspTeammateTextColor
                        else
                            Text.TextColor3 = EspEnemyTextColor
                        end
                    end
                    
                    Text.TextSize = PlayerEspTextSize
                    Text.Text = ""
                    
                    ------------------------------------------------- Global ----------------------------------------------

                    if ToggleWalkSpeedESP.Enabled then
                        Text.Text = `{Text.Text}Speed: {PlayerHumanoid.WalkSpeed}\n`
                    end
                    if ToggleJumpPowerESP.Enabled then
                        Text.Text = `{Text.Text}Jump Power: {PlayerHumanoid.JumpPower}\n`
                    end
                    if ToggleNameESP.Enabled then
                        Text.Text = `{Text.Text}@{Player.Name} | {Player.DisplayName}\n`
                    end
                    if ToggleDistanceESP.Enabled then
                        Text.Text = `{Text.Text}Distance: {SubstituteNumber((Root.Position - PlayerRoot.Position).Magnitude, 3)}\n`
                    end
                    local Health = Player:GetAttribute("Health") or PlayerHumanoid.Health or 0
                    if ToggleHealthESP.Enabled then
                        Text.Text = `{Text.Text}Health: {SubstituteNumber(Health, 3)}\n`
                    end

                    ------------------------------------------------- Skywars ----------------------------------------------

                    if IsSkywars then
                        local Kills = Player:GetAttribute("Kills") or 0
                        if KillESP then
                            Text.Text = `{Text.Text}Kills: {Kills}\n`
                        end
                        local Level = Player:GetAttribute("Level") or 1
                        if LevelESP then
                            Text.Text = `{Text.Text}Level: {Level}\n`
                        end
                        local Wins = Player:GetAttribute("Wins") or 0
                        if WinsESP then
                            Text.Text = `{Text.Text}Wins: {Wins}\n`
                        end
                        local WinStreak = Player:GetAttribute("WinStreak") or 0
                        if WinStreakESP then
                            Text.Text = `{Text.Text}Win Streak: {WinStreak}\n`
                        end
                        local Rank = Player:GetAttribute("Rank")
                        if RankESP then
                            Text.Text = `{Text.Text}Rank: {Rank}\n`
                        end
                        local Title = Player:GetAttribute("Title")
                        if TitleESP then
                            Text.Text = `{Text.Text}Title: {Title}\n`
                        end
                        local Helmet = Player:GetAttribute("Helmet")
                        if HelmetESP then
                            Text.Text = `{Text.Text}Helmet: {Helmet}\n`
                        end
                        local Chestplate = Player:GetAttribute("Chestplate")
                        if ChestplateESP then
                            Text.Text = `{Text.Text}Chestplate: {Chestplate}\n`
                        end
                        local Leggings = Player:GetAttribute("Leggings")
                        if LeggingESP then
                            Text.Text = `{Text.Text}Leggings: {Leggings}`
                        end
                    end

                    if Text.Text ~= "" then
                        Text.Visible = true
                    else
                        Text.Visible = false
                    end
                else
                    Text.Visible = false
                end
            else
                Text.Visible = false
            end
        end)
    end

    PlayerEspTextSizeSlider = CreateSlider({
        Text = "Text Size",
        Min = 0,
        Default = PlayerEspTextSize,
        Max = 100,
        ModuleName = "PlayerEsp",
        Function = function(Val)
            PlayerEspTextSize = Val
        end,
        Function2 = function(Val)
            PlayerEspTextSize = Val
        end,
    })

    ToggleAutomaticPlayerEspTextColor = CreateToggle({
        Text = "Automatic Text Color",
    })

    local function UpdateTextEsp()
        if ToggleHealthESP.Enabled or ToggleNameESP.Enabled or ToggleDistanceESP.Enabled or ToggleWalkSpeedESP.Enabled or ToggleJumpPowerESP.Enabled then
            for i, Player in ipairs(Players:GetPlayers()) do
                if Player == Plr or Player.UserId == Plr.UserId then continue end
                EspPlayer(Player)
            end
            Connections.Visuals.TextEspPlayerAddedConnection = Players.PlayerAdded:Connect(EspPlayer)
            Connections.Visuals.TextEspPlayerRemovingConnection = Players.PlayerRemoving:Connect(function(Player)
                if Connections.Visuals.TextEspConnections[Player.Name] then
                    Connections.Visuals.TextEspConnections[Player.Name]:Disconnect()
                    Connections.Visuals.TextEspConnections[Player.Name] = nil
                end
                local FoundTracer = EspFolder:FindFirstChild(`{Player.Name}_TextESP`)
                if FoundTracer then
                    FoundTracer:Destroy()
                end
            end)
        else
            for i, v in pairs(Connections.Visuals.TextEspConnections) do
                v:Disconnect()
                v = nil
            end
            if Connections.Visuals.TextEspPlayerAddedConnection then
                Connections.Visuals.TextEspPlayerAddedConnection:Disconnect()
                Connections.Visuals.TextEspPlayerAddedConnection = nil
            end
            if Connections.Visuals.TextEspPlayerRemovingConnection then
                Connections.Visuals.TextEspPlayerRemovingConnection:Disconnect()
                Connections.Visuals.TextEspPlayerRemovingConnection = nil
            end
            for i, v in ipairs(EspFolder:GetChildren()) do
                if v.Name:find("_TextESP") then
                    v:Destroy()
                end
            end
        end
    end

    ToggleHealthESP = Visuals:CreateToggle({
        Text = "Health ESP",
        Info = "Shows Players Health.",
        Function = function(Bool)
            HealthESP = Bool
            UpdateTextEsp()
        end,
        Function2 = function()
            PlayerEspTextSizeSlider.Visible = true
            ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
        end,
    })

    ToggleNameESP = Visuals:CreateToggle({
        Text = "Name ESP",
        Info = "Shows Players Names.",
        Function = function(Bool)
            NameESP = Bool
            UpdateTextEsp()
        end,
        Function2 = function()
            PlayerEspTextSizeSlider.Visible = true
        end
    })

    ToggleDistanceESP = Visuals:CreateToggle({
        Text = "Distance ESP",
        Info = "Shows The Distance Between You And Players",
        Function = function(Bool)
            DistanceESP = Bool
            UpdateTextEsp()
        end,
        Function2 = function()
            PlayerEspTextSizeSlider.Visible = true
            ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
        end
    })

    ToggleWalkSpeedESP = Visuals:CreateToggle({
        Text = "Speed ESP",
        Info = "Shows Players Walk Speed",
        Function = function(Bool)
            WalkSpeedESP = Bool
            UpdateTextEsp()
        end,
        Function2 = function()
            PlayerEspTextSizeSlider.Visible = true
            ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
        end
    })

    ToggleJumpPowerESP = Visuals:CreateToggle({
        Text = "Jump Power ESP",
        Info = "Shows Players Jump Power",
        Function = function(Bool)
            JumpPowerESP = Bool
            UpdateTextEsp()
        end,
        Function2 = function()
            PlayerEspTextSizeSlider.Visible = true
            ToggleAutomaticPlayerEspTextColor.MainFrame.Visible = true
        end
    })
end

do
    Connections.Visuals.PlayerDrawingEspConnections = {}

    local PlayerDrawingEspFolder = Instance.new("Folder")
    PlayerDrawingEspFolder.Name = "PlayerDrawingEsp"
    PlayerDrawingEspFolder.Parent = EspFolder

    ToggleAutomaticPlayerDrawingEspColor = nil
    TogglePlayerDrawingEspFilled = nil

    local function EspPlayer(Player)
        if Player == Plr or Player.UserId == Plr.UserId then return end
        local Frame = Instance.new("Frame")
        Frame.BackgroundTransparency = 1
        Frame.BorderSizePixel = 0
        Frame.AnchorPoint = Vector2.new(0.5, 0.5)
        Frame.Name = Player.Name
        Frame.Parent = PlayerDrawingEspFolder
        local UIStroke = Instance.new("UIStroke")
        UIStroke.Thickness = 1
        UIStroke.Parent = Frame
        Connections.Visuals.PlayerDrawingEspConnections[Plr.UserId] = RunService.RenderStepped:Connect(function()
            local Char = GetChar(Plr)
            local Root = GetRoot(Char)
            local PlayerChar = GetChar(Player)
            local PlayerRoot = GetRoot(PlayerChar)
            if not (Char and Root and PlayerChar and PlayerRoot) then Frame.Visible = false; UIStroke.Enabled = false; return end
            local Vector, OnScreen = Camera:WorldToViewportPoint(PlayerRoot.Position)
            local HeadPos = Camera:WorldToViewportPoint(PlayerRoot.Position + Vector3.new(0, 1, 0))
            local LegPos = Camera:WorldToViewportPoint(PlayerRoot.Position + Vector3.new(0, -4, 0))
            if OnScreen then
                Frame.Position = UDim2.fromOffset(Vector.X, Vector.Y)
                Frame.Size = UDim2.fromOffset((PlayerDrawingEspSize.X / Vector.Z), (HeadPos.Y - LegPos.Y) - PlayerDrawingEspSize.Y)
                Frame.BackgroundColor3 = if ToggleAutomaticPlayerDrawingEspColor.Enabled then GetTeamColor(Player) elseif IsTeammate(Player) then PlayerDrawingEspTeammateOutlineColor else PlayerDrawingEspEnemyOutlineColor
                UIStroke.Color = if ToggleAutomaticPlayerDrawingEspColor.Enabled then GetTeamColor(Player) elseif IsTeammate(Player) then PlayerDrawingEspTeammateOutlineColor else PlayerDrawingEspEnemyOutlineColor
                Frame.BackgroundTransparency = if TogglePlayerDrawingEspFilled.Enabled then 0 else 1
                Frame.Visible = true
                UIStroke.Enabled = true
            else
                UIStroke.Enabled = false
                Frame.Visible = false
            end
        end)
    end
    
    TogglePlayerDrawingESP = Visuals:CreateToggle({
        Text = "Player Drawing ESP",
        Info = "Creates ESP Using Frames",
        Function = function(PlayerDrawingESP)
            if PlayerDrawingESP then
                for i, Player in ipairs(Players:GetPlayers()) do
                    EspPlayer(Player)
                end
                Connections.Visuals.PlayerDrawingEspPlayerAddedConnection = Players.PlayerAdded:Connect(EspPlayer)
                Connections.Visuals.PlayerDrawingEspPlayerRemoving = Players.PlayerRemoving:Connect(function(Player)
                    if Connections.Visuals.PlayerDrawingEspConnections[Player.UserId] then
                        Connections.Visuals.PlayerDrawingEspConnections[Player.UserId]:Disconnect()
                        Connections.Visuals.PlayerDrawingEspConnections[Player.UserId] = nil
                    end
                    local FoundFrame = PlayerDrawingEspFolder:FindFirstChild(Player.Name)
                    if FoundFrame then
                        FoundFrame:Destroy()
                    end
                end)
            else
                for i, v in ipairs(PlayerDrawingEspFolder:GetChildren()) do
                    v:Destroy()
                end
                for i, v in pairs(Connections.Visuals.PlayerDrawingEspConnections) do
                    v:Disconnect()
                    v = nil
                end
            end
        end,
    })
end

PlayerDrawingEspThicknessSlider = TogglePlayerDrawingESP:CreateSlider({
    Text = "Thickness",
    Min = 1,
    Default = 1,
    Max = 100,
    Function = function(Val)
        PlayerDrawingEspThickness = Val
    end,
    Function2 = function(Val)
        PlayerDrawingEspThickness = Val
    end,
})

TogglePlayerDrawingESP:CreateColorPicker({
    Text = "Teammate Outline Color",
    Default = PlayerDrawingEspTeammateOutlineColor,
    Function = function(Color)
        PlayerDrawingEspTeammateOutlineColor = Color
    end,
})

TogglePlayerDrawingESP:CreateColorPicker({
    Text = "Teammate Fill Color",
    Default = PlayerDrawingEspTeammateFillColor,
    Function = function(Color)
        PlayerDrawingEspTeammateFillColor = Color
    end,
})

TogglePlayerDrawingESP:CreateColorPicker({
    Text = "Enemy Outline Color",
    Default = PlayerDrawingEspEnemyOutlineColor,
    Function = function(Color)
        PlayerDrawingEspEnemyOutlineColor = Color
    end,
})

TogglePlayerDrawingESP:CreateColorPicker({
    Text = "Enemy Fill Color",
    Default = PlayerDrawingEspEnemyFillColor,
    Function = function(Color)
        PlayerDrawingEspEnemyFillColor = Color
    end,
})

ToggleAutomaticPlayerDrawingEspColor = TogglePlayerDrawingESP:CreateToggle({
    Text = "Automatic Color",
    Function = function(Bool)
    end,
})

TogglePlayerDrawingEspFilled = TogglePlayerDrawingESP:CreateToggle({
    Text = "Box Filled",
    Function = function(Bool)
    end,
})

PlayerDrawingEspSizeXSlider = TogglePlayerDrawingESP:CreateSlider({
    Text = "Box Size X",
    Min = 0,
    Default = PlayerDrawingEspSize.X,
    Max = 3000,
    Function = function(Val)
        PlayerDrawingEspSize = Vector2.new(Val, PlayerDrawingEspSize.Y)
    end,
    Function2 = function(Val)
        PlayerDrawingEspSize = Vector2.new(Val, PlayerDrawingEspSize.Y)
    end
})

PlayerDrawingEspSizeYSlider = TogglePlayerDrawingESP:CreateSlider({
    Text = "Box Size Y",
    Min = 0,
    Default = 0,
    Max = 300,
    Function = function(Val)
        PlayerDrawingEspSize = Vector2.new(PlayerDrawingEspSize.X, Val)
    end,
    Function2 = function(Val)
        PlayerDrawingEspSize = Vector2.new(PlayerDrawingEspSize.X, Val)
    end
})

do
    local Highlights = {}
	Connections.Visuals.PartEspHighlightDestroyed = {}

	local function HighlightPart(Part)
		if PartEspHighlightMode == "Highlight" then
			local Highlight = Instance.new("Highlight")
			Highlight.OutlineColor = PartEspOutlineColor
			Highlight.OutlineTransparency = PartEspOutlineTransparency
			Highlight.FillColor = PartEspFillColor
			Highlight.FillTransparency = PartEspFillTransparency
			Highlight.Adornee = Part
			Highlight.Name = Part.Name .. "_PartEspHighlight"
            Highlight.Parent = EspFolder
			Connections.Visuals.PartEspHighlightDestroyed[#Connections.Visuals.PartEspHighlightDestroyed + 1] = Part.Destroying:Once(function()
				local Index = table.find(Highlights, Highlight)
				if Index then
					table.remove(Highlights, Index)
				end
				Highlight:Destroy()
			end)
            table.insert(Highlights, Highlight)
		elseif PartEspHighlightMode == "BoxHandleAdornment" then
			local BoxHandleAdornment = Instance.new("BoxHandleAdornment")
			BoxHandleAdornment.Adornee = Part
			BoxHandleAdornment.AlwaysOnTop = true
			BoxHandleAdornment.ZIndex = 1
			BoxHandleAdornment.Size = Part.Size
			BoxHandleAdornment.Name = Part.Name .. "_PartEspBoxHandleAdornment"
			BoxHandleAdornment.Color3 = PartEspFillColor
			BoxHandleAdornment.Transparency = PartEspFillTransparency
            BoxHandleAdornment.Parent = EspFolder
			Part.Destroying:Once(function()
				BoxHandleAdornment:Destroy()
				local Index = table.find(Highlights, BoxHandleAdornment)
				if Index then
					table.remove(Highlights, Index)
				end
			end)
            table.insert(Highlights, BoxHandleAdornment)
		end
	end
	
	TogglePartESP = Visuals:CreateToggle({
		Text = "Part ESP",
		Info = "Adds Highlights To Parts",
		Function = function(PartESP)
			if PartESP then
				if PartEspMode == "Folder" and PartEspPath then
					Connections.Visuals.PartEspLoop = PartEspPath.ChildAdded:Connect(function(Child)
						if Child:IsA("BasePart") or Child:IsA("Model") then
							HighlightPart(Child)
						end
					end)
					for i, Part in ipairs(PartEspPath:GetDescendants()) do
						if Part:IsA("BasePart") or Part:IsA("Model") then
							HighlightPart(Part)
						end
					end
				elseif PartEspMode == "ExactName" then
					Connections.Visuals.PartEspLoop = workspace.DescendantAdded:Connect(function(Descendant)
						if PartEspMode == "ExactName" and PartEspName then
							local Char = GetChar(Plr)
							if Char and Descendant:FindFirstAncestor(Char.Name) then return end
							if string.lower(Descendant.Name) == PartEspName and Descendant:IsA("BasePart") or Descendant:IsA("Model") then
								HighlightPart(Descendant)
							end
						end
					end)
					local Char = GetChar(Plr)
					for i, Part in ipairs(workspace:GetDescendants()) do
						if Char and Part:FindFirstAncestor(Char.Name) then continue end
                        local Name = string.lower(Part.Name)
						if Name == PartEspName and (Part:IsA("BasePart") or Part:IsA("Model")) then
							HighlightPart(Part)
						end
					end
				elseif PartEspMode == "ContainsString" and PartEspName then
					Connections.Visuals.PartEspLoop = workspace.DescendantAdded:Connect(function(Descendant)
						local Char = GetChar(Plr)
						if Char and Descendant:FindFirstAncestor(Char.Name) then return end
						local Name = string.lower(Descendant.Name)
						if (string.find(Name, PartEspName) or string.find(PartEspName, Name)) and (Descendant:IsA("BasePart") or Descendant:IsA("Model")) then
							HighlightPart(Descendant)
						end
					end)
					local Char = GetChar(Plr)
					for i, Part in ipairs(workspace:GetDescendants()) do
						if Char and Part:FindFirstAncestor(Char.Name) then continue end
                        local Name = string.lower(Part.Name)
						if (string.find(Name, PartEspName) or string.find(PartEspName, Name)) and (Part:IsA("BasePart") or Part:IsA("Model")) then
							HighlightPart(Part)
						end
					end
				end
			else
				if Connections.Visuals.PartEspLoop then
					Connections.Visuals.PartEspLoop:Disconnect()
                    Connections.Visuals.PartEspLoop = nil
				end
				for i, v in ipairs(Connections.Visuals.PartEspHighlightDestroyed) do
					v:Disconnect()
				end
				table.clear(Connections.Visuals.PartEspHighlightDestroyed)
				for i, v in ipairs(Highlights) do
					v:Destroy()
				end
                table.clear(Highlights)
			end
		end,
	})

    local function UpdatePartEsp()
        for i, v in ipairs(Highlights) do
            if v:IsA("Highlight") then
                v.FillColor = PartEspFillColor
                v.OutlineColor = PartEspOutlineColor
                v.FillTransparency = PartEspFillTransparency
                v.OutlineTransparency = PartEspOutlineTransparency
            elseif v:IsA("BoxHandleAdornment") then
                v.Transparency = PartEspFillTransparency
                v.Color3 = PartEspFillColor
            end
        end
    end
	
    PartEspFillColorPicker = TogglePartESP:CreateColorPicker({
        Text = "Part ESP Fill Color",
        Default = PartEspFillColor,
        Function = function(Color)
            PartEspFillColor = Color
            UpdatePartEsp()
        end,
    })

    PartEspOutlineColorPicker = TogglePartESP:CreateColorPicker({
        Text = "Part ESP Outline Color",
        Default = PartEspOutlineColor,
        Function = function(Color)
            PartEspOutlineColor = Color
            UpdatePartEsp()
        end,
    })
    
    PartEspFillTransparencySlider = TogglePartESP:CreateSlider({
        Text = "Part ESP Fill Transparency",
        Min = 0,
        Default = 1,
        Max = 1,
        Function = function(Val)
            PartEspFillTransparency = Val
            UpdatePartEsp()
        end,
        Function2 = function(Val)
            PartEspFillTransparency = Val
            UpdatePartEsp()
        end,
    })

    PartEspOutlineTransparencySlider = TogglePartESP:CreateSlider({
        Text = "Part ESP Outline Transparency",
        Min = 0,
        Default = 0,
        Max = 1,
        Function = function(Val)
            PartEspOutlineTransparency = Val
            UpdatePartEsp()
        end,
        Function2 = function(Val)
            PartEspOutlineTransparency = Val
            UpdatePartEsp()
        end,
    })

    local PartEspModeDropdown = TogglePartESP:CreateDropdown({
        Text = "Part ESP Mode",
        Default = "Folder",
        AutoUpdateText = true,
    })
    PartEspModeDropdown:CreateButton({
        Text = "Folder",
        Function = function()
            PartEspMode = "Folder"
        end,
    })
    PartEspModeDropdown:CreateButton({
        Text = "Exact Name",
        Function = function()
            PartEspMode = "ExactName"
        end,
    })
    PartEspModeDropdown:CreateButton({
        Text = "Contains String",
        Function = function()
            PartEspMode = "ContainsString"
        end,
    })

    local PartEspHighlightModeDropdown = TogglePartESP:CreateDropdown({
        Text = "Part ESP Highlight Mode",
        Default = "Highlight",
        AutoUpdateText = true,
    })
    PartEspHighlightModeDropdown:CreateButton({
        Text = "Highlight",
        Function = function()
            PartEspHighlightMode = "Highlight"
        end,
    })
    PartEspHighlightModeDropdown:CreateButton({
        Text = "Box Handle Adornment",
        Function = function()
            PartEspHighlightMode = "BoxHandleAdornment"
        end,
    })

    TogglePartESP:CreateTextbox({
        ButtonText = "Part ESP Path",
        PlaceholderText = "[Path]",
        Info = "Enter A Folder To Loop Through",
        MouseButton1Click = function()
			local LoadedString = loadstring(`return {TogglePartESP.Textbox.Text}`)
			if typeof(LoadedString) == "function" then
				PartEspPath = LoadedString()
				Notify({
					Text = `Set PartEspPath To {GetFullName(PartEspPath)}`
				})
			else
				Notify(LoadedString)
			end
        end,
    })

    TogglePartESP:CreateTextbox({
        ButtonText = "Part ESP Name",
        PlaceholderText = "[Part Name]",
        Info = "Adds Highlight To All Parts That Have The Name Of The Specified String",
        FocusLost = function()
            PartEspName = string.lower(TogglePartESP.Textbox.Text)
        end,
    })
end

ToggleNoRender = Visuals:CreateToggle({
	Text = "No Render",
	Info = "Removes 3D Rendering",
	MouseButton1Click = function(Bool)
		pcall(function()
			RunService:Set3dRenderingEnabled(not Bool)
		end)
	end,
})

Toggle2022Materials = Visuals:CreateToggle({
	Text = "2022 Materials",
	Info = "Changes The Materials To 2022 Materials",
	MouseButton1Click = function(Material2022)
		if not SetHidden then NotifyExploitDoesntSupportFunction("SetHiddenProperty"); return end
		SetHidden(MaterialService, "Use2022Materials", Material2022)
	end,
})

TogglePruchasePrompts = Visuals:CreateToggle({
	Text = "No Purchase Prompts",
	Info = "Turns On/Off Purchase Prompts",
	MouseButton1Click = function(NoPurchasePrompts)
		pcall(function()
			CoreGui.PurchasePromptApp.Enabled = not NoPurchasePrompts
		end)
	end,
})

do
	local ShownParts = {}

	ToggleInvisibleParts = Visuals:CreateToggle({
		Text = "Invisible Parts",
		Info = "Shows Invisible Parts",
		MouseButton1Click = function(InvisPartsEnabled)
			if InvisPartsEnabled then
				for i, v in ipairs(workspace:GetDescendants()) do
					if v:IsA("BasePart") and v.Transparency == 1 then
						if not table.find(ShownParts, v) then
							table.insert(ShownParts, v)
						end
						v.Transparency = 0
					end
				end
			else
				for i, v in ipairs(ShownParts) do
					v.Transparency = 1
				end
			end
		end,
	})
end

do
    ToggleLoopFov = nil
    local function UpdateFov()
        if ToggleLoopFov.Enabled then
            Camera.FieldOfView = Fov
        end
	end
    
    ToggleLoopFov = Visuals:CreateToggle({
        Text = "Fov",
        Info = "Sets Fov To The Specified Value",
        Function = function(LoopFovEnabled)
            if LoopFovEnabled then
                Camera.FieldOfView = Fov
                Connections.Other.FovLoop = Camera:GetPropertyChangedSignal("FieldOfView"):Connect(function()
                    Camera.FieldOfView = Fov
                end)
            else
                if Connections.Other.FovLoop then
                    Connections.Other.FovLoop:Disconnect()
                end
            end
        end,
    })

    FieldOfViewSlider = ToggleLoopFov:CreateSlider({
        Text = "Fov",
        Min = 0,
        Default = 70,
        Max = 120,
        Function = function(Val)
            Fov = Val
            UpdateFov()
        end,
        Function2 = function(Val)
            Fov = Val
            UpdateFov()
        end,
    })
end

ToggleLoopCameraZoom = Visuals:CreateToggle({
	Text = "Camera Zoom",
	Info = "Loop Sets Camera Min Zoom And Max Zoom",
	Function = function(LoopCameraZoom)
		if LoopCameraZoom then
			Connections.Other.CameraMaxZoomLoop = Plr:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
				Plr.CameraMaxZoomDistance = MaxZoom
			end)
			Connections.Other.CameraMinZoomLoop = Plr:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(function()
				Plr.CameraMinZoomDistance = MinZoom
			end)
		else
			if Connections.Other.CameraMaxZoomLoop then
				Connections.Other.CameraMaxZoomLoop:Disconnect()
			end
			if Connections.Other.CameraMinZoomLoop then
				Connections.Other.CameraMinZoomLoop:Disconnect()
			end
		end
	end,
})

ToggleThirdPerson = nil

ToggleFirstPerson = Visuals:CreateToggle({
	Text = "First Person",
	Info = "Loop Sets Your Camera Mode To First Person",
	Function = function(FirstPerson)
		ToggleThirdPerson:Disable({NoNotify = true})
		if FirstPerson then
			Plr.CameraMode = Enum.CameraMode.LockFirstPerson
			Connections.Other.LoopFirstPerson = Plr:GetPropertyChangedSignal("CameraMode"):Connect(function()
				Plr.CameraMode = Enum.CameraMode.LockFirstPerson
			end)
		else
			if Connections.Other.LoopFirstPerson then
				Connections.Other.LoopFirstPerson:Disconnect()
			end
		end
	end,
})

ToggleThirdPerson = Visuals:CreateToggle({
	Text = "Third Person",
	Info = "Loop Sets Your Camera Mode To Third Person",
	Function = function(ThirdPerson)
		ToggleFirstPerson:Disable({NoNotify = true})
		if ThirdPerson then
			Plr.CameraMode = Enum.CameraMode.Classic
			Connections.Other.LoopThirdPerson = Plr:GetPropertyChangedSignal("CameraMode"):Connect(function()
				Plr.CameraMode = Enum.CameraMode.Classic
			end)
		else
			if Connections.Other.LoopThirdPerson then
				Connections.Other.LoopThirdPerson:Disconnect()
			end
		end
	end,
})

AntiLag = Visuals:CreateButton({
	Text = "Anti Lag",
	Info = "Removes Lots Of Different Things To Boost FPS",
	MouseButton1Click = function()
		local Terrain = workspace:FindFirstChildOfClass("Terrain")
        if Terrain then
            Terrain.WaterWaveSize = 0
            Terrain.WaterWaveSpeed = 0
            Terrain.WaterReflectance = 0
            Terrain.WaterTransparency = 0
        end
        ExecuteCMD("NoLightingEffects")
		for i, v in ipairs(game:GetDescendants()) do
			if v:IsA("BasePart") then
				v.Material = "Plastic"
				v.Reflectance = 0
			elseif v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ParticleEmitter") then
				v.Lifetime = NumberRange.new(0, 0)
			elseif v:IsA("Trail") then
				v.Lifetime = 0
			elseif v:IsA("Explosion") then
				v.BlastPressure = 1
				v.BlastRadius = 1
            elseif v:IsA("Sparkles") or v:IsA("Smoke") or v:IsA("Fire") then
                v.Enabled = false
            elseif v:IsA("ForceField") then
                v.Visible = false
			end
		end
		Connections.Visuals.AntiLagDescendantAddedConnection = workspace.DescendantAdded:Connect(function(Child)
			if Child:IsA("Sparkles") or Child:IsA("Smoke") or Child:IsA("Fire") then
                RunService.Heartbeat:Wait()
                Child.Enabled = false
            elseif Child:IsA("ForceField") then
                RunService.Heartbeat:Wait()
                Child.Visible = false
            end
		end)
	end,
})

----------------------------------------------------------------------------------------------------- World Category

NoClickDetectorLimits = WorldCategory:CreateButton({
	Text = "No Click Detector Limits",
	Info = "Allows You To Activate Click Detectors From Any Distance (Unless The Game Actually Does Checks)",
	Function = function()
		for i, CD in pairs(workspace:GetDescendants()) do
			if CD:IsA("ClickDetector") then
				CD.MaxActivationDistance = math.huge
			end
		end
	end,
})

FireClickDetectors = WorldCategory:CreateButton({
	Text = "Fire Click Detectors",
	Info = 'Fires All Click Detectors (Requires "FireClickDetector" Function)',
	Function = function()
		if FireClickDetector then
			for i, CD in pairs(workspace:GetDescendants()) do
				if CD:IsA("ClickDetector") then
					FireClickDetector(CD)
				end
			end
		else
			NotifyExploitDoesntSupportFunction("FireClickDetector")
		end
	end,
})

NoProximityPromptLimits = WorldCategory:CreateButton({
	Text = "No Proximity Prompt Limits",
	Info = "Allows You To Activate Proximity Prompts From Any Distance (Unless The Game Actually Does Checks)",
	Function = function()
		for i, Prox in pairs(workspace:GetDescendants()) do
			if Prox:IsA("ProximityPrompt") then
				Prox.MaxActivationDistance = math.huge
			end
		end
	end,
})

FireProximityPrompts = WorldCategory:CreateButton({
	Text = "Fire Proximity Prompts",
	Info = 'Fires All Proximity Prompts (Requires "FireProximityPrompts" Function)',
	Function = function()
		if FireProximityPrompt then
			for i, Prox in pairs(workspace:GetDescendants()) do
				if Prox:IsA("ProximityPrompt") then
					FireProximityPrompt(Prox)
				end
			end
		else
			NotifyExploitDoesntSupportFunction("FireProximityPrompts")
		end
	end,
})

ToggleInstantProximityPrompts = WorldCategory:CreateToggle({
	Text = "Instant Proximity Prompts",
	Info = "Instantly Activates Proximity Prompts",
	Function = function(InstantProximityPrompts)
        if not FireProximityPrompt then NotifyExploitDoesntSupportFunction("FireProximityPrompts"); return end
		if InstantProximityPrompts then
            Connections.World.InstantProximityPromptConnection = ProximityPromptService.PromptButtonHoldBegan:Connect(function(Prompt)
                FireProximityPrompt(Prompt)
            end)
        else
            if Connections.World.InstantProximityPromptConnection then
                Connections.World.InstantProximityPromptConnection:Disconnect()
            end
        end
	end,
})

FireTouchInterests = WorldCategory:CreateButton({
	Text = "Fire Touch Interests",
	Info = "Fires All Touch Interests",
	MouseButton1Click = function()
		if not FireTouchInterest then NotifyExploitDoesntSupportFunction("FireTouchInterest"); return end
		local Char = GetChar(Plr)
		local Root = GetRoot(Char)
		for i, Part in pairs(workspace:GetDescendants()) do
            if Part:IsA("BasePart") and Char and Root then
                FireTouchInterest(Part, Root, 0)
                FireTouchInterest(Part, Root, 1)
                task.wait()
            end
		end
	end,
})

do
    XrayParts = {}
    
    ToggleXray = WorldCategory:CreateToggle({
        Text = "Xray",
        Info = "Guys I Just Did Some Off Camera Mining",
        Function = function(Xray)
            if Xray then
                for i, Part in pairs(workspace:GetDescendants()) do
                    if not Part:IsA("BasePart") or Part:FindFirstAncestorOfClass("Model") and Players:GetPlayerFromCharacter(Part:FindFirstAncestorOfClass("Model")) then continue end
                    Part.LocalTransparencyModifier = 0.5
                    table.insert(XrayParts, Part)
                end
            else
                for i, Part in pairs(XrayParts) do
                    Part.LocalTransparencyModifier = 0
                end
                table.clear(XrayParts)
            end
        end,
    })
end

do
    local VehicleNoclipParts = {}

    ToggleVehicleNoclip = WorldCategory:CreateToggle({
        Text = "Vehicle Noclip",
        Info = "Make Car Have Not Collide",
        Function = function(VehicleNoclip)
            if VehicleNoclip then
                local Char = GetChar(Plr)
                local Humanoid = GetHumanoid(Char)
                if not (Char and Humanoid and Humanoid.SeatPart and Humanoid.SeatPart.Parent) then return end
                local Seat = Humanoid.SeatPart
                local VehicleModel = Seat.Parent
                ToggleNoclip:Enable({NoNotify = true})
                repeat
                    if VehicleModel.ClassName ~= "Model" then
                        VehicleModel = VehicleModel.Parent
                    end
                until VehicleModel.ClassName == "Model"
                task.wait()
                for i, v in ipairs(VehicleModel:GetDescendants()) do
                    if v:IsA("BasePart") and v.CanCollide then
                        v.CanCollide = false
                        table.insert(VehicleNoclipParts, v)
                    end
                end
                Connections.World.VehicleNoclipLoop = RunService.Stepped:Connect(function()
                    for i, v in ipairs(VehicleNoclipParts) do
                        v.CanCollide = false
                    end
                end)
            else
                if Connections.World.VehicleNoclipLoop then
                    Connections.World.VehicleNoclipLoop:Disconnect()
                    Connections.World.VehicleNoclipLoop = nil
                end
                for i, v in ipairs(VehicleNoclipParts) do
                    v.CanCollide = true
                end
                table.clear(VehicleNoclipParts)
            end
        end,
    })
end

ToggleClickPartToSelect = WorldCategory:CreateToggle({
	Text = "Click Part To Select",
	Info = 'Part Path Will Be Copied To Clipboard But Only If Your Exploit Supports "SetClipboard" And It Will Also Be Printed Into The Console',
	Function = function(Bool)
		ClickPartToSelect = Bool
        if not ClickPartToSelect then
            ClickPartToSelectOutline.Adornee = nil
        end
	end,
})

do
    local Vel = 0
    ToggleAntiVoid = WorldCategory:CreateToggle({
        Text = "Anti Void",
        Info = "Prevents You From Falling In The Void",
        Function = function(AntiVoid)
            if AntiVoid then
                Connections.World.AntiVoidLoop = RunService.Stepped:Connect(function()
                    local Char = GetChar(Plr)
                    local Root = GetRoot(Char)
                    if not (Char and Root) then return end
                    if Root.Position.Y <= workspace.FallenPartsDestroyHeight + 25 then
                        Root.AssemblyLinearVelocity += Vector3.new(0, Vel + 25, 0)
                    end
                    RunService.Heartbeat:Wait()
                    if not Root then return end
                    Vel = Root.AssemblyLinearVelocity.Y * -1
                end)
            else
                if Connections.World.AntiVoidLoop then
                    Connections.World.AntiVoidLoop:Disconnect()
                    Connections.World.AntiVoidLoop = nil
                end
            end
        end,
    })
end

ToggleClickDeleteIgnorePlayer = nil

ToggleClickDelete = WorldCategory:CreateToggle({
	Text = "Click Delete",
	Info = "Deletes Parts When You Hold You Binded Key Down And Click",
	Function = function(Bool)
		ClickDelete = Bool
	end,
	Function2 = function()
		ToggleClickDeleteIgnorePlayer.MainFrame.Visible = true
	end,
})

ToggleClickDeleteIgnorePlayer = CreateToggle({
	Text = "Ignore Player",
	Info = "Ignores The Player You Clicked On",
	Function = function(Bool)
		ClickDeleteIgnorePlayer = Bool
	end,
})

do
	local Limbs = {
		"Head",
		"Torso",
		"LowerTorso",
		"UpperRightArm",
		"Right Arm",
		"LowerRightArm",
		"UpperLeftArm",
		"LowerLeftArm",
		"Left Arm",
		"UpperRightLeg",
		"LowerRightLeg",
		"Right Leg",
		"UpperLeftLeg",
		"LowerLeftLeg",
		"Left Leg",
		"HumanoidRootPart",
	}

	local function ClearAllBodyGyros(Part)
		for i, v in pairs(Part:GetChildren()) do
			if v:IsA("BodyGyro") or v:IsA("BodyPosition") then
				v:Destroy()
			end
		end
	end

	TeleportUnAchored = nil; TeleportUnAchored = WorldCategory:CreateTextbox({
		ButtonText = "Tpua",
		PlaceholderText = "[Player]",
		Info = "Teleports un-anchored parts to the specified player. Leave blank to teleport the parts to yourself. you must be the network owner of the part you're trying to teleport or it wont work.",
		MouseButton1Click = function()
			local Char = GetChar(Plr)
			local Root = GetRoot(Char)
			for i, Part in pairs(workspace:GetDescendants()) do
				if not (Part:IsA("BasePart") and Char and Root) or Part.Anchored or Part:IsDescendantOf(Char) or table.find(Limbs, Part.Name) then continue end
				ClearAllBodyGyros(Part)
				local ForceInstance = Instance.new("BodyPosition")
				ForceInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                ForceInstance.Parent = Part
				local Player = FindPlayer(TeleportUnAchored.Textbox.Text)
				local PlayerChar = GetChar(Player)
				local PlayerRoot = GetRoot(PlayerChar)
				if Player and PlayerChar and PlayerRoot then
					ForceInstance.Position = PlayerRoot.Position
				else
					ForceInstance.Position = Root.Position
				end
			end
		end,
	})
end

----------------------------------------------------------------------------------------------------- Creating Buttons In Other Category

RunInfiniteYield = Other:CreateButton({
	Text = "Infinite Yield",
	MouseButton1Click = function()
		if not HttpGet then NotifyExploitDoesntSupportFunction("HttpGet"); return end
        local InfiniteYieldScript = HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source")
		if typeof(InfiniteYieldScript) == "string" then
            local InfiniteYieldFunction = Loadstring(InfiniteYieldScript)
            if typeof(InfiniteYieldFunction) == "function" then
                InfiniteYieldFunction()
            else
                Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to load infinite yield.", Duration = 5})
            end
		else
			Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to get infinite yield.", Duration = 5})
		end
	end,
})

RunDex = Other:CreateButton({
	Text = "Dex",
	MouseButton1Click = function()
        if not HttpGet then NotifyExploitDoesntSupportFunction("HttpGet"); return end
        local DexScript = HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/dex.lua")
		if typeof(DexScript) == "string" then
            local DexFunction = Loadstring(DexScript)
            if typeof(DexFunction) == "function" then
                DexFunction()
            else
                Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to load dex.", Duration = 5})
            end
		else
			Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to get dex.", Duration = 5})
		end
	end,
})

RunRemoteSpy = Other:CreateButton({
	Text = "Remote Spy",
	MouseButton1Click = function()
        if not HttpGet then NotifyExploitDoesntSupportFunction("HttpGet"); return end
        local RemoteSpyScript = HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/SimpleSpyV3/main.lua")
		if typeof(RemoteSpyScript) == "string" then
            local RemoteSpyFunction = Loadstring(RemoteSpyScript)
            if typeof(RemoteSpyFunction) == "function" then
                RemoteSpyFunction()
            else
                Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to load remote spy.", Duration = 5})
            end
		else
			Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to get remote spy.", Duration = 5})
		end
	end,
})

RunSigmaSpy = Other:CreateButton({
	Text = "Sigma Spy",
	MouseButton1Click = function()
		if not HttpGet then NotifyExploitDoesntSupportFunction("HttpGet"); return end
        local SigmaSpyScript = HttpGet("https://raw.githubusercontent.com/depthso/Sigma-Spy/refs/heads/main/Main.lua")
		if typeof(SigmaSpyScript) == "string" then
            local SigmaSpyFunction = Loadstring(SigmaSpyScript)
            if typeof(SigmaSpyFunction) == "function" then
                SigmaSpyFunction()
            else
                Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to load sigma spy.", Duration = 5})
            end
		else
			Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to get sigma spy.", Duration = 5})
		end
	end,
})

RunCobalt = Other:CreateButton({
	Text = "Cobalt",
	Info = "Remote spy but better.",
	MouseButton1Click = function()
		if not HttpGet then NotifyExploitDoesntSupportFunction("HttpGet"); return end
        local CobaltScript = HttpGet("https://github.com/notpoiu/cobalt/releases/latest/download/Cobalt.luau")
		if typeof(CobaltScript) == "string" then
            local CobaltFunction = Loadstring(CobaltScript)
            if typeof(CobaltFunction) == "function" then
                CobaltFunction()
            else
                Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to load cobalt.", Duration = 5})
            end
		else
			Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to get cobalt.", Duration = 5})
		end
	end,
})

RunAudioLogger = Other:CreateButton({
	Text = "Audio Logger",
    Info = "It logs audio.",
	MouseButton1Click = function()
		if not HttpGet then NotifyExploitDoesntSupportFunction("HttpGet"); return end
        local AudioLoggerScript = HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/audiologger.lua", true)
		if typeof(AudioLoggerScript) == "string" then
            local AudioLoggerFunction = Loadstring(AudioLoggerScript)
            if typeof(AudioLoggerFunction) == "function" then
                AudioLoggerFunction()
            else
                Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to load audio logger.", Duration = 5})
            end
		else
			Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to get audio logger.", Duration = 5})
		end
	end,
})

RunF3X = Other:CreateButton({
	Text = "F3X",
	MouseButton1Click = function()
		if not HttpGet then NotifyExploitDoesntSupportFunction("HttpGet"); return end
        local F3XScript = HttpGet("https://raw.githubusercontent.com/infyiff/backup/refs/heads/main/f3x.lua")
		if typeof(F3XScript) == "string" then
            local F3XFunction = Loadstring(F3XScript)
            if typeof(F3XFunction) == "function" then
                F3XFunction()
            else
                Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to load F3X.", Duration = 5})
            end
		else
			Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to get F3X.", Duration = 5})
		end
	end,
})

RunWallWalker = Other:CreateButton({
	Text = "Wall Walker",
	MouseButton1Click = function()
		if not HttpGet then NotifyExploitDoesntSupportFunction("HttpGet"); return end
        local WallWalkerScript = HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/wallwalker.lua")
		if typeof(WallWalkerScript) == "string" then
            local WallWalkerFunction = Loadstring(WallWalkerScript)
            if typeof(WallWalkerFunction) == "function" then
                WallWalkerFunction()
            else
                Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to load wall walker.", Duration = 5})
            end
		else
			Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to get wall walker.", Duration = 5})
		end
	end,
})

RunUNCTest = Other:CreateButton({
    Text = "UNC Test",
    Info = "Runs A UNC Test",
    MouseButton1Click = function()
		if not HttpGet then NotifyExploitDoesntSupportFunction("HttpGet"); return end
        local UNCTestScript = HttpGet("https://github.com/ltseverydayyou/uuuuuuu/blob/main/UNC%20test?raw=true")
		if typeof(UNCTestScript) == "string" then
            local UNCTestFunction = Loadstring(UNCTestScript)
            if typeof(UNCTestFunction) == "function" then
                UNCTestFunction()
            else
                Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to load UNC test.", Duration = 5})
            end
		else
			Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to get UNC test.", Duration = 5})
		end
    end,
})

RunSUNCTest = Other:CreateButton({
    Text = "SUNC Test",
    Info = "Runs An SUNC Test (takes you to a different game).",
    MouseButton1Click = function()
		if not HttpGet then NotifyExploitDoesntSupportFunction("HttpGet"); return end
        local SUNCTestScript = HttpGet("https://gitlab.com/sens3/nebunu/-/raw/main/HummingBird8's_sUNC_yes_i_moved_to_gitlab_because_my_github_acc_got_brickedd/sUNCm0m3n7.lua")
		if typeof(SUNCTestScript) == "string" then
            local SUNCTestFunction = Loadstring(SUNCTestScript)
            if typeof(SUNCTestFunction) == "function" then
                SUNCTestFunction()
            else
                Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to load SUNC test.", Duration = 5})
            end
		else
			Notify({Text = "<font color = 'rgb(255, 0, 0)'>Failed</font> to get SUNC test.", Duration = 5})
		end
    end,
})

Rejoin = Other:CreateButton({
	Text = "Rejoin",
	Info = "Makes you rejoin the server.",
	Function = function()
		if #Players:GetPlayers() <= 1 then
			Plr:Kick("\nRejoining...")
			task.wait()
			TeleportService:Teleport(game.PlaceId, Plr)
		else
			TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, Plr)
		end
	end,
})

ServerHop = Other:CreateButton({
	Text = "Server Hop",
	Info = "Sends you to a random server.",
	Function = function()
		if not HttpRequest then NotifyExploitDoesntSupportFunction("HttpRequest"); return end
		local Servers = {}
		local Request = HttpRequest({Url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100&excludeFullGames=true", game.PlaceId)})
		local Body = HttpService:JSONDecode(Request.Body)

		if Body and Body.data then
			for i, v in next, Body.data do
				if type(v) == "table" and tonumber(v.playing) and tonumber(v.maxPlayers) and v.playing < v.maxPlayers and v.id ~= game.JobId then
					table.insert(Servers, 1, v.id)
				end
			end
		end

		if #Servers > 0 then
            repeat

            until
			TeleportService:TeleportToPlaceInstance(game.PlaceId, Servers[math.random(1, #Servers)], Plr)
		else
			Notify({
				Text = "Couldnt Find A Server",
			})
		end
	end,
})

ToggleServerInfo = Other:CreateToggle({
	Text = "Server Info",
	Info = "Shows info about the server and your local player.",
	MouseButton1Click = function(Bool)
		ServerInfoMenu.MainFrame.Visible = Bool
        if Bool then
            Connections.TidalWave.ServerInfoDistributedGameTimeConnection = RunService.RenderStepped:Connect(function()
                DistributedGameTimeTextLabel.Btn.Text = `Distributed Game Time: {SubstituteNumber(time(), 3)}`
            end)
        else
            if Connections.TidalWave.ServerInfoDistributedGameTimeConnection then
                task.cancel(Connections.TidalWave.ServerInfoDistributedGameTimeConnection)
                Connections.TidalWave.ServerInfoDistributedGameTimeConnection = nil
            end
        end
	end,
})

do
    local Class = "RemoteEvent"

	local InstanceFinderMenu
    local ToggleInstanceFinder = Other:CreateToggle({
        Text = "Instance Finder",
        Info = "Finds Instances",
        MouseButton1Click = function(Bool)
            InstanceFinderMenu.MainFrame.Visible = Bool
            if InstanceFinderMenu.MainFrame.Visible then
                for i, v in ipairs(game:GetDescendants()) do
                    if v:IsA(Class) then
                        CreateButton({
                            Parent = InstanceFinderMenu.ScrollingFrame,
                            Text = GetFullName(v),
                            MouseButton1Click = function()
                                SetClipboard(GetFullName(v), "Copied full name to clipboard.")
                            end,
                        })
                    end
                end
            else
                for i, v in ipairs(InstanceFinderMenu.ScrollingFrame:GetChildren()) do
                    if v:IsA("TextButton") then
                        v:Destroy()
                    end
                end
            end
        end,
    })

	ToggleInstanceFinder:CreateTextbox({
        NoButton = true,
        Text = Class,
        PlaceholderText = "[ClassName]",
        FocusLost = function(Args)
            Class = Args.Text
        end,
    })

   	InstanceFinderMenu = CreateMenu({
        Text = "Instance Finder",
        OnClose = function()
            ToggleInstanceFinder:Disable()
            for i, v in ipairs(InstanceFinderMenu.ScrollingFrame:GetChildren()) do
                if v:GetAttribute("Button") then
                    v:Destroy()
                end
            end
        end,
    })
end

FPSCapTextbox = nil; FPSCapTextbox = Other:CreateTextbox({
	ButtonText = "FPS Cap",
	PlaceholderText = "[Number]",
    EnabledIndicator = true,
	Function = function(FPSCap)
        if FPSCap then
            local FPS = tonumber(FPSCapTextbox.Textbox.Text)
            if FPS then
                SetFPSCap(FPS)
            elseif FPSCapTextbox.Textbox.Text:lower() == "none" then
                SetFPSCap(1000000)
            else
                Notify({Text = 'Enter A Valid Number To Set The FPS Cap To Or Enter "None" For No FPS Cap'})
            end
        else
            if Connections.TidalWave.FPSCapLoop then
                task.cancel(Connections.TidalWave.FPSCapLoop)
                Connections.TidalWave.FPSCapLoop = nil
            end
        end
	end,
    FocusLost = function(Args)
        if Connections.TidalWave.FPSCapLoop then
            task.cancel(Connections.TidalWave.FPSCapLoop)
            Connections.TidalWave.FPSCapLoop = nil
            local FPS = tonumber(Args.Text)
            if FPS then
                SetFPSCap(FPS)
            elseif Args.Text:lower() == "none" then
                SetFPSCap(1000000)
            else
                Notify({Text = 'Enter A Valid Number To Set The FPS Cap To Or Enter "None" For No FPS Cap'})
            end
        end
    end,
})

ToggleViewPart = nil; ToggleViewPart = Other:CreateTextbox({
	TextLabelText = "View Part",
	PlaceholderText = "Part Name",
	EnabledIndicator = true,
	Function = function(ViewPart)
		if ViewPart then
            local Name = ToggleViewPart.Textbox.Text:lower()
			for i, v in pairs(workspace:GetDescendants()) do
				if v.Name:lower() == Name then
					Camera.CameraSubject = v
					break
				end
			end
		else
			local Char = GetChar(Plr)
			local Humanoid = GetHumanoid(Char)
			if Char and Humanoid then
				Camera.CameraSubject = Humanoid
			elseif Char then
				if Char:FindFirstChild("Head") then
					Camera.CameraSubject = Char:FindFirstChild("Head")
				else
					local Root = GetRoot(Char)
					if Root then
						Camera.CameraSubject = Root
					end
				end
			end
		end
	end,
})

GiveBtools = Other:CreateButton({
	Text = "Btools",
	Info = "Gives You Btools",
	Function = function()
        local Backpack = Plr:FindFirstChildWhichIsA("Backpack")
        if not Backpack then return end
		for i = 1, 4 do
			local Tool = Instance.new("HopperBin")
			Tool.BinType = i
			Tool.Name = "Tool"
            Tool.Parent = Backpack
		end
	end,
})

ClientBringTextbox = nil; ClientBringTextbox = Other:CreateTextbox({
	ButtonText = "Bring",
	PlaceholderText = "Player Name",
	Info = "Brings A Player To You (Client)",
	EnabledIndicator = true,
	Function = function(ClientBring)
		if ClientBring then
			Connections.Other.ClientBringLoop = RunService.Heartbeat:Connect(function()
				local Player = FindPlayer(ClientBringTextbox.Textbox.Text)
				local PlayerChar = GetChar(Player)
				local PlayerRoot = GetRoot(PlayerChar)
				local Char = GetChar(Plr)
				local Root = GetRoot(Char)
				if PlayerChar and PlayerRoot and Char and Root then
					PlayerRoot.CFrame = Root.CFrame
				end
			end)
		else
			if Connections.Other.ClientBringLoop then
				Connections.Other.ClientBringLoop:Disconnect()
				Connections.Other.ClientBringLoop = nil
			end
		end
	end,
})

ToggleShiftLock = Other:CreateToggle({
	Text = "Enable Shiftlock",
	Info = "Forces The Game To Allow Shiftlock",
	Function = function(ForceEnableShiftLock)
		if ForceEnableShiftLock then
			Plr.DevEnableMouseLock = true
			Connections.Other.ForceEnableShiftLockLoop = Plr:GetPropertyChangedSignal("DevEnableMouseLock"):Connect(function()
				Plr.DevEnableMouseLock = true
			end)
		else
			if Connections.Other.ForceEnableShiftLockLoop then
				Connections.Other.ForceEnableShiftLockLoop:Disconnect()
			end
		end
	end,
})

InvisGuis = {}
HiddenGuis = {}

ToggleHideGuis = nil

ToggleShowGuis = Other:CreateToggle({
	Text = "Show Guis",
	Info = "Shows Hidden Guis",
	Function = function(ShowGuis)
		if ShowGuis then
            ToggleHideGuis:Disable({NoNotify = true})
			for i, v in pairs(Plr:FindFirstChildWhichIsA("PlayerGui"):GetDescendants()) do
				if v:FindFirstAncestor(TidalWaveScreenGui.Name) then continue end
				if (v:IsA("Frame") or v:IsA("ImageLabel") or v:IsA("ScrollingFrame")) and not v.Visible then
					v.Visible = true
					if not table.find(InvisGuis, v) then
						table.insert(InvisGuis, v)
					end
				end
			end
		else
			for i,v in pairs(InvisGuis) do
				v.Visible = false
			end
			InvisGuis = {}
		end
	end,
})

ToggleHideGuis = Other:CreateToggle({
	Text = "Hide Guis",
	Info = "Hides Guis",
	Function = function(HideGuis)
		if HideGuis then
            ToggleShowGuis:Disable({NoNotify = true})
			for i, v in pairs(Plr:FindFirstChildWhichIsA("PlayerGui"):GetDescendants()) do
				if v:FindFirstAncestor(TidalWaveScreenGui.Name) then continue end
				if (v:IsA("Frame") or v:IsA("ImageLabel") or v:IsA("ScrollingFrame")) and v.Visible then
					v.Visible = false
					if not table.find(HiddenGuis, v) then
						table.insert(HiddenGuis, v)
					end
				end
			end
		else
			for i,v in pairs(HiddenGuis) do
				v.Visible = true
			end
			HiddenGuis = {}
		end
	end,
})

ToggleGuiDelete = Other:CreateToggle({
	Text = "Gui Delete",
	Info = "Deletes All Guis Your Mouse Is Hovering Over When Pressing Backspace Or Delete",
	Function = function(GuiDelete)
		local GuiDeleteInputBegan
		if GuiDelete then
			GuiDeleteInputBegan = UIS.InputBegan:Connect(function(Input)
				if ChatboxFocused() or TidalWaveFocused then return end
				if Input.KeyCode == Enum.KeyCode.Backspace or Input.KeyCode == Enum.KeyCode.Delete then
					for i, v in pairs(Plr:FindFirstChildWhichIsA("PlayerGui"):GetGuiObjectsAtPosition(Mouse.X, Mouse.Y)) do
                        if v:FindFirstAncestor(TidalWaveScreenGui.Name) then continue end
                        if v.Visible then
                            v:Destroy()
                        end
                    end
				end
			end)
		else
			if GuiDeleteInputBegan then
				GuiDeleteInputBegan:Disconnect()
                GuiDeleteInputBegan = nil
			end
		end
	end,
})

DataLimit = nil; DataLimit = Other:CreateTextbox({
	ButtonText = "Data Limit",
	PlaceholderText = "Number",
	MouseButton1Click = function()
        local DataLimitVal = tonumber(DataLimit.Textbox.Text)
        if not DataLimitVal then return end
		pcall(function()
            NetworkClient:SetOutgoingKBPSLimit(DataLimitVal)
        end)
	end,
})

SetReplicationLag = nil; SetReplicationLag = Other:CreateTextbox({
	ButtonText = "Replication Lag",
	PlaceholderText = "Number",
	MouseButton1Click = function()
		local ReplicationLag = tonumber(SetReplicationLag.Textbox.Text)
		if not ReplicationLag then return end
		pcall(function()
			settings():GetService("NetworkSettings").IncomingReplicationLag = ReplicationLag
		end)
	end,
})

ToggleAntiAfk = nil; ToggleAntiAfk = Other:CreateButton({
	Text = "Anti AFK",
	Info = "Prevents You From Getting Kicked For Being Idle",
	Function = function()
		if GetConnections then
			for i, v in pairs(GetConnections(Plr.Idled)) do
				if v["Disable"] then
					v["Disable"](v)
				elseif v["Disconnect"] then
					v["Disconnect"](v)
				end
			end
			ModuleToggled(ToggleAntiAfk, "Anti AFK", true)
		else
			Connections.Other.AntiAfkLoop = Plr.Idled:Connect(function()
				VirtualUser:CaptureController()
				VirtualUser:ClickButton2(Vector2.new())
			end)
		end
	end,
})

FixCamera = Other:CreateButton({
	Text = "Fix Camera",
	Info = "Attempts To Fix Your Camera (Might Not Work)",
	MouseButton1Click = function()
		if Toggles.ViewPlayer.Boolean then
			ToggleViewPlayer:Toggle({NoNotify = true})
		end
		if Toggles.Freecam.Boolean then
			ToggleFreecam:Toggle({NoNotify = true})
		end
		local Char = GetChar(Plr)
		local Root = GetRoot(Char)
		local Humanoid = GetHumanoid(Char)
		if Char and Humanoid then
			workspace.CurrentCamera.CameraSubject = Humanoid
		elseif Char and Char:FindFirstChild("Head") then
			workspace.CurrentCamera.CameraSubject = Char:FindFirstChild("Head")
		elseif Char and Root then
			workspace.CurrentCamera.CameraSubject = Root
		end
		workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	end,
})

ToggleNoclipCamera = Other:CreateToggle({
	Text = "Noclip Camera",
	Info = "Allows You To Move Your Camera Through Walls",
	MouseButton1Click = function(NoclipCamera)
        if not SetConstant then NotifyExploitDoesntSupportFunction("SetConstant"); return end
        if not GetConstants then NotifyExploitDoesntSupportFunction("GetConstants"); return end
        if not Getgc then NotifyExploitDoesntSupportFunction("Getgc"); return end
        local Pop = Plr:FindFirstChildWhichIsA("PlayerScripts").PlayerModule.CameraModule.ZoomController.Popper
		for i, v in pairs(Getgc()) do
            if type(v) == "function" and getfenv(v).script == Pop then
                for i2, v2 in pairs(GetConstants(v)) do
                    if tonumber(v2) == 0.25 and NoclipCamera then
                        SetConstant(v, i2, 0)
                    elseif tonumber(v2) == 0 and not NoclipCamera then
                        SetConstant(v, i2, 0.25)
                    end
                end
            end
        end
	end,
})

ToggleBubbleChat = Other:CreateToggle({
	Text = "Bubble Chat",
	Info = "Enables/Disables Bubble Chat",
	EnabledIndicatorDefault = true,
	MouseButton1Click = function(Enabled)
		local BubbleChat = TextChatService:FindFirstChildWhichIsA("BubbleChatConfiguration")
		if not BubbleChat then return end
		BubbleChat.Enabled = Enabled
	end,
})

ToggleCheckCaller = nil

SpoofValueButton = Other:CreateButton({
    Text = "Spoof Value",
    MouseButton1Click = function()
        if not Hookmetamethod then NotifyExploitDoesntSupportFunction("Hookmetamethod"); return end
        local Old; Old = Hookmetamethod(game, "__index", NewCClosure(function(self, Key)
            if CheckCaller and not CheckCaller() and ToggleCheckCaller.Enabled then return Old(self, Key) end
            if self == InstanceToSpoof and tostring(Key):lower() == ValueToSpoof then
                return SpoofValue
            end
            return Old(self, Key)
        end))
    end,
})

InstanceToSpoofTextbox = SpoofValueButton:CreateTextbox({
    ButtonText = "Instance To Spoof",
    PlaceholderText = "[Path]",
    Info = "The Instance With The Value You Wanna Spoof",
    FocusLost = function(Args)
		local LoadedString = loadstring(`return {Args.Text}`)
		if typeof(LoadedString) == "function" then
			InstanceToSpoof = LoadedString()
		else
			Notify({Text = LoadedString, Duration = 5})
		end
    end,
})

ValueToSpoofTextbox = SpoofValueButton:CreateTextbox({
    ButtonText = "Value To Spoof",
    PlaceholderText = "[Value]",
    Info = "The Value To Spoof",
    FocusLost = function(Args)
        ValueToSpoof = string.lower(Args.Text)
    end,
})

SpoofValueTextbox = SpoofValueButton:CreateTextbox({
    ButtonText = "Value",
    PlaceholderText = "[AnyValue]",
    Info = "The Value To Set It To",
    FocusLost = function(Args)
		local LoadedString = loadstring(`return {Args.Text}`)
        if typeof(LoadedString) == "function" then
			SpoofValue = LoadedString()
		else
			Notify({Text = LoadedString, Duration = 5})
		end
    end,
})

ToggleCheckCaller = SpoofValueButton:CreateToggle({
    Text = "Check Caller",
    Info = "Whether Or Not To Spoof The Value When Being Referenced From Your Executor",
    Default = true,
    MouseButton1Click = function()
        
    end,
})

ToggleSpoofFunctionCheckCaller = nil

SpoofFunction = Other:CreateButton({
    Text = "Spoof Function",
    MouseButton1Click = function()
        if not Hookmetamethod then NotifyExploitDoesntSupportFunction("Hookmetamethod"); return end
        if not GetNameCallMethod then NotifyExploitDoesntSupportFunction("GetNameCallMethod"); return end
        local Old; Old = Hookmetamethod(game, "__namecall", NewCClosure(function(self, ...)
            if CheckCaller and not CheckCaller() and ToggleSpoofFunctionCheckCaller.Enabled then return Old(self, ...) end
            local Method = GetNameCallMethod()
            if self == SpoofFunctionSelf and Method == SpoofFunctionMethod then
                if SpoofFunctionSelfToReturn == "self" then
                    return Old(self, unpack(SpoofFunctionArgs))
                else
                    return Old(SpoofFunctionSelfToReturn, unpack(SpoofFunctionArgs))
                end
            end
            return Old(self, ...)
        end))
    end,
})

SpoofFunctionSelfTextbox = SpoofFunction:CreateTextbox({
    ButtonText = "Function Self",
    PlaceholderText = "[Obj With Func]",
    FocusLost = function(Args)
		local LoadedString = loadstring(`return {Args.Text}`)
        if typeof(LoadedString) == "function" then
			SpoofFunctionSelf = LoadedString()
		else
			Notify({Text = LoadedString, Duration = 5})
		end
    end,
})

SpoofFunctionMethodTextbox = nil; SpoofFunctionMethodTextbox = SpoofFunction:CreateTextbox({
    ButtonText = "Method",
    PlaceholderText = "[Method]",
    Info = "Make Sure To Type The Exact Method Which For A Remote Event It Would Be \"FireServer\"",
    FocusLost = function()
        SpoofFunctionMethod = SpoofFunctionMethodTextbox.Textbox.Text
    end,
})

SpoofFunctionArgsTextbox = nil; SpoofFunctionArgsTextbox = SpoofFunction:CreateTextbox({
    ButtonText = "Args",
    PlaceholderText = "[Arg1, Arg2]",
    FocusLost = function(Args)
		local LoadedString = loadstring(`return \{{SpoofFunctionArgsTextbox.Text}\}`)
        if typeof(LoadedString) == "function" then
			SpoofFunctionArgs = LoadedString()
		else
			Notify({Text = LoadedString, Duration = 5})
		end
    end,
})

ToggleSpoofFunctionCheckCaller = SpoofFunction:CreateToggle({
    Text = "Check Caller",
    Info = "Whether Or Not To Spoof The Function When Being Called From Your Executor",
    Default = true,
    MouseButton1Click = function()
        
    end,
})

SpoofFunctionSelfToReturnTextbox = nil; SpoofFunctionSelfToReturnTextbox = SpoofFunction:CreateTextbox({
    ButtonText = "Self To Return",
    PlaceholderText = "[Obj]",
    Info = "Sets The Self Of The Function Which Allows You To Change The Instance Being Destroyed By Something Like Destroy() Or Remove()",
    FocusLost = function()
		local LoadedString = loadstring(`return {SpoofFunctionSelfToReturnTextbox.Textbox.Text}`)
        if typeof(LoadedString) == "function" then
			SpoofFunctionSelfToReturn = LoadedString
		else
			Notify({Text = LoadedString, Duration = 5})
		end
    end,
})

----------------------------------------------------------------------------------------------------- Settings Category

do
	ToggleAnimateWindows = MenuSettings:CreateToggle({
		Text = "Animate Windows",
		Info = "Toggles Menu Opening/Closing Animation",
		Function = function(Bool)
			AnimateWindows = Bool
		end,
	})

	ToggleAnimateWindows:CreateSlider({
		Text = "Animation Duration",
		Min = 0,
		Default = 0.2,
		Max = 2,
		Function = function(Val)
			MenuOpenSpeed = Val
		end,
		Function2 = function(Val)
			MenuOpenSpeed = Val
		end,
	})

	MenuEasingStyleDropdown = ToggleAnimateWindows:CreateDropdown({
		Text = "Easing Style",
		Default = MenuEasingStyle,
	})
	for i, EasingStyle in ipairs(Enum.EasingStyle:GetEnumItems()) do
		MenuEasingStyleDropdown:CreateButton({
			Text = EasingStyle.Name,
			Function = function()
				MenuEasingStyle = EasingStyle.Name
			end,
		})
	end

	MenuOpenEasingDirectionDropdown = ToggleAnimateWindows:CreateDropdown({
		Text = "Open Easing Direction",
		Default = MenuOpenEasingDirection,
	})
	for i, EasingDirection in ipairs(Enum.EasingDirection:GetEnumItems()) do
		MenuOpenEasingDirectionDropdown:CreateButton({
			Text = EasingDirection.Name,
			Function = function()
				MenuOpenEasingDirection = EasingDirection.Name
			end,
		})
	end

	MenuCloseEasingDirectionDropdown = ToggleAnimateWindows:CreateDropdown({
		Text = "Close Easing Direction",
		Default = MenuCloseEasingDirection,
	})
	for i, EasingDirection in ipairs(Enum.EasingDirection:GetEnumItems()) do
		MenuCloseEasingDirectionDropdown:CreateButton({
			Text = EasingDirection.Name,
			Function = function()
				MenuCloseEasingDirection = EasingDirection.Name
			end,
		})
	end
end

ToggleKeepCMDBarOpen = MenuSettings:CreateToggle({
	Text = "Keep CMD Bar Open",
	Function = function(Bool)
		KeepCMDBarOpen = Bool
		CMDCategory:MakeToggleable(not KeepCMDBarOpen)
	end,
})

ToggleNotifications = MenuSettings:CreateToggle({
	Text = "Notifications",
	EnabledIndicatorDefault = true,
	Function = function(Bool)
		NotifyOn = not Bool
	end,
})

function SaveProfileFunction(ProfileName)
	local ConfigsToSave = {
        Toggles = {},
        Values = {},
        Keybinds = TidalWaveKeybinds or {},
	}
	
    for i, v in pairs(Toggles) do
        if typeof(v) == "table" and v.Toggle and v.Boolean ~= nil then
            ConfigsToSave.Toggles[i] = v.Boolean
        end
    end

    for i, v in pairs(Values) do
        if typeof(v) == "table" then
            if v.UpdateSlider and v.Value ~= nil then
                ConfigsToSave.Values[i] = v.Value
            elseif v.Values then
                if v.CurrentValue ~= "" then
                    ConfigsToSave.Values[i] = v.CurrentValue
                else
                    ConfigsToSave.Values[i] = v.Values
                end
            elseif v.SetColor and v.Color then
                ConfigsToSave.Values[i] = {
                    R = v.Color.R,
                    G = v.Color.G,
                    B = v.Color.B,
                }
            end
        end
    end

	if RunService:IsStudio() then
		ReplicatedStorage:FindFirstChild("Data"):InvokeServer({
			Event = "SaveData",
			Data = ConfigsToSave,
			ProfileName = ProfileName,
		})
	else
		if not WriteFile then NotifyExploitDoesntSupportFunction("WriteFile"); return end
		CreateGlobalFiles()
		WriteFile(`TidalWave/Profiles/{ProfileName}.json`, HttpService:JSONEncode(ConfigsToSave))
	end
end

SaveProfile = nil; SaveProfile = MenuSettings:CreateTextbox({
	ButtonText =  "Save",
	PlaceholderText = "Profile Name",
	Info = "Saves All Your Options To A Profile.",
	Function = function()
		SaveProfileFunction(SaveProfile.Textbox.Text)
	end,
})

function TableToColor3(Table)
	if typeof(Table) ~= "table" then return end
	local R, G, B = tonumber(Table.R), tonumber(Table.G), tonumber(Table.B)
	if R and G and B then
		return Color3.new(R, G, B)
	end
	return nil
end

function TableToVector2(Table)
	if typeof(Table) ~= "table" then return end
	local X, Y = tonumber(Table.X), tonumber(Table.Y)
	if X and Y then
		return Vector2.new(X, Y)
	end
	return nil
end

function CheckValue(Value, Type: string, Alternate)
	if typeof(Value) == Type then
		return Value
	end
	return Alternate
end

function LoadProfileFunction(Json, ProfileName)
	local StartTime = tick()

    for i, v in pairs(Json.Toggles) do
        local Toggle = Toggles[i]
        if Toggle and Toggle.Enable and Toggle.Disable then
            if v == true then
                Toggle:Enable({NoNotify = true})
            elseif v == false then
                Toggle:Disable({NoNotify = true})
            end
        end
    end
    
	for i, v in pairs(Json.Values) do
        local Toggle = Values[i]
        if Toggle then
            if Toggle.Values then
                for i2, v2 in pairs(Toggle.Values) do
                    if typeof(v2) == "table" then
                        if v[i2] and v[i2].Selected == true and v2.Selected == false then
                            v2:Remove()
                        elseif v2[i2] and v[i2].Selected == false and v2.Selected == true then
                            v2:Add()
                        end
                    elseif i2 == v and typeof(v2) == "function" then
                        v2()
                    end
                end
            elseif Toggle.UpdateSlider then
                Toggle:UpdateSlider(v)
            elseif Toggle.SetColor then
                Toggle:SetColor(Color3.new(v.R, v.G, v.B))
            end
        end
    end

    TidalWaveKeybinds = Json.Keybinds or {}

	UpdateGlobalSettings()

	local LoadDuration = tick() - StartTime

    Notify({
        Text = `Loaded profile: {ProfileName} in {SubstituteNumber(LoadDuration, 3)} seconds.`
    })
end

LoadProfile = MenuSettings:CreateButton({
	Text = "Load Profile",
	Function = function()
		ProfileMenu.TopBar.Visible = true
		for i, v in ipairs(ProfileMenu.ScrollingFrame:GetChildren()) do
			if not v:IsA("UIListLayout") then
				v:Destroy()
			end
		end
		if RunService:IsStudio() then
			local Data = ReplicatedStorage:FindFirstChild("Data")
			if not Data then return end
            if not Data:IsA("RemoteFunction") then return end
			local Profiles = Data:InvokeServer({
				Event = "RequestData",
			})
			for i, v in pairs(Profiles) do
				CreateButton({
					Text = i,
					Parent = ProfileMenu.ScrollingFrame,
					ZIndex = 69423,
					Function = function()
						LoadProfileFunction(v, i)
					end,
				})
			end
		else
			if not ListFiles then NotifyExploitDoesntSupportFunction("ListFiles"); return end
			for i, v in ipairs(ListFiles("TidalWave/Profiles")) do
                local FileName = GetFileName(v)
				CreateButton({
					Text = FileName,
					Parent = ProfileMenu.ScrollingFrame,
					ZIndex = 69423,
					Function = function()
						if not IsFile then NotifyExploitDoesntSupportFunction("IsFile"); return end
						if not ReadFile then NotifyExploitDoesntSupportFunction("ReadFile"); return end
						if not IsFile(v) then return end
						local Json = HttpService:JSONDecode(ReadFile(v))
						LoadProfileFunction(Json, FileName)
					end,
				})
			end
		end
	end,
})

ReloadScript = MenuSettings:CreateButton({
    Text = "Reload Tidal Wave",
    Function = function()
        Shutdown()
        if not LoadFile then NotifyExploitDoesntSupportFunction("LoadFile"); return end
        LoadFile("TidalWave.lua")()
    end,
})

CloseScript = MenuSettings:CreateButton({
	Text = "Close Tidal Wave",
	Function = function()
		Shutdown()
	end,
})

SetAProfileToAutoLoad = MenuSettings:CreateButton({
	Text = "Auto Load Profile",
	Info = "The profile to load upon loading tidal wave.",
	Function = function()
		ProfileMenu.TopBar.Visible = true
		for i, v in pairs(ProfileMenu.ScrollingFrame:GetChildren()) do
			if not v:IsA("UIGridLayout") then
				v:Destroy()
			end
		end

		if not IsFile then NotifyExploitDoesntSupportFunction("IsFile"); return end
		if not WriteFile then NotifyExploitDoesntSupportFunction("WriteFile"); return end

		CreateButton({
			Text = "None",
			Parent = ProfileMenu.ScrollingFrame,
			MouseButton1Click = function()
				ProfileToAutoLoad = nil
				UpdateGlobalFiles()
				Notify({
					Text = "Set profile to auto load to none",
				})
			end,
		})

		if not ListFiles then NotifyExploitDoesntSupportFunction("ListFiles"); return end
		for i, Profile in pairs(ListFiles("TidalWave/Profiles")) do
			local ProfileName = string.gsub(string.split(Profile, "\\")[3], ".json", "")
			CreateButton({
				Text = ProfileName,
				Parent = ProfileMenu.ScrollingFrame,
				MouseButton1Click = function()
					ProfileToAutoLoad = Profile
					UpdateGlobalFiles()
					Notify({
						Text = `Set profile to auto load to {ProfileName}`,
					})
				end,
			})
		end
	end,
})

ToggleKeepTidalWave = MenuSettings:CreateToggle({
	Text = "Keep Tidal Wave",
	Info = "Keeps tidal wave opened when you teleport through games.",
	Function = function(Bool)
		CreateGlobalFiles()
		if not WriteFile then NotifyExploitDoesntSupportFunction("WriteFile"); return end
		if not QueueOnTeleport then NotifyExploitDoesntSupportFunction("QueueOnTeleport"); return end
		KeepTidalWave = Bool
		UpdateGlobalFiles()
	end,
})

ToggleHackList = MenuSettings:CreateToggle({
	Text = "Hack List",
	EnabledIndicatorDefault = true,
	Function = function(Bool)
		HackListFrame.Visible = Bool
	end,
})

ToggleHackListRGBText = ToggleHackList:CreateToggle({
	Text = "RGB Text",
	Info = "Make Text Cool And RGB :D",
	Function = function(Bool)
		HackListRGBText = Bool
		if HackListRGBText then
			for i, v in pairs(HackListFrame:GetChildren()) do
				if v:IsA("UIListLayout") then continue end
				v.HackLabel.UIGradient.Enabled = true
				task.spawn(function()
					while HackListRGBText and not StopScript do
						local Tween = TweenService:Create(v.HackLabel.UIGradient.Enabled, TweenInfo.new(3, Enum.EasingStyle.Linear), {Offset = Vector2.new(1, 0)})
						Tween:Play()
						Tween.Completed:Wait()
						v.HackLabel.UIGradient.Offset = Vector2.new(v.Size.X.Scale - 1, 0)
					end
				end)
			end
		else
			for i, v in pairs(HackListFrame:GetChildren()) do
				if v:IsA("UIListLayout") then continue end
				v.HackLabel.UIGradient.Enabled = false
			end
		end
	end,
})

ToggleAnimateCategories = MenuSettings:CreateToggle({
	Text = "Animate Categories",
	Info = "Toggles Animations For Hiding/Showing Categories",
	EnabledIndicatorDefault = true,
	Function = function(Bool)
		AnimateCategories = Bool
	end,
})

do
	local HelpMenu
	local HelpButton = MenuSettings:CreateToggle({
		Text = "Help",
		MouseButton1Click = function(Bool)
			HelpMenu.TopBar.Visible = Bool
		end,
	})

    HelpMenu = CreateMenu({
        Text = "Help",
        OnClose = function()
            ToggleButtonColor(HelpButton, HelpMenu.TopBar.Visible)
        end,
    })

    local HelpLabel = Instance.new("TextLabel")
    HelpLabel.BackgroundTransparency = 1
    HelpLabel.Size = UDim2.fromScale(0.95, 0.9)
    HelpLabel.TextSize = 16
    HelpLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    HelpLabel.Font = TextFont
    HelpLabel.RichText = true
    HelpLabel.AutomaticSize = Enum.AutomaticSize.Y
    HelpLabel.Text = [[

    <b>Toggling Modules</b>
    
    left click to toggle a module
    
    <b>Accessing Module Settings</b>
    
    right click to access the settings of a module
    
    <b>Making Keybinds For Modules</b>
    
    left click the keybind button in the settings of a module then press the key you want
    if you wanna cancel rebinding click off
    if you wanna delete the keybind press the x button
    
    <b>Editing Menu Keybinds</b>
    
    go to the keybinds category
    left click the pencil then press the key you want
    if you wanna cancel rebinding click off
    if you wanna delete the keybind press esc

    <b>Saving Profiles</b>

    go over to the settings category
    then look for the save profile textbox which is at the bottom of the settings category
    then type in whatever name you want into the textbox
    and once you typed in a name just click save

    <b>Loading Profiles</b>

    to load profiles you click the load profile button which is in the settings category
    then it will open up a menu of all your profiles
    and then you just simply left click on whatever profile you wanna load

    ]]

    HelpLabel.Parent = HelpMenu.ScrollingFrame

    local SupportedGameStatuses
    local SupportedGameStatusesMenu = CreateMenu({
        Text = "Supported Game Statuses",
        OnClose = function()
            SupportedGameStatuses:Disable()
        end,
    })

    SupportedGameStatuses = MenuSettings:CreateToggle({
        Text = "Supported Game Statuses",
        NoNotify = true,
        MouseButton1Click = function(Bool)
            SupportedGameStatusesMenu.MainFrame.Visible = Bool
        end,
    })

    CreateButton({
        Text = `Skywars: <font color = 'rgb(0, 255, 0)'>Working</font>`,
        RichText = true,
        Parent = SupportedGameStatusesMenu.ScrollingFrame,
    })
    CreateButton({
        Text = `Stair Climbing Simulator: <font color = 'rgb(0, 255, 0)'>Working</font>`,
        RichText = true,
        Parent = SupportedGameStatusesMenu.ScrollingFrame,
    })
    CreateButton({
        Text = `Flee The Facility: <font color = 'rgb(0, 255, 0)'>Working</font>`,
        RichText = true,
        Parent = SupportedGameStatusesMenu.ScrollingFrame,
    })
    CreateButton({
        Text = `Strongman Simulator: <font color = 'rgb(0, 255, 0)'>Working</font>`,
        RichText = true,
        Parent = SupportedGameStatusesMenu.ScrollingFrame,
    })
    CreateButton({
        Text = `Dead By Roblox: <font color = 'rgb(0, 255, 0)'>Working</font>`,
        RichText = true,
        Parent = SupportedGameStatusesMenu.ScrollingFrame,
    })
    CreateButton({
        Text = `Chick-n-Coop: <font color = 'rgb(255, 0, 0)'>Not Working</font>`,
        RichText = true,
        Parent = SupportedGameStatusesMenu.ScrollingFrame,
    })
    CreateButton({
        Text = `Out-n-In: <font color = 'rgb(255, 0, 0)'>Not Working</font>`,
        RichText = true,
        Parent = SupportedGameStatusesMenu.ScrollingFrame,
    })
end

SearchTextbox = SearchCategory:CreateTextbox({
	NoButton = true,
	SizeMulti = 3,
	Name = "SearchBar",
})

SearchTextbox.Textbox:GetPropertyChangedSignal("Text"):Connect(function()
    for i, Category in ipairs(CategoryHolderFrame:GetChildren()) do
        if Category == CMDCategory.TopBar or Category == SearchCategory.TopBar then continue end
        local Success, ContentScrollingFrame = pcall(function()
            return Category.ContentFrame.ContentScrollingFrame
        end)
        if not Success then continue end
        for i2, Button in ipairs(ContentScrollingFrame:GetChildren()) do
            if not (Button:IsA("Frame") or Button:IsA("ImageButton") or Button:IsA("TextButton")) then continue end
            local TextObject = Button:FindFirstChildWhichIsA("TextLabel") or Button:FindFirstChildWhichIsA("TextButton") or Button
            local Tags = nil
            if Button:GetAttribute("Tags") ~= "" then
                Tags = Button:GetAttribute("Tags")
            else
                Tags = nil
            end
			if not (TextObject:IsA("TextLabel") or TextObject:IsA("TextButton")) then continue end
            local ButtonText = string.lower(TextObject.Text)
            local SearchTextboxText = string.lower(SearchTextbox.Textbox.Text)
            if string.find(ButtonText, SearchTextboxText) or (Tags and string.find(Tags, ButtonText)) or string.find(string.gsub(ButtonText, " ", ""), SearchTextboxText) then
                Button.Visible = true
            else
                Button.Visible = false
            end
        end
    end
end)

CMDBar = CMDCategory:CreateTextbox({
    LayoutOrder = -1,
	NoButton = true,
	SizeMulti = 3,
	Name = "CMDBar",
	FocusLost = function(Properties)
		if not Properties.Enter then return end
        local Text; Text = Properties.Text:gsub(", ", " "):gsub(Text, ",", " ")
        local Args = Text:lower():split(" ")
        local CMD = Args[1]
        table.remove(Args, 1)
        ExecuteCMD(CMD, Args)
        Properties.Textbox.Text = ""
	end,
})

----------------------------------------------------------------------------------------------------- Commands

AddCmd("SpeedHack", {}, function(Args)
    local Speed = tonumber(Args[2])
    if Speed then
        WalkSpeedSlider:UpdateSlider(Speed)
    end
	ToggleSpeedHack:Enable()
end)

AddCmd("UnSpeedHack", {"NoSpeedHack"}, function(Args)
	ToggleSpeedHack:Disable()
end)

AddCmd("SpeedHackSpeed", {"Speed"}, function(Args)
    local Speed = tonumber(Args[2])
    if Speed then
        WalkSpeedSlider:UpdateSlider(Speed)
    end
end)

AddCmd("SpeedHackMethod", {}, function(Args)
	local Args2 = Args[2] and Args[2]:lower()
	if Args2 == "bodyvelocity" or Args2 == "bvelocity" or Args2 == "bvel" or Args2 == "bodyv" or Args2 == "bodyvel" or Args2 == "bv" then
		SpeedHackMethod = "BodyVelocity"
	elseif Args2 == "linearvelocity" or Args2 == "linearvel" or Args2 == "lvelocity" or Args2 == "linearv" or Args2 == "lv" then
		SpeedHackMethod = "LinearVelocity"
	elseif Args2 == "bodyforce" or Args2 == "bforce" or Args2 == "bodyf" or Args2 == "bf" then
		SpeedHackMethod = "BodyForce"
	elseif Args2 == "vectorforce" or Args2 == "vforce" or Args2 == "vectorf" or Args2 == "vf" then
		SpeedHackMethod = "VectorForce"
    elseif Args2 == "teleportwalk" or Args2 == "tpwalk" or Args2 == "tpw" then
        SpeedHackMethod = "TpWalk"
    elseif Args2 == "assemblylinearvelocity" or Args2 == "assemblylinearvel" or Args2 == "assemblyvel" or Args2 == "alvel" or Args2 == "alv" then
        SpeedHackMethod = "AssemblyLinearVelocity"
	end
end)

AddCmd("LoopJumpPower", {"LoopJP"}, function(Args)
    local JP = tonumber(Args[2])
    if JP then
        JumpPowerSlider:UpdateSlider(JP)
    end
	ToggleJumpPower:Enable()
end)

AddCmd("UnLoopJumpPower", {"NoLoopJumpPower"}, function()
	ToggleJumpPower:Disable()
end)

AddCmd("JumpPower", {"SetJumpPower", "SetJP"}, function(Args)
	JumpPower = tonumber(Args[2]) or JumpPower
end)

AddCmd("Gravity", {"LoopGravity"}, function(Args)
    local Grav = tonumber(Args[2])
	if Grav then
        GravitySlider:UpdateSlider(Grav)
    end
	ToggleGravity:Enable()
end)

AddCmd("UnLoopGravity", {"NoLoopGravity"}, function()
	ToggleGravity:Disable()
end)

AddCmd("Noclip", {}, function(Args)
	ToggleNoclip:Enable()
end)

AddCmd("Clip", {"UnNoclip", "NoNoclip"}, function(Args)
	ToggleNoclip:Disable()
end)

AddCmd("InfiniteJump", {"InfJump"}, function()
	ToggleInfiniteJump:Enable()
end)

AddCmd("UnInfiniteJump", {"NoInfiniteJump"}, function()
	ToggleInfiniteJump:Disable()
end)

AddCmd("Fly", {}, function(Args)
    local Speed = tonumber(Args[2])
	if Speed then
        FlySpeedSlider:UpdateSlider(Speed)
    end
	ToggleFly:Enable()
end)

AddCmd("UnFly", {"NoFly"}, function()
	ToggleFly:Disable()
end)

AddCmd("FlySpeed", {}, function(Args)
	local Speed = tonumber(Args[2])
	if Speed then
        FlySpeedSlider:UpdateSlider(Speed)
    end
end)

AddCmd("Float", {}, function()
	ToggleFloat:Enable()
end)

AddCmd("UnFloat", {"NoFloat"}, function()
	ToggleFloat:Disable()
end)

AddCmd("ClickTeleport", {"ClickTP"}, function(Args)
	local KeyCode = EnumFromName(Enum.KeyCode, Args[2])
	if KeyCode then
		TidalWaveKeybinds.ClickTeleport = KeyCode.Name
	end
	ToggleClickTeleport:Enable()
end)

AddCmd("UnClickTeleport", {"UnClickTP", "NoClickTP"}, function()
	ToggleClickTeleport:Disable()
end)

AddCmd("ClickTeleportKeybind", {"ClickTpKeybind"}, function(Args)
	local KeyCode = EnumFromName(Enum.KeyCode, Args[2])
	if KeyCode then
		TidalWaveKeybinds.ClickTeleport = KeyCode.Name
	else
		Notify({
			Text = "Invalid Key Code",
		})
	end
end)

AddCmd("CFrameFly", {"CFly"}, function(Args)
    local Speed = tonumber(Args[2])
    if Speed then
        CFrameFlySpeedSlider:UpdateSlider(Speed)
    end
	ToggleCFrameFly:Enable()
end)

AddCmd("UnCFrameFly", {"NoCFrameFly", "UnCFly", "NoCFly"}, function()
	ToggleCFrameFly:Disable()
end)

AddCmd("CFrameFlySpeed", {"CFlySpeed"}, function(Args)
    local Speed = tonumber(Args[2])
    if Speed then
        CFrameFlySpeedSlider:UpdateSlider(Speed)
    end
end)

AddCmd("Swim", {}, function()
	ToggleSwim:Enable()
end)

AddCmd("UnSwim", {"NoSwim"}, function()
	ToggleSwim:Disable()
end)

AddCmd("WalkFling", {}, function()
	ToggleWalkFling:Enable()
end)

AddCmd("UnWalkFling", {"NoWalkFling"}, function()
	ToggleWalkFling:Disable()
end)

AddCmd("SpiderHack", {"Spider"}, function(Args)
	SpiderHackSpeed = tonumber(Args[2]) or SpiderHackSpeed
	ToggleSpiderHack:Enable()
end)

AddCmd("UnSpiderHack", {"NoSpiderHack"}, function()
	ToggleSpiderHack:Disable()
end)

AddCmd("SpiderHackSpeed", {"SpiderSpeed"}, function(Args)
    local Speed = tonumber(Args[2])
    if Speed then
        SpiderHackSpeedSlider:UpdateSlider(Speed)
    end
end)

AddCmd("SpiderHackRadius", {"SpiderRadius"}, function(Args)
    local Speed = tonumber(Args[2])
    if Speed then
        SpiderHackRadiusSlider:UpdateSlider(Speed)
    end
end)

AddCmd("NoShadows", {}, function()
	ToggleNoShadows:Enable()
end)

AddCmd("UnNoShadows", {"Shadows"}, function()
	ToggleNoShadows:Disable()
end)

AddCmd("NoDepthOfField", {}, function()
	ToggleNoShadows:Enable()
end)

AddCmd("UnNoDepthOfField", {"DepthOfField"}, function()
	ToggleNoShadows:Disable()
end)

AddCmd("NoFog", {}, function()
	ToggleNoFog:Enable()
end)

AddCmd("UnNoFog", {"Fog"}, function()
	ToggleNoFog:Disable()
end)

AddCmd("NoAtmosphere", {}, function()
	ToggleNoAtmosphere:Enable()
end)

AddCmd("UnNoAtmosphere", {"Atmosphere"}, function()
	ToggleNoAtmosphere:Disable()
end)

AddCmd("NoBloom", {}, function()
	ToggleNoBloom:Enable()
end)

AddCmd("UnNoBloom", {"Bloom"}, function()
	ToggleNoBloom:Disable()
end)

AddCmd("NoBlur", {}, function()
	ToggleNoBlur:Enable()
end)

AddCmd("UnNoBlur", {"Blur"}, function()
	ToggleNoBlur:Disable()
end)

AddCmd("NoColorCorrection", {}, function()
	ToggleNoColorCorrection:Enable()
end)

AddCmd("UnNoColorCorrection", {"ColorCorrection"}, function()
	ToggleNoColorCorrection:Disable()
end)

AddCmd("NoSunRays", {}, function()
	ToggleNoSunRays:Enable()
end)

AddCmd("UnNoSunRays", {"SunRays"}, function()
	ToggleNoSunRays:Disable()
end)

AddCmd("NoSky", {}, function()
	ToggleNoSky:Enable()
end)

AddCmd("UnNoSky", {"Sky"}, function()
	ToggleNoSky:Disable()
end)

AddCmd("NoColorGrading", {}, function()
	ToggleNoColorGrading:Enable()
end)

AddCmd("UnNoColorGrading", {"ColorGrading"}, function()
	ToggleNoColorGrading:Disable()
end)

AddCmd("ForceTimeOfDay", {"SetTimeOfDay", "LoopSetTimeOfDay"}, function(Args)
	local Time = tonumber(Args[2])
	if Time then
		ForceTimeOfDaySlider:UpdateSlider(Time)
	end
	ToggleForceTimeOfDay:Enable()
end)

AddCmd("UnForceTimeOfDay", {"NoForceTimeOfDay"}, function()
	ToggleForceTimeOfDay:Disable()
end)

AddCmd("Brightness", {"LoopBrightness"}, function(Args)
    local NewBrightness = tonumber(Args[2])
    if NewBrightness then
        BrightnessSlider:UpdateSlider(NewBrightness)
    end
	ToggleBrightness:Enable()
end)

AddCmd("UnLoopBrightness", {}, function()
	ToggleBrightness:Disable()
end)

AddCmd("NoLightingEffects", {}, function()
	ToggleNoShadows:Enable({NoNotify = true})
	ToggleNoDepthOfField:Enable({NoNotify = true})
	ToggleNoFog:Enable({NoNotify = true})
	ToggleNoAtmosphere:Enable({NoNotify = true})
	ToggleNoBloom:Enable({NoNotify = true})
	ToggleNoBlur:Enable({NoNotify = true})
	ToggleNoColorCorrection:Enable({NoNotify = true})
	ToggleNoSunRays:Enable({NoNotify = true})
	ToggleNoSky:Enable({NoNotify = true})
	ToggleNoColorGrading:Enable({NoNotify = true})
	Notify({
		Text = "Lighting Effects Have Been <b><font color = 'rgb(255, 0, 0)'>Disabled</font></b>",
	})
end)

AddCmd("FullBright", {}, function()
    ToggleNoShadows:Enable({NoNotify = true})
	ToggleNoDepthOfField:Enable({NoNotify = true})
	ToggleNoFog:Enable({NoNotify = true})
	ToggleNoAtmosphere:Enable({NoNotify = true})
	ToggleNoBloom:Enable({NoNotify = true})
	ToggleNoBlur:Enable({NoNotify = true})
	ToggleNoColorCorrection:Enable({NoNotify = true})
	ToggleNoSunRays:Enable({NoNotify = true})
	ToggleNoSky:Enable({NoNotify = true})
	ToggleNoColorGrading:Enable({NoNotify = true})
    BrightnessSlider:UpdateSlider(3)
    Lighting.Brightness = Brightness
	ToggleBrightness:Enable({NoNotify = true})
    Ambient = Color3.fromRGB(255, 255, 255)
    Lighting.Ambient = Ambient
	ToggleAmbient:Enable({NoNotify = true})
    OutdoorAmbient = Color3.fromRGB(255, 255, 255)
    Lighting.OutdoorAmbient = OutdoorAmbient
    ToggleOutdoorAmbient:Enable({NoNotify = true})
    ColorShiftBottom = Color3.fromRGB(255, 255, 255)
    Lighting.ColorShift_Bottom = ColorShiftBottom
    ToggleColorShiftBottom:Enable({NoNotify = true})
    ColorShiftTop = Color3.fromRGB(255, 255, 255)
    Lighting.ColorShift_Top = ColorShiftTop
    ToggleColorShiftTop:Enable({NoNotify = true})
    ForceTimeOfDaySlider:UpdateSlider(12)
    Lighting.ClockTime = ForceTimeOfDay
    ToggleForceTimeOfDay:Enable({NoNotify = true})
    EnvironmentDiffuseScaleSlider:UpdateSlider(0)
	ToggleEnvironmentDiffuseScale:Enable({NoNotify = true})
    EnvironmentSpecularScaleSlider:UpdateSlider(0)
	ToggleEnvironmentSpecularScale:Enable({NoNotify = true})
	Notify({
		Text = "Fullbright Has Been <b><font color = 'rgb(0, 255, 0)'>Enabled</font></b>",
	})
end)

AddCmd("PlayerHighlightESP", {}, function()
	TogglePlayerHighlightESP:Enable()
end)

AddCmd("UnPlayerHighlightESP", {"NoPlayerHighlightESP"}, function()
	TogglePlayerHighlightESP:Disable()
end)

AddCmd("PlayerTracers", {"PlrTracers"}, function()
	TogglePlayerTracers:Enable()
end)

AddCmd("UnPlayerTracers", {"NoPlayerTracers"}, function()
	TogglePlayerTracers:Disable()
end)

AddCmd("HealthESP", {"HpESP"}, function()
	ToggleHealthESP:Enable()
end)

AddCmd("UnHealthESP", {"NoHealthESP"}, function()
	ToggleHealthESP:Disable()
end)

AddCmd("NameESP", {}, function()
	ToggleNameESP:Enable()
end)

AddCmd("UnNameESP", {"NoNameESP"}, function()
	ToggleNameESP:Disable()
end)

AddCmd("DistanceESP", {}, function()
	ToggleDistanceESP:Enable()
end)

AddCmd("UnDistanceESP", {"NoDistanceESP"}, function()
	ToggleDistanceESP:Disable()
end)

AddCmd("WalkSpeedESP", {"SpeedESP"}, function()
	ToggleWalkSpeedESP:Enable()
end)

AddCmd("UnWalkSpeedESP", {"NoWalkSpeedESP"}, function()
	ToggleWalkSpeedESP:Disable()
end)

AddCmd("JumpPowerESP", {"JpEsp"}, function()
	ToggleJumpPowerESP:Enable()
end)

AddCmd("UnJumpPowerESP", {"NoJumpPowerESP"}, function()
	ToggleJumpPowerESP:Disable()
end)

AddCmd("PlayerDrawingESP", {"PlrDrawingESP"}, function()
	TogglePlayerDrawingESP:Enable()
end)

AddCmd("UnPlayerDrawingESP", {"NoPlayerDrawingESP"}, function()
	TogglePlayerDrawingESP:Disable()
end)

AddCmd("InvisibleParts", {"InvisParts"}, function()
	ToggleInvisibleParts:Enable()
end)

AddCmd("UnInvisibleParts", {"UnInvisParts", "NoInvisParts"}, function()
	ToggleInvisibleParts:Disable()
end)

AddCmd("FieldOfView", {"Fov"}, function(Args)
    local FieldOfView = tonumber(Args[2])
    if FieldOfView then
        FieldOfViewSlider:UpdateSlider(FieldOfView)
    end
    ToggleLoopFov:Enable()
end)

AddCmd("UnLoopFov", {"NoLoopFov"}, function()
	ToggleLoopFov:Disable()
end)

AddCmd("FixCamera", {"FixCam"}, function()
	FixCamera:Toggle()
end)

AddCmd("NoclipCamera", {"NoclipCam"}, function()
	ToggleNoclipCamera:Enable()
end)

AddCmd("UnNoclipCamera", {"ClipCamera"}, function()
	ToggleNoclipCamera:Disable()
end)

AddCmd("ServerHop", {}, function()
	ServerHop:Toggle()
end)

AddCmd("Rejoin", {"RJ"}, function()
	Rejoin:Toggle()
end)

AddCmd("View", {"Spectate"}, function(Args)
	ToggleViewPlayer.Textbox.Text = Args[2]
	if Toggles.ViewPlayer.Boolean then
		ToggleViewPlayer:Toggle()
        task.wait()
		ToggleViewPlayer:Toggle()
	else
		ToggleViewPlayer:Toggle()
	end
end)

AddCmd("UnView", {"NoView"}, function()
	ToggleViewPlayer:Disable()
end)

AddCmd("Freecam", {"Fc"}, function()
	ToggleFreecam:Enable()
end)

AddCmd("UnFreecam", {"UnFc"}, function()
	ToggleFreecam:Disable()
end)

AddCmd("Orbit", {}, function(Args)
	local Speed = tonumber(Args[3])
	local Distance = tonumber(Args[4])
    if Speed then
        OrbitSpeedSlider:UpdateSlider(Speed)
    end
	if Distance then
        OrbitDistanceSlider:UpdateSlider(Distance)
    end
	ToggleOrbitPlayer.Textbox.Text = Args[2]
	ToggleOrbitPlayer:Enable()
end)

AddCmd("FlyJump", {}, function()
	ToggleFlyJump:Enable()
end)

AddCmd("UnFlyJump", {"NoFlyJump"}, function()
	ToggleFlyJump:Disable()
end)

AddCmd("Goto", {"To"}, function(Args)
	local Char = GetChar(Plr)
	local Root = GetRoot(Char)
	local Player = FindPlayer(Args[2])
	local PlayerChar = GetChar(Player)
	local PlayerRoot = GetRoot(PlayerChar)
	if not (Char and Root and Player and PlayerChar and PlayerRoot) then return end
	Root.CFrame = PlayerRoot.CFrame
end)

AddCmd("AddAlias", {}, function(Args)
	if Args[2] and Args[3] then
		AddAlias(Args[2], Args[3])
	end
end)

AddCmd("RemoveAlias", {}, function(Args)
	if Args[2] then
		RemoveAlias(Args[2])
	end
end)

AddCmd("GotoPos", {"ToPos"}, function(Args)
	local Char = GetChar(Plr)
	local Root = GetRoot(Char)

	if not (Char and Root) then return end

    local X = tonumber(Args[2])
    local Y = tonumber(Args[3])
    local Z = tonumber(Args[4])
	if not (X and Y and Z) then return end
    local CF = CFrame.new(X, Y, Z)
    CF *= CFrame.Angles(0, math.rad(Root.Rotation.Y), 0)

	Root.CFrame = CF
end)

AddCmd("NoClickDetectorLimits", {"NoCDLimits"}, function()
	NoClickDetectorLimits:Toggle()
end)

AddCmd("FireClickDetectors", {"FireCD"}, function()
	FireClickDetectors:Toggle()
end)

AddCmd("NoProximityPromptLimits", {"NoPPLimits"}, function()
	NoProximityPromptLimits:Toggle()
end)

AddCmd("InstantProximityPrompts", {"InstantPP"}, function()
	ToggleInstantProximityPrompts:Enable()
end)

AddCmd("UnInstantProximityPrompts", {"UnInstantPP"}, function()
	ToggleInstantProximityPrompts:Disable()
end)

AddCmd("Xray", {}, function()
	ToggleXray:Enable()
end)

AddCmd("UnXray", {"NoXray"}, function()
	ToggleXray:Disable()
end)

AddCmd("VehicleNoclip", {"VNoclip"}, function()
	ToggleVehicleNoclip:Enable()
end)

AddCmd("UnVehicleNoclip", {"NoVehicleNoclip", "UnVNoclip", "NoVNoclip"}, function()
	ToggleVehicleNoclip:Disable()
end)

AddCmd("ClickPartToSelect", {}, function()
	ToggleClickPartToSelect:Enable()
end)

AddCmd("UnClickPartToSelect", {"NoClickPartToSelect"}, function()
	ToggleClickPartToSelect:Disable()
end)

AddCmd("AntiVoid", {}, function(Args)
	ToggleAntiVoid:Enable()
end)

AddCmd("UnAntiVoid", {"NoAntiVoid"}, function()
	ToggleAntiVoid:Disable()
end)

AddCmd("ClickDelete", {"ClickDel"}, function()
	ToggleClickDelete:Enable()
end)

AddCmd("UnClickDelete", {"UnClickDel", "NoClickDelete", "NoClickDel"}, function()
	ToggleClickDelete:Disable()
end)

AddCmd("DeleteInvisibleParts", {"DeleteInvisParts"}, function()
	for i, v in ipairs(workspace:GetDescendants()) do
        if v:IsA("BasePart") and v.Transparency == 1 and v.CanCollide then
            v:Destroy()
        end
    end
end)

AddCmd("Tpua", {}, function()
	TeleportUnAchored:Toggle()
end)

AddCmd("DeleteInstance", {"DeleteObject"}, function(Args)
	local Name = Args[2] and Args[2]:lower()
    if not Name then return end
	for i, v in ipairs(workspace:GetDescendants()) do
		if v.Name:lower() == Name then
			v:Destroy()
		end
	end
end, "Deletes all instances in workspace with the specified name.", "[name]")

AddCmd("DeleteInstanceOfClass", {}, function(Args)
	local Class = Args[2] and Args[2]:lower()
    if not Class then return end
	for i, v in pairs(workspace:GetDescendants()) do
		if v.ClassName:lower() == Class then
			v:Destroy()
		end
	end
end, "Deletes all instances in workspace with the specified class name.", "[class]")

AddCmd("ServerHop", {"Shop"}, function()
	ServerHop:Toggle()
end, "Teleports you to a random server.")

AddCmd("UIScale", {"GUIScale"}, function(Args)
	local Scale = tonumber(Args[2])
    if Scale then
        TidalWaveUIScale.Scale = Scale
    end
end, "Sets the scale of tidal wave gui.", "[number]")

AddCmd("RemoteSpy", {"RSpy"}, function(Args)
    RunRemoteSpy:Toggle()
end, "Runs remote spy")

AddCmd("Dex", {"Explorer"}, function(Args)
    RunDex:Toggle()
end, "Runs dex.")

AddCmd("InfiniteYield", {"InfYield", "IY"}, function(Args)
    RunInfiniteYield:Toggle()
end, "Runs infinite yield")

AddCmd("AudioLogger", {}, function(Args)
    RunAudioLogger:Toggle()
end, "Runs audio logger")

AddCmd("WallWalker", {}, function(Args)
    RunWallWalker:Toggle()
end, "Runs wall walker")

AddCmd("F3X", {}, function(Args)
    RunF3X:Toggle()
end, "Runs F3X")

AddCmd("Cobalt", {}, function(Args)
    RunCobalt:Toggle()
end, "Runs cobalt")

AddCmd("SigmaSpy", {}, function(Args)
    RunSigmaSpy:Toggle()
end, "Runs sigma spy.")

AddCmd("Reset", {}, function(Args)
    local Char = GetChar(Plr)
    local Humanoid = GetHumanoid(Char)
    if Char and Humanoid then
        Humanoid:ChangeState(Enum.HumanoidStateType.Dead)
    end
end, "Resets your character.")

AddCmd("PromptR6", {}, function(Args)
    local Char = GetChar(Plr)
    local Humanoid = GetHumanoid(Char)
    if not (Char and Humanoid) then return end
    AvatarEditorService:PromptSaveAvatar(Humanoid.HumanoidDescription, Enum.HumanoidRigType.R6)
    local Result = AvatarEditorService.PromptSaveAvatarCompleted:Wait()
    if Result == Enum.AvatarPromptResult.Success then
        Humanoid:ChangeState(Enum.HumanoidStateType.Dead)
    end
end, "prompts you to switch to R6.")

AddCmd("PromptR15", {}, function(Args)
    local Char = GetChar(Plr)
    local Humanoid = GetHumanoid(Char)
    if not (Char and Humanoid) then return end
    AvatarEditorService:PromptSaveAvatar(Humanoid.HumanoidDescription, Enum.HumanoidRigType.R15)
    local Result = AvatarEditorService.PromptSaveAvatarCompleted:Wait()
    if Result == Enum.AvatarPromptResult.Success then
        Humanoid:ChangeState(Enum.HumanoidStateType.Dead)
    end
end, "prompts you to switch to R15.")

AddCmd("FreecamGoto", {"FreecamTo"}, function(Args)
    local Player = FindPlayer(Args[2])
    local PlayerChar = GetChar(Player)
    local PlayerRoot = GetRoot(PlayerChar)
    if not (Player and PlayerChar and PlayerRoot) then return end
    StartFreecam(PlayerRoot.CFrame)
end, "Teleports freecam to the specified player.", "[name]")

AddCmd("FreecamGotoPos", {"FreecamToPos"}, function(Args)
    local X, Y, Z = tonumber(Args[2]), tonumber(Args[3]), tonumber(Args[4])
    if X and Y and Z then
        StartFreecam(CFrame.new(X, Y, Z))
    end
end, "Teleports freecam to the specified position.", "[X, Y, Z]")

AddCmd("TeleportToPos", {"TpToPos"}, function(Args)
    local Char = GetChar(Plr)
    local Root = GetRoot(Char)
    local X, Y, Z = tonumber(Args[2]), tonumber(Args[3]), tonumber(Args[4])
    local TweenTime = tonumber(Args[4])
    if Char and Root and X and Y and Z then
        local Pos =  Vector3.new(X, Y, Z)
        if TweenTime == 0 or TweenTime == nil then
            Root.CFrame = CFrame.new(Pos)
        else
            local Tween = TweenService:Create(Root, TweenInfo.new(TweenTime, Enum.EasingStyle.Linear), {CFrame = CFrame.new(Pos)})
            Tween:Play()
        end
    end
end, "Teleports you to the specified position.", "[X, Y, Z]")

AddCmd("SaveGame", {}, function()
    if SaveInstance then
        Notify({Text = "Started Saving The Game"})
        SaveInstance(game)
        Notify({Text = "Finished Saving The Game"})
    else
        NotifyExploitDoesntSupportFunction("SaveInstance")
    end
end, "Saves the game to your exploit's workspace folder.")

AddCmd("CancelTeleport", {}, function(Args)
    pcall(function()
        TeleportService:Cancel()
    end)
end, "Cancels teleports in progress.")

AddCmd("UnsuspendVC", {"NoSuspendVC"}, function(Args)
    if Connections.Other.OnVoiceModerated then
        Connections.Other.OnVoiceModerated:Disconnect()
        Connections.Other.OnVoiceModerated = nil
    end
    VoiceChatService:joinVoice()
    Connections.Other.OnVoiceModerated = VoiceChatInternal.LocalPlayerModerated:Connect(function()
        task.wait(1)
        VoiceChatService:joinVoice()
    end)
end, "Unsuspends voice chat.")

do
	CMDBar.Textbox:GetPropertyChangedSignal("Text"):Connect(function()
		local String = CMDBar.Textbox.Text:gsub("\t", "")
		CMDBar.Textbox.Text = String
		for i, v in CMDCategory.ScrollingFrame:GetChildren() do
			if v:IsA("UIListLayout") or v == CMDBar.MainFrame then continue end
			local Text, Str = v.Text:lower(), String:lower()
			if Text:find(Str) then
				v.Visible = true
				if Text:sub(1, #Str) == Str then
                    if Text == Str then
                        v.LayoutOrder = -1
                    else
                        v.LayoutOrder = 0
                    end
				else
					v.LayoutOrder = 1
				end
			else
				v.Visible = false
			end
		end
	end)

	local SoundID
    local Start = 0
    local End = 5
    local Volume = 0.5
	CreateGlobalFiles()
	if ListFiles and GetCustomAsset then
		local StartUpSounds = ListFiles("TidalWave/StartUpSounds")
		if #StartUpSounds > 0 then
            local RandomFile = StartUpSounds[math.random(1, #StartUpSounds)]
            local FileType = GetFileType(RandomFile)
            if FileType == "Folder" and ReadFile then
                local Files = ListFiles(RandomFile)
                for i, v in ipairs(Files) do
                    local vFileType = GetFileType(v)
                    if vFileType == "json" then
                        local Json = HttpService:JSONDecode(ReadFile(v))
                        if Json.Start then
                            Start = Json.Start
                        end
                        if Json.End then
                            End = Json.End
                        end
                        if Json.Volume then
                            Volume = Json.Volume
                        end
                        if Json.ID then
                            SoundID = Json.SoundID
                        end
                    elseif vFileType == "mp3" or vFileType == "wav" or vFileType == "ogg" then
                        SoundID = GetCustomAsset(v)
                    end
                end
            elseif FileType == "txt" and ReadFile then
                local ID = tonumber(ReadFile(RandomFile))
                if ID then
                    SoundID = ID
                end
            elseif FileType == "mp3" then
                SoundID = GetCustomAsset(RandomFile)
            end
		end
	end
    UpdateGlobalSettings()
	RunService.RenderStepped:Wait()
	Notify({
		Text = `Successfully loaded tidal wave in {SubstituteNumber(tick() - TidalWaveLoadStartTime, 3)} seconds. Press {MenuKeybind} to toggle gui`,
		Start = Start,
        End = End,
		SoundID = SoundID,
		Volume = Volume,
	})
end
